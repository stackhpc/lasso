/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.24
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */


#ifndef SWIG_TEMPLATE_DISAMBIGUATOR
#  if defined(__SUNPRO_CC) 
#    define SWIG_TEMPLATE_DISAMBIGUATOR template
#  else
#    define SWIG_TEMPLATE_DISAMBIGUATOR 
#  endif
#endif

/***********************************************************************
 * swigrun.swg
 *
 *     This file contains generic CAPI SWIG runtime support for pointer
 *     type checking.
 *
 ************************************************************************/

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "1"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
#define SWIG_QUOTE_STRING(x) #x
#define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
#define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
#define SWIG_TYPE_TABLE_NAME
#endif

#include <string.h>

#ifndef SWIGINLINE
#if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#  define SWIGINLINE inline
#else
#  define SWIGINLINE
#endif
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the swig runtime code.
  In 99.9% of the cases, swig just needs to declare them as 'static'.
  
  But only do this if is strictly necessary, ie, if you have problems
  with your compiler or so.
*/
#ifndef SWIGRUNTIME
#define SWIGRUNTIME static
#endif
#ifndef SWIGRUNTIMEINLINE
#define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return *f1 - *f2;
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te) == 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Register a type mapping with the type-checking
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeRegisterTL(swig_type_info **tl, swig_type_info *ti) {
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = *tl;
  while (tc) {
    /* check simple type equivalence */
    int typeequiv = (strcmp(tc->name, ti->name) == 0);   
    /* check full type equivalence, resolving typedefs */
    if (!typeequiv) {
      /* only if tc is not a typedef (no '|' on it) */
      if (tc->str && ti->str && !strstr(tc->str,"|")) {
	typeequiv = SWIG_TypeEquiv(ti->str,tc->str);
      }
    }
    if (typeequiv) {
      /* Already exists in the table.  Just add additional types to the list */
      if (ti->clientdata) tc->clientdata = ti->clientdata;
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = *tl;
  *tl = ti;

  /* Build linked lists */
  l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;
  head->next = next;

  return ret;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
        s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_type_info *ty, void *ptr) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
  Search for a swig_type_info structure
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryTL(swig_type_info *tl, const char *name) {
  swig_type_info *ty = tl;
  while (ty) {
    if (ty->str && (SWIG_TypeEquiv(ty->str,name))) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientDataTL(swig_type_info *tl, swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = tl;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0))
          SWIG_TypeClientDataTL(tl,tc,clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static char hex[17] = "0123456789abcdef";
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  register unsigned char uu;
  for (; u != eu; ++u) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register int d = *(c++);
    register unsigned char uu = 0;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
  This function will propagate the clientdata field of type to any new
  swig_type_info structures that have been added into the list of
  equivalent types.  It is like calling SWIG_TypeClientData(type,
  clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientDataTL(swig_type_info *tl, swig_type_info *type) {
  swig_type_info *equiv = type->next;
  swig_type_info *tc;
  if (!type->clientdata) return;
  while (equiv) {
    if (!equiv->converter) {
      tc = tl;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0) && !tc->clientdata)
          SWIG_TypeClientDataTL(tl,tc, type->clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/


#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if !defined(STATIC_LINKED)
#    define SWIGEXPORT(a) __declspec(dllexport) a
#  else
#    define SWIGEXPORT(a) a
#  endif
#else
#  define SWIGEXPORT(a) a
#endif

#ifdef __cplusplus
extern "C" {
#endif


/*************************************************************************/


/* The static type info list */

static swig_type_info *swig_type_list = 0;
static swig_type_info **swig_type_list_handle = &swig_type_list;
  

/* Register a type mapping with the type-checking */
static swig_type_info *
SWIG_TypeRegister(swig_type_info *ti) {
  return SWIG_TypeRegisterTL(swig_type_list_handle, ti);
}

/* Search for a swig_type_info structure */
static swig_type_info *
SWIG_TypeQuery(const char *name) {
  return SWIG_TypeQueryTL(*swig_type_list_handle, name);
}

/* Set the clientdata field for a type */
static void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientDataTL(*swig_type_list_handle, ti, clientdata);
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
static void
SWIG_PropagateClientData(swig_type_info *type) {
  SWIG_PropagateClientDataTL(*swig_type_list_handle, type);
}

#ifdef __cplusplus
}
#endif

/*
 * php4.swg
 *
 * PHP4 runtime library
 *
 */

#ifdef __cplusplus
extern "C" {
#endif
#include "zend.h"
#include "zend_API.h"
#include "php.h"

/* These TSRMLS_ stuff should already be defined now, but with older php under
   redhat are not... */
#ifndef TSRMLS_D
#define TSRMLS_D
#endif
#ifndef TSRMLS_DC
#define TSRMLS_DC
#endif
#ifndef TSRMLS_C
#define TSRMLS_C
#endif
#ifndef TSRMLS_CC
#define TSRMLS_CC
#endif

#ifdef __cplusplus
}
#endif

/* used to wrap returned objects in so we know whether they are newobject
   and need freeing, or not */
typedef struct _swig_object_wrapper {
  void * ptr;
  int newobject;
} swig_object_wrapper;

/* local scope self_constructors are set to 1 inside function wrappers
   which are also class constructors, so that the php4.swg output typemaps
   know whether or not to wrap returned objects in this_ptr or a new object */
int self_constructor=0;

/* empty zend destructor for types without one */
static ZEND_RSRC_DTOR_FUNC(SWIG_landfill) {};

/* This one makes old swig style string pointers but the php module doesn't
   use these any more.  This is just left here for old times sake and may go */
static void
SWIG_MakePtr(char *c, void *ptr, swig_type_info *ty) {
  static char hex[17] = "0123456789abcdef";
  unsigned long p, s;
  char data[32], *r;

  r = data;
  p = (unsigned long) ptr;
  if (p > 0) {
    while (p > 0) {
      s = p & 0xf;
      *(r++) = hex[s];
      p = p >> 4;
    }
    *r = '_';
    while (r >= data) {
      *(c++) = *(r--);
    }
    strcpy (c, ty->name);
  } else {
    strcpy (c, "NULL");
  }
}

static void
SWIG_SetPointerChar(char **c, void *ptr, swig_type_info *type) {
   char data[512];

   SWIG_MakePtr(data, ptr, type);
   *c = estrdup(data);
}

#define SWIG_SetPointerZval(a,b,c,d) SWIG_ZTS_SetPointerZval(a,b,c,d, SWIG_module_entry TSRMLS_CC)

static void
SWIG_ZTS_SetPointerZval(zval *z, void *ptr, swig_type_info *type, int newobject, zend_module_entry* module_entry TSRMLS_DC) {
  swig_object_wrapper *value=NULL;
  /* No need to call SWIG_MakePtr here! */
  if (type->clientdata) {
    if (! (*(int *)(type->clientdata))) zend_error(E_ERROR, "Type: %s failed to register with zend",type->name);
    value=(swig_object_wrapper *)emalloc(sizeof(swig_object_wrapper));
    value->ptr=ptr;
    value->newobject=newobject;
    ZEND_REGISTER_RESOURCE(z, value, *(int *)(type->clientdata));
    return;
  } else { /* have to deal with old fashioned string pointer?
              but this should not get this far */
    zend_error(E_ERROR, "Type: %s not registered with zend",type->name);
  }
}

/* This old-style routine converts an old string-pointer c into a real pointer
   ptr calling making appropriate casting functions according to ty
   We don't use this any more */
static int
SWIG_ConvertPtr_(char *c, void **ptr, swig_type_info *ty) {
   register int d;
   unsigned long p;
   swig_type_info *tc;

   if(c == NULL) {
   	*ptr = 0;
	return 0;
   }

   p = 0;
   if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
	return 0;
    } else {
	goto type_error;
    }
  }

    c++;
    /* Extract hex value from pointer */
    while ((d = *c)) {
      if ((d >= '0') && (d <= '9'))
        p = (p << 4) + (d - '0');
      else if ((d >= 'a') && (d <= 'f'))
        p = (p << 4) + (d - ('a'-10));
      else
        break;
      c++;
    }
    *ptr = (void *) p;
	
    if(ty) {
	tc = SWIG_TypeCheck(c,ty);
	if(!tc) goto type_error;
	*ptr = SWIG_TypeCast(tc, (void*)p);
    }
    return 0;

type_error:

    return -1;
}

/* This is a new pointer conversion routine
   Taking the native pointer p (which would have been converted from the old
   string pointer) and it's php type id, and it's type name (which also would
   have come from the old string pointer) it converts it to ptr calling 
   appropriate casting functions according to ty
   Sadly PHP has no API to find a type name from a type id, only from an instance
   of a resource of the type id, so we have to pass type_name as well.
   The two functions which might call this are:
   SWIG_ZTS_ConvertResourcePtr which gets the type name from the resource
   and the registered zend destructors for which we have one per type each
   with the type name hard wired in. */
static int
SWIG_ZTS_ConvertResourceData(void * p, int type, const char *type_name, void **ptr, swig_type_info *ty TSRMLS_DC) {
  swig_type_info *tc;

  if (ty) {
    if (! type_name) {  
      /* can't convert p to ptr type ty if we don't know what type p is */
      return -1;
    } else {
      /* convert and cast p from type_name to ptr as ty
         Need to sort out const-ness, can SWIG_TypeCast really not take a const? */
      tc = SWIG_TypeCheck((char *)type_name,ty);
      if (!tc) return -1;
      *ptr = SWIG_TypeCast(tc, (void*)p);
    }
  } else {
    /* They don't care about the target type, so just pass on the pointer! */
    *ptr = (void *) p;
  }
  return 0;
}

/* This function fills ptr with a pointer of type ty by extracting the pointer
   and type info from the resource in z.  z must be a resource
   It uses SWIG_ZTS_ConvertResourceData to do the real work. */
static int
SWIG_ZTS_ConvertResourcePtr(zval *z, void **ptr, swig_type_info *ty TSRMLS_DC) {
  swig_object_wrapper *value;
  void *p;
  int type;
  char *type_name;

  value = (swig_object_wrapper *) zend_list_find(z->value.lval,&type);
  p = value->ptr;
  if (type==-1) return -1;

  type_name=zend_rsrc_list_get_rsrc_type(z->value.lval TSRMLS_CC);

  return SWIG_ZTS_ConvertResourceData(p,type,type_name,ptr,ty TSRMLS_CC);
}

/* But in fact SWIG_ConvertPtr is the native interface for getting typed
   pointer values out of zvals.  We need the TSRMLS_ macros for when we
   make PHP type calls later as we handle php resources */
#define SWIG_ConvertPtr(a,b,c) SWIG_ZTS_ConvertPtr(a,b,c TSRMLS_CC)

/* We allow passing of a STRING or RESOURCE pointing to the object
   or an OBJECT whose _cPtr is a string or resource pointing to the object
   STRING pointers are very depracated */
static int
SWIG_ZTS_ConvertPtr(zval *z, void **ptr, swig_type_info *ty TSRMLS_DC) {
   char *c;
   zval *val;
   
   if(z == NULL) {
	*ptr = 0;
	return 0;
   }

   if (z->type==IS_OBJECT) {
     zval ** _cPtr;
     if (zend_hash_find(HASH_OF(z),"_cPtr",sizeof("_cPtr"),(void**)&_cPtr)==SUCCESS) {
       /* Don't co-erce to string if it isn't */
       if ((*_cPtr)->type==IS_STRING) c = Z_STRVAL_PP(_cPtr);
       else if ((*_cPtr)->type==IS_RESOURCE) {
         return SWIG_ZTS_ConvertResourcePtr(*_cPtr,ptr,ty TSRMLS_CC);
       } else goto type_error; /* _cPtr was not string or resource property */
     } else goto type_error; /* can't find property _cPtr */
   } else if (z->type==IS_RESOURCE) {
     return SWIG_ZTS_ConvertResourcePtr(z,ptr,ty TSRMLS_CC);
   } else if (z->type==IS_STRING) {
     c = Z_STRVAL_P(z); 
     return SWIG_ConvertPtr_(c,ptr,ty);
   } else goto type_error;

type_error:

    return -1;
}


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_LassoMdProtocolType swig_types[0] 
#define  SWIGTYPE_p_LassoNodeList swig_types[1] 
#define  SWIGTYPE_p_LassoSamlpStatusCode swig_types[2] 
#define  SWIGTYPE_p_LassoSamlAudienceRestrictionCondition swig_types[3] 
#define  SWIGTYPE_p_LassoSamlConditions swig_types[4] 
#define  SWIGTYPE_p_LassoLogout swig_types[5] 
#define  SWIGTYPE_p_LassoSamlSubjectStatement swig_types[6] 
#define  SWIGTYPE_p_LassoSamlAuthenticationStatement swig_types[7] 
#define  SWIGTYPE_p_LassoSamlAttributeStatement swig_types[8] 
#define  SWIGTYPE_p_char swig_types[9] 
#define  SWIGTYPE_p_LassoLibFederationTerminationNotification swig_types[10] 
#define  SWIGTYPE_p_LassoSamlpRequestAbstract swig_types[11] 
#define  SWIGTYPE_p_LassoSamlSubjectStatementAbstract swig_types[12] 
#define  SWIGTYPE_p_LassoSamlStatementAbstract swig_types[13] 
#define  SWIGTYPE_p_LassoSamlConditionAbstract swig_types[14] 
#define  SWIGTYPE_p_LassoHttpMethod swig_types[15] 
#define  SWIGTYPE_p_LassoSamlpResponseAbstract swig_types[16] 
#define  SWIGTYPE_p_LassoStringList swig_types[17] 
#define  SWIGTYPE_p_void swig_types[18] 
#define  SWIGTYPE_int swig_types[19] 
#define  SWIGTYPE_p_LassoFederation swig_types[20] 
#define  SWIGTYPE_p_LassoDefederation swig_types[21] 
#define  SWIGTYPE_p_LassoLogin swig_types[22] 
#define  SWIGTYPE_p_LassoCheckVersionMode swig_types[23] 
#define  SWIGTYPE_p_LassoSamlAuthorityBinding swig_types[24] 
#define  SWIGTYPE_p_LassoRequestType swig_types[25] 
#define  SWIGTYPE_p_LassoSamlpRequest swig_types[26] 
#define  SWIGTYPE_p_LassoLibAuthnRequest swig_types[27] 
#define  SWIGTYPE_p_LassoLibLogoutRequest swig_types[28] 
#define  SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest swig_types[29] 
#define  SWIGTYPE_p_LassoSignatureType swig_types[30] 
#define  SWIGTYPE_p_LassoSamlAdvice swig_types[31] 
#define  SWIGTYPE_p_LassoSamlAssertion swig_types[32] 
#define  SWIGTYPE_p_LassoLibAssertion swig_types[33] 
#define  SWIGTYPE_p_LassoLecp swig_types[34] 
#define  SWIGTYPE_p_LassoSignatureMethod swig_types[35] 
#define  SWIGTYPE_p_LassoLibRequestAuthnContext swig_types[36] 
#define  SWIGTYPE_p_LassoLoginProtocolProfile swig_types[37] 
#define  SWIGTYPE_p_LassoSamlNameIdentifier swig_types[38] 
#define  SWIGTYPE_p_LassoNameRegistration swig_types[39] 
#define  SWIGTYPE_p_LassoSamlSubject swig_types[40] 
#define  SWIGTYPE_p_LassoSamlAttributeDesignator swig_types[41] 
#define  SWIGTYPE_p_LassoSamlpResponse swig_types[42] 
#define  SWIGTYPE_p_LassoLibAuthnResponse swig_types[43] 
#define  SWIGTYPE_p_LassoLibLogoutResponse swig_types[44] 
#define  SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse swig_types[45] 
#define  SWIGTYPE_p_LassoLibStatusResponse swig_types[46] 
#define  SWIGTYPE_p_LassoServer swig_types[47] 
#define  SWIGTYPE_p_LassoSession swig_types[48] 
#define  SWIGTYPE_p_LassoSamlAttribute swig_types[49] 
#define  SWIGTYPE_p_LassoSamlpStatus swig_types[50] 
#define  SWIGTYPE_p_LassoIdentity swig_types[51] 
#define  SWIGTYPE_p_LassoProviderRole swig_types[52] 
#define  SWIGTYPE_p_LassoSamlSubjectLocality swig_types[53] 
#define  SWIGTYPE_p_LassoSamlSubjectConfirmation swig_types[54] 
#define  SWIGTYPE_p_LassoSamlAttributeValue swig_types[55] 
#define  SWIGTYPE_p_LassoProvider swig_types[56] 
#define  SWIGTYPE_p_LassoNameIdentifierMapping swig_types[57] 
#define  SWIGTYPE_p_LassoNode swig_types[58] 
static swig_type_info *swig_types[60];

/* -------- TYPES TABLE (END) -------- */

/* header section */
/*
  +----------------------------------------------------------------------+
  | PHP version 4.0                                                      |
  +----------------------------------------------------------------------+
  | Copyright (c) 1997, 1998, 1999, 2000, 2001 The PHP Group             |
  +----------------------------------------------------------------------+
  | This source file is subject to version 2.02 of the PHP license,      |
  | that is bundled with this package in the file LICENSE, and is        |
  | available at through the world-wide-web at                           |
  | http://www.php.net/license/2_02.txt.                                 |
  | If you did not receive a copy of the PHP license and are unable to   |
  | obtain it through the world-wide-web, please send a note to          |
  | license@php.net so we can mail you a copy immediately.               |
  +----------------------------------------------------------------------+
  | Authors:                                                             |
  |                                                                      |
  +----------------------------------------------------------------------+
 */
#define SWIG_init	initlasso

#define SWIG_name	"lasso"
#ifdef __cplusplus
extern "C" {
#endif
#include "php.h"
#include "php_ini.h"
#include "ext/standard/info.h"
#include "php_lasso.h"
#ifdef __cplusplus
}
#endif


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


/* We should make use of "code" if we can */
#define SWIG_exception(code, msg) { zend_error(E_ERROR, msg); }



#if defined(SWIGRUBY) || defined (PHP_VERSION)
/* Ruby and PHP pollute the #define space with these names */
#undef PACKAGE_NAME
#undef PACKAGE_STRING
#undef PACKAGE_TARNAME
#undef PACKAGE_VERSION
#undef PACKAGE_BUGREPORT
#endif

#include <lasso/lasso_config.h>
#include <lasso/lasso.h>
#include <lasso/xml/lib_assertion.h>
#include <lasso/xml/saml_attribute_value.h>

#ifdef LASSO_WSF_ENABLED
#include <lasso/xml/disco_resource_id.h>
#include <lasso/xml/disco_encrypted_resource_id.h>
#endif



#define bool int
#define false 0
#define true 1



/* 
 * Thanks to the patch in this Debian bug for the solution
 * to the crash inside vsnprintf on some architectures.
 *
 * "reuse of args inside the while(1) loop is in violation of the
 * specs and only happens to work by accident on other systems."
 *
 * http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=104325 
 */

#ifndef va_copy
#ifdef __va_copy
#define va_copy(dest,src) __va_copy(dest,src)
#else
#define va_copy(dest,src) (dest) = (src)
#endif
#endif



/* ZVAL_STRING segfault when s is null */
#undef ZVAL_STRING
#define ZVAL_STRING(z, s, duplicate) {	\
	char *__s=(s);					\
	if (__s) {                      \
		(z)->value.str.len = strlen(__s);	\
		(z)->value.str.val = (duplicate?estrndup(__s, (z)->value.str.len):__s);	\
	} else {                        \
		(z)->value.str.len = 0;	    \
		(z)->value.str.val = empty_string; \
	}                               \
	(z)->type = IS_STRING;	        \
}



static void throw_exception_msg(int errorCode) {
	char errorMsg[256];
	if (errorCode > 0)
        {
	    sprintf(errorMsg, "%d / Lasso Warning: %s", errorCode, lasso_strerror(errorCode));
            zend_error(E_WARNING, errorMsg);
        }
	else
        {
	    sprintf(errorMsg, "%d / Lasso Error: %s", errorCode, lasso_strerror(errorCode));
            zend_error(E_ERROR, errorMsg);
        }
}




typedef struct node_info {
	char *name;
	struct node_info *super;
	swig_type_info *swig;
#ifdef PHP_VERSION
	zend_class_entry *php;
#endif
} node_info;

static node_info node_infos[100]; /* FIXME: Size should be computed */

/* Cast a LassoNode into the appropriate derivated class. */
static swig_type_info *dynamic_cast_node(void **nodePointer) {
	node_info *info;
	char *name;

	if (*nodePointer == NULL)
		return NULL;
	name = (char *) G_OBJECT_TYPE_NAME(*nodePointer);
	for (info = node_infos; info->swig; info++) {
		if (strcmp(info->name, name) == 0)
			return info->swig;
	}
	return NULL;
}

static node_info *get_node_info_with_swig(swig_type_info *swig) {
	node_info *info;

	for (info = node_infos; info->swig; info++) {
		if (info->swig == swig)
			return info;
	}
	return NULL;
}

#ifdef PHP_VERSION
static void set_node_info(node_info *info, char *name, char *superName, swig_type_info *swig,
			  zend_class_entry *php) {
#else
static void set_node_info(node_info *info, char *name, char *superName, swig_type_info *swig) {
#endif
	node_info *super;

	info->name = name;
	if (superName) {
		for (super = node_infos; super != info; super++)
			if (strcmp(super->name, superName) == 0)
				break;
		if (super == info) {
			printf("Lasso Swig Alert: Unknown super class %s for class %s\n",
			       superName, name);
			super = NULL;
		}
	} else
		super = NULL;
	info->super = super;
	info->swig = swig;
#ifdef PHP_VERSION
	info->php = php;
#endif
}



#include <lasso/errors.h>



static void add_key_to_array(char *key, gpointer pointer, GPtrArray *array)
{
        g_ptr_array_add(array, g_strdup(key));
}

static void add_node_to_array(gpointer node, GPtrArray *array)
{
	if (node != NULL)
		g_object_ref(node);
        g_ptr_array_add(array, node);
}

static void add_string_to_array(char *string, GPtrArray *array)
{
	if (string != NULL)
		string = g_strdup(string);
        g_ptr_array_add(array, string);
}

static void add_xml_to_array(xmlNode *xmlnode, GPtrArray *array)
{
	xmlOutputBufferPtr buf;
	gchar *xmlString;

	buf = xmlAllocOutputBuffer(NULL);
	if (buf == NULL)
		xmlString = NULL;
	else {
		xmlNodeDumpOutput(buf, NULL, xmlnode, 0, 1, NULL);
		xmlOutputBufferFlush(buf);
		if (buf->conv == NULL)
			xmlString = g_strdup(buf->buffer->content);
		else
			xmlString = g_strdup(buf->conv->content);
		xmlOutputBufferClose(buf);
	}
	g_ptr_array_add(array, xmlString);
}

static void free_node_array_item(gpointer node, gpointer unused)
{
	if (node != NULL)
		/* Test added to help debugging. */
		if (LASSO_IS_NODE(node))
			lasso_node_destroy(LASSO_NODE(node));
		else
			g_object_unref(node);
}

static void free_node_list_item(gpointer node, gpointer unused)
{
	if (node != NULL)
		/* Test added to help debugging. */
		if (LASSO_IS_NODE(node))
			lasso_node_destroy(LASSO_NODE(node));
		else
			g_object_unref(node);
}

static void free_string_list_item(char *string, gpointer unused)
{
	if (string != NULL)
		g_free(string);
}

static void free_xml_list_item(xmlNode *xmlnode, gpointer unused)
{
	if (xmlnode != NULL)
		xmlFreeNode(xmlnode);
}

static gpointer get_node(gpointer node)
{
	return node == NULL ? NULL : g_object_ref(node);
}

static GPtrArray *get_node_list(GList *nodeList) {
	GPtrArray *nodeArray;

	if (nodeList == NULL)
		return NULL;
	nodeArray = g_ptr_array_sized_new(g_list_length(nodeList));
	g_list_foreach(nodeList, (GFunc) add_node_to_array, nodeArray);
	return nodeArray;
}

static GPtrArray *get_string_list(GList *stringList) {
	GPtrArray *stringArray;

	if (stringList == NULL)
		return NULL;
	stringArray = g_ptr_array_sized_new(g_list_length(stringList));
	g_list_foreach(stringList, (GFunc) add_string_to_array, stringArray);
	return stringArray;
}

static GPtrArray *get_xml_list(GList *xmlList) {
	GPtrArray *xmlArray;

	if (xmlList == NULL)
		return NULL;
	xmlArray = g_ptr_array_sized_new(g_list_length(xmlList));
	g_list_foreach(xmlList, (GFunc) add_xml_to_array, xmlArray);
	return xmlArray;
}

static char* get_xml_string(xmlNode *xmlnode)
{
	xmlOutputBufferPtr buf;
	char *xmlString;

	if (xmlnode == NULL) {
		return NULL;
	}

	buf = xmlAllocOutputBuffer(NULL);
	if (buf == NULL)
		xmlString = NULL;
	else {
		xmlNodeDumpOutput(buf, NULL, xmlnode, 0, 1, NULL);
		xmlOutputBufferFlush(buf);
		if (buf->conv == NULL)
			xmlString = g_strdup(buf->buffer->content);
		else
			xmlString = g_strdup(buf->conv->content);
		xmlOutputBufferClose(buf);
	}
	xmlFreeNode(xmlnode);
	return xmlString;
}

static xmlNode *get_string_xml(const char *string) {
	xmlDoc *doc;
	xmlNode *node;

	doc = xmlReadDoc(string, NULL, NULL, XML_PARSE_NONET);
	node = xmlDocGetRootElement(doc);
	if (node != NULL)
		node = xmlCopyNode(node, 1);
	xmlFreeDoc(doc);

	return node;
}

static void set_node(gpointer *nodePointer, gpointer value)
{
	if (*nodePointer != NULL)
		/* Test added to help debugging. */
		if (LASSO_IS_NODE(*nodePointer))
			lasso_node_destroy(LASSO_NODE(*nodePointer));
		else
			g_object_unref(*nodePointer);
	*nodePointer = value == NULL ? NULL : g_object_ref(value);
}

static void set_node_list(GList **nodeListPointer, GPtrArray *nodeArray) {
	if (*nodeListPointer != NULL) {
		g_list_foreach(*nodeListPointer, (GFunc) free_node_list_item, NULL);
		g_list_free(*nodeListPointer);
	}
	if (nodeArray == NULL)
		*nodeListPointer = NULL;
	else {
		gpointer node;
		int index;

		for (index = 0; index < nodeArray->len; index ++) {
			node = g_ptr_array_index(nodeArray, index);
			if (node != NULL)
				g_object_ref(node);
			*nodeListPointer = g_list_append(*nodeListPointer, node);
		}
	}
}

static void set_string(char **pointer, char *value)
{
	if (*pointer != NULL)
		g_free(*pointer);
	*pointer = value == NULL ? NULL : strdup(value);
}

static void set_string_list(GList **stringListPointer, GPtrArray *stringArray) {
	if (*stringListPointer != NULL) {
		g_list_foreach(*stringListPointer, (GFunc) free_string_list_item, NULL);
		g_list_free(*stringListPointer);
	}
	if (stringArray == NULL)
		*stringListPointer = NULL;
	else {
		char *string;
		int index;

		for (index = 0; index < stringArray->len; index ++) {
			string = g_ptr_array_index(stringArray, index);
			if (string != NULL)
				string = g_strdup(string);
			*stringListPointer = g_list_append(*stringListPointer, string);
		}
	}
}

static void set_xml_list(GList **xmlListPointer, GPtrArray *xmlArray) {
	if (*xmlListPointer != NULL) {
		g_list_foreach(*xmlListPointer, (GFunc) free_xml_list_item, NULL);
		g_list_free(*xmlListPointer);
	}
	if (xmlArray == NULL)
		*xmlListPointer = NULL;
	else {
		xmlDoc *doc;
		int index;
		xmlNode *node;
		char *xmlString;

		for (index = 0; index < xmlArray->len; index ++) {
			xmlString = g_ptr_array_index(xmlArray, index);
			if (xmlString == NULL)
				node = NULL;
			else {
				doc = xmlReadDoc(g_ptr_array_index(xmlArray, index), NULL, NULL,
						 XML_PARSE_NONET);
				if (doc == NULL)
					continue;
				node = xmlDocGetRootElement(doc);
				if (node != NULL)
					node = xmlCopyNode(node, 1);
				xmlFreeDoc(doc);
			}
			*xmlListPointer = g_list_append(*xmlListPointer, node);
		}
	}
}

static void set_xml_string(xmlNode **xmlnode, const char* string)
{
	xmlDoc *doc;
	xmlNode *node;

	doc = xmlReadDoc(string, NULL, NULL, XML_PARSE_NONET);
	node = xmlDocGetRootElement(doc);
	if (node != NULL)
		node = xmlCopyNode(node, 1);
	xmlFreeDoc(doc);

	if (*xmlnode)
		xmlFreeNode(*xmlnode);

	*xmlnode = node;
}




static int _wrap_propset_LassoNode(zend_property_reference *property_reference, pval *value);
static int _propset_LassoNode(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoNode(zend_property_reference *property_reference);
static int _propget_LassoNode(zend_property_reference *property_reference, pval *value);


/* Constructors, destructors & static methods implementations */

#define new_LassoNode lasso_node_new
#define delete_LassoNode lasso_node_destroy

/* Methods implementations */

#define LassoNode_dump(self) lasso_node_dump(LASSO_NODE(self))



typedef GPtrArray LassoNodeList;

static void LassoNodeList_append(LassoNodeList *self,LassoNode *item){
			if (item != NULL)
				g_object_ref(item);
			g_ptr_array_add(self, item);
		}
static void *LassoNodeList_cast(LassoNodeList *self){
			return self;
		}
static LassoNodeList *LassoNodeList_frompointer(void *nodeArray){
			return (LassoNodeList *) nodeArray;
		}
static LassoNode *LassoNodeList_getItem(LassoNodeList *self,int index){
			LassoNode *item;

			item = g_ptr_array_index(self, index);
			if (item != NULL)
				g_object_ref(item);
			return item;
		}
static int LassoNodeList_length(LassoNodeList *self){
			return self->len;
		}
static void LassoNodeList_setItem(LassoNodeList *self,int index,LassoNode *item){
			LassoNode **itemPointer = (LassoNode **) &g_ptr_array_index(self, index);
			if (*itemPointer != NULL)
				/* Test added to help debugging. */
				if (LASSO_IS_NODE(*itemPointer))
					lasso_node_destroy(LASSO_NODE(*itemPointer));
				else
					g_object_unref(*itemPointer);
			if (item == NULL)
				*itemPointer = NULL;
			else
				*itemPointer = g_object_ref(item);
		}
static int _wrap_propset_LassoNodeList(zend_property_reference *property_reference, pval *value);
static int _propset_LassoNodeList(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoNodeList(zend_property_reference *property_reference);
static int _propget_LassoNodeList(zend_property_reference *property_reference, pval *value);


/* Constructors, destructors & static methods implementations */

#define new_LassoNodeList g_ptr_array_new

void delete_LassoNodeList(GPtrArray *self) {
	g_ptr_array_foreach(self, (GFunc) free_node_array_item, NULL);
	g_ptr_array_free(self, false);
}



typedef GPtrArray LassoStringList;

static void LassoStringList_append(LassoStringList *self,char *item){
			if (item != NULL)
				item = g_strdup(item);
			g_ptr_array_add(self, item);
		}
static void *LassoStringList_cast(LassoStringList *self){
			return self;
		}
static LassoStringList *LassoStringList_frompointer(void *stringArray){
			return (LassoStringList *) stringArray;
		}
static char *LassoStringList_getItem(LassoStringList *self,int index){
			return g_ptr_array_index(self, index);
		}
static int LassoStringList_length(LassoStringList *self){
			return self->len;
		}
static void LassoStringList_setItem(LassoStringList *self,int index,char *item){
			char **itemPointer = (char **) &g_ptr_array_index(self, index);
			if (*itemPointer != NULL)
				g_free(*itemPointer);
			if (item == NULL)
				*itemPointer = NULL;
			else
				*itemPointer = g_strdup(item);
		}
static int _wrap_propset_LassoStringList(zend_property_reference *property_reference, pval *value);
static int _propset_LassoStringList(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoStringList(zend_property_reference *property_reference);
static int _propget_LassoStringList(zend_property_reference *property_reference, pval *value);


/* Constructors, destructors & static methods implementations */

#define new_LassoStringList g_ptr_array_new
#define delete_LassoStringList(self) g_ptr_array_free(self, true)


static int _wrap_propset_LassoSamlAdvice(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlAdvice(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlAdvice(zend_property_reference *property_reference);
static int _propget_LassoSamlAdvice(zend_property_reference *property_reference, pval *value);


/* Attributes implementations */
/* Assertion */
#define LassoSamlAdvice_get_Assertion(self) get_node((self)->Assertion)
#define LassoSamlAdvice_Assertion_get(self) get_node((self)->Assertion)
#define LassoSamlAdvice_set_Assertion(self, value) set_node((gpointer *) &(self)->Assertion, (value))
#define LassoSamlAdvice_Assertion_set(self, value) set_node((gpointer *) &(self)->Assertion, (value))

/* assertionIdReference */
#define LassoSamlAdvice_get_assertionIdReference(self) get_string_list((self)->AssertionIDReference)
#define LassoSamlAdvice_assertionIdReference_get(self) get_string_list((self)->AssertionIDReference)
#define LassoSamlAdvice_set_assertionIdReference(self, value) set_string_list(&(self)->AssertionIDReference, (value))
#define LassoSamlAdvice_assertionIdReference_set(self, value) set_string_list(&(self)->AssertionIDReference, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlAdvice lasso_saml_advice_new
#define delete_LassoSamlAdvice(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlAdvice_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlAssertion(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlAssertion(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlAssertion(zend_property_reference *property_reference);
static int _propget_LassoSamlAssertion(zend_property_reference *property_reference, pval *value);


/* Attributes Implementations */

/* Advice */
#define LassoSamlAssertion_get_Advice(self) get_node((self)->Advice)
#define LassoSamlAssertion_Advice_get(self) get_node((self)->Advice)
#define LassoSamlAssertion_set_Advice(self, value) set_node((gpointer *) &(self)->Advice, (value))
#define LassoSamlAssertion_Advice_set(self, value) set_node((gpointer *) &(self)->Advice, (value))

/* AttributeStatement */
#define LassoSamlAssertion_get_AttributeStatement(self) get_node((self)->AttributeStatement)
#define LassoSamlAssertion_AttributeStatement_get(self) get_node((self)->AttributeStatement)
#define LassoSamlAssertion_set_AttributeStatement(self, value) set_node((gpointer *) &(self)->AttributeStatement, (value))
#define LassoSamlAssertion_AttributeStatement_set(self, value) set_node((gpointer *) &(self)->AttributeStatement, (value))

/* AuthenticationStatement */
#define LassoSamlAssertion_get_AuthenticationStatement(self) get_node((self)->AuthenticationStatement)
#define LassoSamlAssertion_AuthenticationStatement_get(self) get_node((self)->AuthenticationStatement)
#define LassoSamlAssertion_set_AuthenticationStatement(self, value) set_node((gpointer *) &(self)->AuthenticationStatement, (value))
#define LassoSamlAssertion_AuthenticationStatement_set(self, value) set_node((gpointer *) &(self)->AuthenticationStatement, (value))

/* Conditions */
#define LassoSamlAssertion_get_Conditions(self) get_node((self)->Conditions)
#define LassoSamlAssertion_Conditions_get(self) get_node((self)->Conditions)
#define LassoSamlAssertion_set_Conditions(self, value) set_node((gpointer *) &(self)->Conditions, (value))
#define LassoSamlAssertion_Conditions_set(self, value) set_node((gpointer *) &(self)->Conditions, (value))

/* SubjectStatement */
#define LassoSamlAssertion_get_SubjectStatement(self) get_node((self)->SubjectStatement)
#define LassoSamlAssertion_SubjectStatement_get(self) get_node((self)->SubjectStatement)
#define LassoSamlAssertion_set_SubjectStatement(self, value) set_node((gpointer *) &(self)->SubjectStatement, (value))
#define LassoSamlAssertion_SubjectStatement_set(self, value) set_node((gpointer *) &(self)->SubjectStatement, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlAssertion lasso_saml_assertion_new
#define delete_LassoSamlAssertion(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlAssertion_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlAttribute(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlAttribute(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlAttribute(zend_property_reference *property_reference);
static int _propget_LassoSamlAttribute(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from SamlAttributeDesignator */

/* AttributeName */
#define LassoSamlAttribute_get_AttributeName(self) LASSO_SAML_ATTRIBUTE_DESIGNATOR(self)->AttributeName
#define LassoSamlAttribute_AttributeName_get(self) LASSO_SAML_ATTRIBUTE_DESIGNATOR(self)->AttributeName
#define LassoSamlAttribute_set_AttributeName(self, value) set_string(&LASSO_SAML_ATTRIBUTE_DESIGNATOR(self)->AttributeName, (value))
#define LassoSamlAttribute_AttributeName_set(self, value) set_string(&LASSO_SAML_ATTRIBUTE_DESIGNATOR(self)->AttributeName, (value))

/* AttributeNamespace */
#define LassoSamlAttribute_get_AttributeNamespace(self) LASSO_SAML_ATTRIBUTE_DESIGNATOR(self)->AttributeNamespace
#define LassoSamlAttribute_AttributeNamespace_get(self) LASSO_SAML_ATTRIBUTE_DESIGNATOR(self)->AttributeNamespace
#define LassoSamlAttribute_set_AttributeNamespace(self, value) set_string(&LASSO_SAML_ATTRIBUTE_DESIGNATOR(self)->AttributeNamespace, (value))
#define LassoSamlAttribute_AttributeNamespace_set(self, value) set_string(&LASSO_SAML_ATTRIBUTE_DESIGNATOR(self)->AttributeNamespace, (value))

/* Attributes implementations */

/* AttributeValue */
#define LassoSamlAttribute_get_AttributeValue(self) get_node_list((self)->AttributeValue)
#define LassoSamlAttribute_AttributeValue_get(self) get_node_list((self)->AttributeValue)
#define LassoSamlAttribute_set_AttributeValue(self, value) set_node_list(&(self)->AttributeValue, (value))
#define LassoSamlAttribute_AttributeValue_set(self, value) set_node_list(&(self)->AttributeValue, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlAttribute lasso_saml_attribute_new
#define delete_LassoSamlAttribute(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlAttribute_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlAttributeDesignator(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlAttributeDesignator(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlAttributeDesignator(zend_property_reference *property_reference);
static int _propget_LassoSamlAttributeDesignator(zend_property_reference *property_reference, pval *value);


/* Constructors, destructors & static methods implementations */

#define new_LassoSamlAttributeDesignator lasso_saml_attribute_designator_new
#define delete_LassoSamlAttributeDesignator(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlAttributeDesignator_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlAttributeStatement(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlAttributeStatement(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlAttributeStatement(zend_property_reference *property_reference);
static int _propget_LassoSamlAttributeStatement(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from SamlSubjectStatementAbstract */

/* Subject */
#define LassoSamlAttributeStatement_get_Subject(self) get_node(LASSO_SAML_SUBJECT_STATEMENT_ABSTRACT(self)->Subject)
#define LassoSamlAttributeStatement_Subject_get(self) get_node(LASSO_SAML_SUBJECT_STATEMENT_ABSTRACT(self)->Subject)
#define LassoSamlAttributeStatement_set_Subject(self, value) set_node((gpointer *) &LASSO_SAML_SUBJECT_STATEMENT_ABSTRACT(self)->Subject, (value))
#define LassoSamlAttributeStatement_Subject_set(self, value) set_node((gpointer *) &LASSO_SAML_SUBJECT_STATEMENT_ABSTRACT(self)->Subject, (value))

/* Attributes Implementations */

/* Attribute */
#define LassoSamlAttributeStatement_get_Attribute(self) get_node_list((self)->Attribute)
#define LassoSamlAttributeStatement_Attribute_get(self) get_node_list((self)->Attribute)
#define LassoSamlAttributeStatement_set_Attribute(self, value) set_node_list(&(self)->Attribute, (value))
#define LassoSamlAttributeStatement_Attribute_set(self, value) set_node_list(&(self)->Attribute, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlAttributeStatement lasso_saml_attribute_statement_new
#define delete_LassoSamlAttributeStatement(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlAttributeStatement_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlAttributeValue(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlAttributeValue(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlAttributeValue(zend_property_reference *property_reference);
static int _propget_LassoSamlAttributeValue(zend_property_reference *property_reference, pval *value);


/* Attributes Implementations */

/* any */
#define LassoSamlAttributeValue_get_any(self) get_node_list((self)->any)
#define LassoSamlAttributeValue_any_get(self) get_node_list((self)->any)
#define LassoSamlAttributeValue_set_any(self, value) set_node_list(&(self)->any, (value))
#define LassoSamlAttributeValue_any_set(self, value) set_node_list(&(self)->any, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlAttributeValue lasso_saml_attribute_value_new
#define delete_LassoSamlAttributeValue(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlAttributeValue_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlAudienceRestrictionCondition(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlAudienceRestrictionCondition(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlAudienceRestrictionCondition(zend_property_reference *property_reference);
static int _propget_LassoSamlAudienceRestrictionCondition(zend_property_reference *property_reference, pval *value);


/* Attributes implementations */

/* audience */
#define LassoSamlAudienceRestrictionCondition_get_audience(self) get_string_list((self)->Audience)
#define LassoSamlAudienceRestrictionCondition_audience_get(self) get_string_list((self)->Audience)
#define LassoSamlAudienceRestrictionCondition_set_audience(self, value) set_string_list(&(self)->Audience, (value))
#define LassoSamlAudienceRestrictionCondition_audience_set(self, value) set_string_list(&(self)->Audience, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlAudienceRestrictionCondition lasso_saml_audience_restriction_condition_new
#define delete_LassoSamlAudienceRestrictionCondition(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlAudienceRestrictionCondition_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlAuthenticationStatement(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlAuthenticationStatement(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlAuthenticationStatement(zend_property_reference *property_reference);
static int _propget_LassoSamlAuthenticationStatement(zend_property_reference *property_reference, pval *value);


/* Attributes Implementations */

/* AuthorityBinding */
#define LassoSamlAuthenticationStatement_get_AuthorityBinding(self) get_node_list((self)->AuthorityBinding)
#define LassoSamlAuthenticationStatement_AuthorityBinding_get(self) get_node_list((self)->AuthorityBinding)
#define LassoSamlAuthenticationStatement_set_AuthorityBinding(self, value) set_node_list(&(self)->AuthorityBinding, (value))
#define LassoSamlAuthenticationStatement_AuthorityBinding_set(self, value) set_node_list(&(self)->AuthorityBinding, (value))

/* SubjectLocality */
#define LassoSamlAuthenticationStatement_get_SubjectLocality(self) get_node((self)->SubjectLocality)
#define LassoSamlAuthenticationStatement_SubjectLocality_get(self) get_node((self)->SubjectLocality)
#define LassoSamlAuthenticationStatement_set_SubjectLocality(self, value) set_node((gpointer *) &(self)->SubjectLocality, (value))
#define LassoSamlAuthenticationStatement_SubjectLocality_set(self, value) set_node((gpointer *) &(self)->SubjectLocality, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlAuthenticationStatement lasso_saml_authentication_statement_new
#define delete_LassoSamlAuthenticationStatement(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlAuthenticationStatement_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlAuthorityBinding(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlAuthorityBinding(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlAuthorityBinding(zend_property_reference *property_reference);
static int _propget_LassoSamlAuthorityBinding(zend_property_reference *property_reference, pval *value);


/* Constructors, destructors & static methods implementations */

#define new_LassoSamlAuthorityBinding lasso_saml_authority_binding_new
#define delete_LassoSamlAuthorityBinding(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlAuthorityBinding_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlConditionAbstract(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlConditionAbstract(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlConditionAbstract(zend_property_reference *property_reference);
static int _propget_LassoSamlConditionAbstract(zend_property_reference *property_reference, pval *value);


/* Implementations of methods inherited from LassoNode */

#define LassoSamlConditionAbstract_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlConditions(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlConditions(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlConditions(zend_property_reference *property_reference);
static int _propget_LassoSamlConditions(zend_property_reference *property_reference, pval *value);


/* Attributes Implementations */

/* AudienceRestrictionCondition */
#define LassoSamlConditions_get_AudienceRestrictionCondition(self) get_node_list((self)->AudienceRestrictionCondition)
#define LassoSamlConditions_AudienceRestrictionCondition_get(self) get_node_list((self)->AudienceRestrictionCondition)
#define LassoSamlConditions_set_AudienceRestrictionCondition(self, value) set_node_list(&(self)->AudienceRestrictionCondition, (value))
#define LassoSamlConditions_AudienceRestrictionCondition_set(self, value) set_node_list(&(self)->AudienceRestrictionCondition, (value))

/* Condition */
#define LassoSamlConditions_get_Condition(self) get_node_list((self)->Condition)
#define LassoSamlConditions_Condition_get(self) get_node_list((self)->Condition)
#define LassoSamlConditions_set_Condition(self, value) set_node_list(&(self)->Condition, (value))
#define LassoSamlConditions_Condition_set(self, value) set_node_list(&(self)->Condition, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlConditions lasso_saml_conditions_new
#define delete_LassoSamlConditions(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlConditions_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlNameIdentifier(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlNameIdentifier(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlNameIdentifier(zend_property_reference *property_reference);
static int _propget_LassoSamlNameIdentifier(zend_property_reference *property_reference, pval *value);


/* Constructors, destructors & static methods implementations */

#define new_LassoSamlNameIdentifier lasso_saml_name_identifier_new
#define delete_LassoSamlNameIdentifier(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlNameIdentifier_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlStatementAbstract(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlStatementAbstract(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlStatementAbstract(zend_property_reference *property_reference);
static int _propget_LassoSamlStatementAbstract(zend_property_reference *property_reference, pval *value);


/* Implementations of methods inherited from LassoNode */

#define LassoSamlStatementAbstract_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlSubject(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlSubject(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlSubject(zend_property_reference *property_reference);
static int _propget_LassoSamlSubject(zend_property_reference *property_reference, pval *value);


/* Attributes implementations */

/* NameIdentifier */
#define LassoSamlSubject_get_NameIdentifier(self) get_node((self)->NameIdentifier)
#define LassoSamlSubject_NameIdentifier_get(self) get_node((self)->NameIdentifier)
#define LassoSamlSubject_set_NameIdentifier(self, value) set_node((gpointer *) &(self)->NameIdentifier, (value))
#define LassoSamlSubject_NameIdentifier_set(self, value) set_node((gpointer *) &(self)->NameIdentifier, (value))

/* SubjectConfirmation */
#define LassoSamlSubject_get_SubjectConfirmation(self) get_node((self)->SubjectConfirmation)
#define LassoSamlSubject_SubjectConfirmation_get(self) get_node((self)->SubjectConfirmation)
#define LassoSamlSubject_set_SubjectConfirmation(self, value) set_node((gpointer *) &(self)->SubjectConfirmation, (value))
#define LassoSamlSubject_SubjectConfirmation_set(self, value) set_node((gpointer *) &(self)->SubjectConfirmation, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlSubject lasso_saml_subject_new
#define delete_LassoSamlSubject(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlSubject_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlSubjectConfirmation(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlSubjectConfirmation(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlSubjectConfirmation(zend_property_reference *property_reference);
static int _propget_LassoSamlSubjectConfirmation(zend_property_reference *property_reference, pval *value);


/* Attributes implementations */

/* confirmationMethod */
#define LassoSamlSubjectConfirmation_get_confirmationMethod(self) get_string_list((self)->ConfirmationMethod)
#define LassoSamlSubjectConfirmation_confirmationMethod_get(self) get_string_list((self)->ConfirmationMethod)
#define LassoSamlSubjectConfirmation_set_confirmationMethod(self, value) set_string_list(&(self)->ConfirmationMethod, (value))
#define LassoSamlSubjectConfirmation_confirmationMethod_set(self, value) set_string_list(&(self)->ConfirmationMethod, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlSubjectConfirmation lasso_saml_subject_confirmation_new
#define delete_LassoSamlSubjectConfirmation(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlSubjectConfirmation_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlSubjectLocality(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlSubjectLocality(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlSubjectLocality(zend_property_reference *property_reference);
static int _propget_LassoSamlSubjectLocality(zend_property_reference *property_reference, pval *value);


/* Constructors, destructors & static methods implementations */

#define new_LassoSamlSubjectLocality lasso_saml_subject_locality_new
#define delete_LassoSamlSubjectLocality(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlSubjectLocality_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlSubjectStatement(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlSubjectStatement(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlSubjectStatement(zend_property_reference *property_reference);
static int _propget_LassoSamlSubjectStatement(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from SamlSubjectStatementAbstract */

/* Subject */
#define LassoSamlSubjectStatement_get_Subject(self) get_node(LASSO_SAML_SUBJECT_STATEMENT_ABSTRACT(self)->Subject)
#define LassoSamlSubjectStatement_Subject_get(self) get_node(LASSO_SAML_SUBJECT_STATEMENT_ABSTRACT(self)->Subject)
#define LassoSamlSubjectStatement_set_Subject(self, value) set_node((gpointer *) &LASSO_SAML_SUBJECT_STATEMENT_ABSTRACT(self)->Subject, (value))
#define LassoSamlSubjectStatement_Subject_set(self, value) set_node((gpointer *) &LASSO_SAML_SUBJECT_STATEMENT_ABSTRACT(self)->Subject, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlSubjectStatement lasso_saml_subject_statement_new
#define delete_LassoSamlSubjectStatement(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlSubjectStatement_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlSubjectStatementAbstract(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlSubjectStatementAbstract(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlSubjectStatementAbstract(zend_property_reference *property_reference);
static int _propget_LassoSamlSubjectStatementAbstract(zend_property_reference *property_reference, pval *value);


/* Attributes implementations */

/* Subject */
#define LassoSamlSubjectStatementAbstract_get_Subject(self) get_node((self)->Subject)
#define LassoSamlSubjectStatementAbstract_Subject_get(self) get_node((self)->Subject)
#define LassoSamlSubjectStatementAbstract_set_Subject(self, value) set_node((gpointer *) &(self)->Subject, (value))
#define LassoSamlSubjectStatementAbstract_Subject_set(self, value) set_node((gpointer *) &(self)->Subject, (value))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlSubjectStatementAbstract_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlpRequest(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlpRequest(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlpRequest(zend_property_reference *property_reference);
static int _propget_LassoSamlpRequest(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from SamlpRequestAbstract */

/* certificate_file */
#define LassoSamlpRequest_get_certificate_file(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file
#define LassoSamlpRequest_certificate_file_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file
#define LassoSamlpRequest_set_certificate_file(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file, (value))
#define LassoSamlpRequest_certificate_file_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file, (value))

/* IssueInstant */
#define LassoSamlpRequest_get_IssueInstant(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant
#define LassoSamlpRequest_IssueInstant_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant
#define LassoSamlpRequest_set_IssueInstant(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant, (value))
#define LassoSamlpRequest_IssueInstant_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant, (value))

/* MajorVersion */
#define LassoSamlpRequest_get_MajorVersion(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion
#define LassoSamlpRequest_MajorVersion_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion
#define LassoSamlpRequest_set_MajorVersion(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion = (value)
#define LassoSamlpRequest_MajorVersion_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion = (value)

/* MinorVersion */
#define LassoSamlpRequest_get_MinorVersion(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion
#define LassoSamlpRequest_MinorVersion_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion
#define LassoSamlpRequest_set_MinorVersion(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion = (value)
#define LassoSamlpRequest_MinorVersion_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion = (value)

/* private_key_file */
#define LassoSamlpRequest_get_private_key_file(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file
#define LassoSamlpRequest_private_key_file_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file
#define LassoSamlpRequest_set_private_key_file(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file, (value))
#define LassoSamlpRequest_private_key_file_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file, (value))

/* RequestID */
#define LassoSamlpRequest_get_RequestID(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID
#define LassoSamlpRequest_RequestID_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID
#define LassoSamlpRequest_set_RequestID(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID, (value))
#define LassoSamlpRequest_RequestID_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID, (value))

/* RespondWith */
#define LassoSamlpRequest_get_RespondWith(self) get_string_list(LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith)
#define LassoSamlpRequest_RespondWith_get(self) get_string_list(LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith)
#define LassoSamlpRequest_set_RespondWith(self, value) set_string_list(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith, (value))
#define LassoSamlpRequest_RespondWith_set(self, value) set_string_list(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith, (value))

/* sign_method */
#define LassoSamlpRequest_get_sign_method(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method
#define LassoSamlpRequest_sign_method_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method
#define LassoSamlpRequest_set_sign_method(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method = (value)
#define LassoSamlpRequest_sign_method_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method = (value)

/* sign_type */
#define LassoSamlpRequest_get_sign_type(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type
#define LassoSamlpRequest_sign_type_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type
#define LassoSamlpRequest_set_sign_type(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type = (value)
#define LassoSamlpRequest_sign_type_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type = (value)

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlpRequest lasso_samlp_request_new
#define delete_LassoSamlpRequest(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlpRequest_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlpRequestAbstract(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlpRequestAbstract(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlpRequestAbstract(zend_property_reference *property_reference);
static int _propget_LassoSamlpRequestAbstract(zend_property_reference *property_reference, pval *value);


/* Attributes implementations */

/* RespondWith */
#define LassoSamlpRequestAbstract_get_RespondWith(self) get_string_list((self)->RespondWith)
#define LassoSamlpRequestAbstract_RespondWith_get(self) get_string_list((self)->RespondWith)
#define LassoSamlpRequestAbstract_set_RespondWith(self, value) set_string_list(&(self)->RespondWith, (value))
#define LassoSamlpRequestAbstract_RespondWith_set(self, value) set_string_list(&(self)->RespondWith, (value))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlpRequestAbstract_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlpResponse(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlpResponse(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlpResponse(zend_property_reference *property_reference);
static int _propget_LassoSamlpResponse(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from SamlpResponseAbstract */

/* certificate_file */
#define LassoSamlpResponse_get_certificate_file(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->certificate_file
#define LassoSamlpResponse_certificate_file_get(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->certificate_file
#define LassoSamlpResponse_set_certificate_file(self, value) set_string(&LASSO_SAMLP_RESPONSE_ABSTRACT(self)->certificate_file, (value))
#define LassoSamlpResponse_certificate_file_set(self, value) set_string(&LASSO_SAMLP_RESPONSE_ABSTRACT(self)->certificate_file, (value))

/* InResponseTo */
#define LassoSamlpResponse_get_InResponseTo(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->InResponseTo
#define LassoSamlpResponse_InResponseTo_get(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->InResponseTo
#define LassoSamlpResponse_set_InResponseTo(self, value) set_string(&LASSO_SAMLP_RESPONSE_ABSTRACT(self)->InResponseTo, (value))
#define LassoSamlpResponse_InResponseTo_set(self, value) set_string(&LASSO_SAMLP_RESPONSE_ABSTRACT(self)->InResponseTo, (value))

/* IssueInstant */
#define LassoSamlpResponse_get_IssueInstant(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->IssueInstant
#define LassoSamlpResponse_IssueInstant_get(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->IssueInstant
#define LassoSamlpResponse_set_IssueInstant(self, value) set_string(&LASSO_SAMLP_RESPONSE_ABSTRACT(self)->IssueInstant, (value))
#define LassoSamlpResponse_IssueInstant_set(self, value) set_string(&LASSO_SAMLP_RESPONSE_ABSTRACT(self)->IssueInstant, (value))

/* MajorVersion */
#define LassoSamlpResponse_get_MajorVersion(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->MajorVersion
#define LassoSamlpResponse_MajorVersion_get(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->MajorVersion
#define LassoSamlpResponse_set_MajorVersion(self, value) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->MajorVersion = (value)
#define LassoSamlpResponse_MajorVersion_set(self, value) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->MajorVersion = (value)

/* MinorVersion */
#define LassoSamlpResponse_get_MinorVersion(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->MinorVersion
#define LassoSamlpResponse_MinorVersion_get(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->MinorVersion
#define LassoSamlpResponse_set_MinorVersion(self, value) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->MinorVersion = (value)
#define LassoSamlpResponse_MinorVersion_set(self, value) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->MinorVersion = (value)

/* private_key_file */
#define LassoSamlpResponse_get_private_key_file(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->private_key_file
#define LassoSamlpResponse_private_key_file_get(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->private_key_file
#define LassoSamlpResponse_set_private_key_file(self, value) set_string(&LASSO_SAMLP_RESPONSE_ABSTRACT(self)->private_key_file, (value))
#define LassoSamlpResponse_private_key_file_set(self, value) set_string(&LASSO_SAMLP_RESPONSE_ABSTRACT(self)->private_key_file, (value))

/* Recipient */
#define LassoSamlpResponse_get_Recipient(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->Recipient
#define LassoSamlpResponse_Recipient_get(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->Recipient
#define LassoSamlpResponse_set_Recipient(self, value) set_string(&LASSO_SAMLP_RESPONSE_ABSTRACT(self)->Recipient, (value))
#define LassoSamlpResponse_Recipient_set(self, value) set_string(&LASSO_SAMLP_RESPONSE_ABSTRACT(self)->Recipient, (value))

/* ResponseID */
#define LassoSamlpResponse_get_ResponseID(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->ResponseID
#define LassoSamlpResponse_ResponseID_get(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->ResponseID
#define LassoSamlpResponse_set_ResponseID(self, value) set_string(&LASSO_SAMLP_RESPONSE_ABSTRACT(self)->ResponseID, (value))
#define LassoSamlpResponse_ResponseID_set(self, value) set_string(&LASSO_SAMLP_RESPONSE_ABSTRACT(self)->ResponseID, (value))

/* sign_method */
#define LassoSamlpResponse_get_sign_method(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->sign_method
#define LassoSamlpResponse_sign_method_get(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->sign_method
#define LassoSamlpResponse_set_sign_method(self, value) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->sign_method = (value)
#define LassoSamlpResponse_sign_method_set(self, value) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->sign_method = (value)

/* sign_type */
#define LassoSamlpResponse_get_sign_type(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->sign_type
#define LassoSamlpResponse_sign_type_get(self) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->sign_type
#define LassoSamlpResponse_set_sign_type(self, value) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->sign_type = (value)
#define LassoSamlpResponse_sign_type_set(self, value) LASSO_SAMLP_RESPONSE_ABSTRACT(self)->sign_type = (value)

/* Attributes Implementations */

/* Assertion */
#define LassoSamlpResponse_get_Assertion(self) get_node_list((self)->Assertion)
#define LassoSamlpResponse_Assertion_get(self) get_node_list((self)->Assertion)
#define LassoSamlpResponse_set_Assertion(self, value) set_node_list(&(self)->Assertion, (value))
#define LassoSamlpResponse_Assertion_set(self, value) set_node_list(&(self)->Assertion, (value))

/* Status */
#define LassoSamlpResponse_get_Status(self) get_node((self)->Status)
#define LassoSamlpResponse_Status_get(self) get_node((self)->Status)
#define LassoSamlpResponse_set_Status(self, value) set_node((gpointer *) &(self)->Status, (value))
#define LassoSamlpResponse_Status_set(self, value) set_node((gpointer *) &(self)->Status, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlpResponse lasso_samlp_response_new
#define delete_LassoSamlpResponse(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlpResponse_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlpResponseAbstract(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlpResponseAbstract(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlpResponseAbstract(zend_property_reference *property_reference);
static int _propget_LassoSamlpResponseAbstract(zend_property_reference *property_reference, pval *value);


/* Implementations of methods inherited from LassoNode */

#define LassoSamlpResponseAbstract_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlpStatus(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlpStatus(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlpStatus(zend_property_reference *property_reference);
static int _propget_LassoSamlpStatus(zend_property_reference *property_reference, pval *value);


/* Attributes Implementations */

/* StatusCode */
#define LassoSamlpStatus_get_StatusCode(self) get_node((self)->StatusCode)
#define LassoSamlpStatus_StatusCode_get(self) get_node((self)->StatusCode)
#define LassoSamlpStatus_set_StatusCode(self, value) set_node((gpointer *) &(self)->StatusCode, (value))
#define LassoSamlpStatus_StatusCode_set(self, value) set_node((gpointer *) &(self)->StatusCode, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlpStatus lasso_samlp_status_new
#define delete_LassoSamlpStatus(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlpStatus_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoSamlpStatusCode(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSamlpStatusCode(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSamlpStatusCode(zend_property_reference *property_reference);
static int _propget_LassoSamlpStatusCode(zend_property_reference *property_reference, pval *value);


/* Attributes Implementations */

/* StatusCode */
#define LassoSamlpStatusCode_get_StatusCode(self) get_node((self)->StatusCode)
#define LassoSamlpStatusCode_StatusCode_get(self) get_node((self)->StatusCode)
#define LassoSamlpStatusCode_set_StatusCode(self, value) set_node((gpointer *) &(self)->StatusCode, (value))
#define LassoSamlpStatusCode_StatusCode_set(self, value) set_node((gpointer *) &(self)->StatusCode, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoSamlpStatusCode lasso_samlp_status_code_new
#define delete_LassoSamlpStatusCode(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoSamlpStatusCode_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoLibAssertion(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLibAssertion(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLibAssertion(zend_property_reference *property_reference);
static int _propget_LassoLibAssertion(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from SamlAssertion */

/* Advice */
#define LassoLibAssertion_get_Advice(self) get_node(LASSO_SAML_ASSERTION(self)->Advice)
#define LassoLibAssertion_Advice_get(self) get_node(LASSO_SAML_ASSERTION(self)->Advice)
#define LassoLibAssertion_set_Advice(self, value) set_node((gpointer *) &LASSO_SAML_ASSERTION(self)->Advice, (value))
#define LassoLibAssertion_Advice_set(self, value) set_node((gpointer *) &LASSO_SAML_ASSERTION(self)->Advice, (value))

/* AssertionID */
#define LassoLibAssertion_get_AssertionID(self) LASSO_SAML_ASSERTION(self)->AssertionID
#define LassoLibAssertion_AssertionID_get(self) LASSO_SAML_ASSERTION(self)->AssertionID
#define LassoLibAssertion_set_AssertionID(self, value) set_string(&LASSO_SAML_ASSERTION(self)->AssertionID, (value))
#define LassoLibAssertion_AssertionID_set(self, value) set_string(&LASSO_SAML_ASSERTION(self)->AssertionID, (value))

/* AttributeStatement */
#define LassoLibAssertion_get_AttributeStatement(self) get_node(LASSO_SAML_ASSERTION(self)->AttributeStatement)
#define LassoLibAssertion_AttributeStatement_get(self) get_node(LASSO_SAML_ASSERTION(self)->AttributeStatement)
#define LassoLibAssertion_set_AttributeStatement(self, value) set_node((gpointer *) &LASSO_SAML_ASSERTION(self)->AttributeStatement, (value))
#define LassoLibAssertion_AttributeStatement_set(self, value) set_node((gpointer *) &LASSO_SAML_ASSERTION(self)->AttributeStatement, (value))

/* AuthenticationStatement */
#define LassoLibAssertion_get_AuthenticationStatement(self) get_node(LASSO_SAML_ASSERTION(self)->AuthenticationStatement)
#define LassoLibAssertion_AuthenticationStatement_get(self) get_node(LASSO_SAML_ASSERTION(self)->AuthenticationStatement)
#define LassoLibAssertion_set_AuthenticationStatement(self, value) set_node((gpointer *) &LASSO_SAML_ASSERTION(self)->AuthenticationStatement, (value))
#define LassoLibAssertion_AuthenticationStatement_set(self, value) set_node((gpointer *) &LASSO_SAML_ASSERTION(self)->AuthenticationStatement, (value))

/* certificate_file */
#define LassoLibAssertion_get_certificate_file(self) LASSO_SAML_ASSERTION(self)->certificate_file
#define LassoLibAssertion_certificate_file_get(self) LASSO_SAML_ASSERTION(self)->certificate_file
#define LassoLibAssertion_set_certificate_file(self, value) set_string(&LASSO_SAML_ASSERTION(self)->certificate_file, (value))
#define LassoLibAssertion_certificate_file_set(self, value) set_string(&LASSO_SAML_ASSERTION(self)->certificate_file, (value))

/* Conditions */
#define LassoLibAssertion_get_Conditions(self) get_node(LASSO_SAML_ASSERTION(self)->Conditions)
#define LassoLibAssertion_Conditions_get(self) get_node(LASSO_SAML_ASSERTION(self)->Conditions)
#define LassoLibAssertion_set_Conditions(self, value) set_node((gpointer *) &LASSO_SAML_ASSERTION(self)->Conditions, (value))
#define LassoLibAssertion_Conditions_set(self, value) set_node((gpointer *) &LASSO_SAML_ASSERTION(self)->Conditions, (value))

/* IssueInstant */
#define LassoLibAssertion_get_IssueInstant(self) LASSO_SAML_ASSERTION(self)->IssueInstant
#define LassoLibAssertion_IssueInstant_get(self) LASSO_SAML_ASSERTION(self)->IssueInstant
#define LassoLibAssertion_set_IssueInstant(self, value) set_string(&LASSO_SAML_ASSERTION(self)->IssueInstant, (value))
#define LassoLibAssertion_IssueInstant_set(self, value) set_string(&LASSO_SAML_ASSERTION(self)->IssueInstant, (value))

/* Issuer */
#define LassoLibAssertion_get_Issuer(self) LASSO_SAML_ASSERTION(self)->Issuer
#define LassoLibAssertion_Issuer_get(self) LASSO_SAML_ASSERTION(self)->Issuer
#define LassoLibAssertion_set_Issuer(self, value) set_string(&LASSO_SAML_ASSERTION(self)->Issuer, (value))
#define LassoLibAssertion_Issuer_set(self, value) set_string(&LASSO_SAML_ASSERTION(self)->Issuer, (value))

/* MajorVersion */
#define LassoLibAssertion_get_MajorVersion(self) LASSO_SAML_ASSERTION(self)->MajorVersion
#define LassoLibAssertion_MajorVersion_get(self) LASSO_SAML_ASSERTION(self)->MajorVersion
#define LassoLibAssertion_set_MajorVersion(self, value) LASSO_SAML_ASSERTION(self)->MajorVersion = (value)
#define LassoLibAssertion_MajorVersion_set(self, value) LASSO_SAML_ASSERTION(self)->MajorVersion = (value)

/* MinorVersion */
#define LassoLibAssertion_get_MinorVersion(self) LASSO_SAML_ASSERTION(self)->MinorVersion
#define LassoLibAssertion_MinorVersion_get(self) LASSO_SAML_ASSERTION(self)->MinorVersion
#define LassoLibAssertion_set_MinorVersion(self, value) LASSO_SAML_ASSERTION(self)->MinorVersion = (value)
#define LassoLibAssertion_MinorVersion_set(self, value) LASSO_SAML_ASSERTION(self)->MinorVersion = (value)

/* private_key_file */
#define LassoLibAssertion_get_private_key_file(self) LASSO_SAML_ASSERTION(self)->private_key_file
#define LassoLibAssertion_private_key_file_get(self) LASSO_SAML_ASSERTION(self)->private_key_file
#define LassoLibAssertion_set_private_key_file(self, value) set_string(&LASSO_SAML_ASSERTION(self)->private_key_file, (value))
#define LassoLibAssertion_private_key_file_set(self, value) set_string(&LASSO_SAML_ASSERTION(self)->private_key_file, (value))

/* sign_method */
#define LassoLibAssertion_get_sign_method(self) LASSO_SAML_ASSERTION(self)->sign_method
#define LassoLibAssertion_sign_method_get(self) LASSO_SAML_ASSERTION(self)->sign_method
#define LassoLibAssertion_set_sign_method(self, value) LASSO_SAML_ASSERTION(self)->sign_method = (value)
#define LassoLibAssertion_sign_method_set(self, value) LASSO_SAML_ASSERTION(self)->sign_method = (value)

/* sign_type */
#define LassoLibAssertion_get_sign_type(self) LASSO_SAML_ASSERTION(self)->sign_type
#define LassoLibAssertion_sign_type_get(self) LASSO_SAML_ASSERTION(self)->sign_type
#define LassoLibAssertion_set_sign_type(self, value) LASSO_SAML_ASSERTION(self)->sign_type = (value)
#define LassoLibAssertion_sign_type_set(self, value) LASSO_SAML_ASSERTION(self)->sign_type = (value)

/* SubjectStatement */
#define LassoLibAssertion_get_SubjectStatement(self) get_node(LASSO_SAML_ASSERTION(self)->SubjectStatement)
#define LassoLibAssertion_SubjectStatement_get(self) get_node(LASSO_SAML_ASSERTION(self)->SubjectStatement)
#define LassoLibAssertion_set_SubjectStatement(self, value) set_node((gpointer *) &LASSO_SAML_ASSERTION(self)->SubjectStatement, (value))
#define LassoLibAssertion_SubjectStatement_set(self, value) set_node((gpointer *) &LASSO_SAML_ASSERTION(self)->SubjectStatement, (value))

/* Implementations of methods inherited from SamlAssertion */

/* Constructors, destructors & static methods implementations */

#define new_LassoLibAssertion lasso_lib_assertion_new
#define delete_LassoLibAssertion(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoLibAssertion_newFull lasso_lib_assertion_new_full
#else
#define LibAssertion_newFull lasso_lib_assertion_new_full
#endif

/* Implementations of methods inherited from LassoNode */

#define LassoLibAssertion_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoLibAuthnRequest(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLibAuthnRequest(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLibAuthnRequest(zend_property_reference *property_reference);
static int _propget_LassoLibAuthnRequest(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from SamlpRequestAbstract */

/* certificate_file */
#define LassoLibAuthnRequest_get_certificate_file(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file
#define LassoLibAuthnRequest_certificate_file_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file
#define LassoLibAuthnRequest_set_certificate_file(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file, (value))
#define LassoLibAuthnRequest_certificate_file_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file, (value))

/* IssueInstant */
#define LassoLibAuthnRequest_get_IssueInstant(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant
#define LassoLibAuthnRequest_IssueInstant_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant
#define LassoLibAuthnRequest_set_IssueInstant(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant, (value))
#define LassoLibAuthnRequest_IssueInstant_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant, (value))

/* MajorVersion */
#define LassoLibAuthnRequest_get_MajorVersion(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion
#define LassoLibAuthnRequest_MajorVersion_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion
#define LassoLibAuthnRequest_set_MajorVersion(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion = (value)
#define LassoLibAuthnRequest_MajorVersion_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion = (value)

/* MinorVersion */
#define LassoLibAuthnRequest_get_MinorVersion(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion
#define LassoLibAuthnRequest_MinorVersion_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion
#define LassoLibAuthnRequest_set_MinorVersion(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion = (value)
#define LassoLibAuthnRequest_MinorVersion_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion = (value)

/* private_key_file */
#define LassoLibAuthnRequest_get_private_key_file(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file
#define LassoLibAuthnRequest_private_key_file_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file
#define LassoLibAuthnRequest_set_private_key_file(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file, (value))
#define LassoLibAuthnRequest_private_key_file_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file, (value))

/* RequestID */
#define LassoLibAuthnRequest_get_RequestID(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID
#define LassoLibAuthnRequest_RequestID_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID
#define LassoLibAuthnRequest_set_RequestID(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID, (value))
#define LassoLibAuthnRequest_RequestID_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID, (value))

/* RespondWith */
#define LassoLibAuthnRequest_get_RespondWith(self) get_string_list(LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith)
#define LassoLibAuthnRequest_RespondWith_get(self) get_string_list(LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith)
#define LassoLibAuthnRequest_set_RespondWith(self, value) set_string_list(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith, (value))
#define LassoLibAuthnRequest_RespondWith_set(self, value) set_string_list(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith, (value))

/* sign_method */
#define LassoLibAuthnRequest_get_sign_method(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method
#define LassoLibAuthnRequest_sign_method_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method
#define LassoLibAuthnRequest_set_sign_method(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method = (value)
#define LassoLibAuthnRequest_sign_method_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method = (value)

/* sign_type */
#define LassoLibAuthnRequest_get_sign_type(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type
#define LassoLibAuthnRequest_sign_type_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type
#define LassoLibAuthnRequest_set_sign_type(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type = (value)
#define LassoLibAuthnRequest_sign_type_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type = (value)

/* Attributes Implementations */

/* Extension */
#define LassoLibAuthnRequest_get_Extension(self) get_xml_list((self)->Extension)
#define LassoLibAuthnRequest_Extension_get(self) get_xml_list((self)->Extension)
#define LassoLibAuthnRequest_set_Extension(self, value) set_xml_list(&(self)->Extension, (value))
#define LassoLibAuthnRequest_Extension_set(self, value) set_xml_list(&(self)->Extension, (value))

/* RequestAuthnContext */
#define LassoLibAuthnRequest_get_RequestAuthnContext(self) get_node((self)->RequestAuthnContext)
#define LassoLibAuthnRequest_RequestAuthnContext_get(self) get_node((self)->RequestAuthnContext)
#define LassoLibAuthnRequest_set_RequestAuthnContext(self, value) set_node((gpointer *) &(self)->RequestAuthnContext, (value))
#define LassoLibAuthnRequest_RequestAuthnContext_set(self, value) set_node((gpointer *) &(self)->RequestAuthnContext, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoLibAuthnRequest lasso_lib_authn_request_new
#define delete_LassoLibAuthnRequest(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoLibAuthnRequest_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoLibAuthnResponse(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLibAuthnResponse(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLibAuthnResponse(zend_property_reference *property_reference);
static int _propget_LassoLibAuthnResponse(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from SamlpResponse */

/* Extension */
#define LassoLibAuthnResponse_get_Extension(self) get_xml_list((self)->Extension)
#define LassoLibAuthnResponse_Extension_get(self) get_xml_list((self)->Extension)
#define LassoLibAuthnResponse_set_Extension(self, value) set_xml_list(&(self)->Extension, (value))
#define LassoLibAuthnResponse_Extension_set(self, value) set_xml_list(&(self)->Extension, (value))

/* Status */
#define LassoLibAuthnResponse_get_Status(self) get_node(LASSO_SAMLP_RESPONSE(self)->Status)
#define LassoLibAuthnResponse_Status_get(self) get_node(LASSO_SAMLP_RESPONSE(self)->Status)
#define LassoLibAuthnResponse_set_Status(self, value) set_node((gpointer *) &LASSO_SAMLP_RESPONSE(self)->Status, (value))
#define LassoLibAuthnResponse_Status_set(self, value) set_node((gpointer *) &LASSO_SAMLP_RESPONSE(self)->Status, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoLibAuthnResponse lasso_lib_authn_response_new
#define delete_LassoLibAuthnResponse(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoLibAuthnResponse_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoLibFederationTerminationNotification(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLibFederationTerminationNotification(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLibFederationTerminationNotification(zend_property_reference *property_reference);
static int _propget_LassoLibFederationTerminationNotification(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from SamlpRequestAbstract */

/* certificate_file */
#define LassoLibFederationTerminationNotification_get_certificate_file(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file
#define LassoLibFederationTerminationNotification_certificate_file_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file
#define LassoLibFederationTerminationNotification_set_certificate_file(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file, (value))
#define LassoLibFederationTerminationNotification_certificate_file_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file, (value))

/* IssueInstant */
#define LassoLibFederationTerminationNotification_get_IssueInstant(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant
#define LassoLibFederationTerminationNotification_IssueInstant_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant
#define LassoLibFederationTerminationNotification_set_IssueInstant(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant, (value))
#define LassoLibFederationTerminationNotification_IssueInstant_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant, (value))

/* MajorVersion */
#define LassoLibFederationTerminationNotification_get_MajorVersion(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion
#define LassoLibFederationTerminationNotification_MajorVersion_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion
#define LassoLibFederationTerminationNotification_set_MajorVersion(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion = (value)
#define LassoLibFederationTerminationNotification_MajorVersion_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion = (value)

/* MinorVersion */
#define LassoLibFederationTerminationNotification_get_MinorVersion(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion
#define LassoLibFederationTerminationNotification_MinorVersion_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion
#define LassoLibFederationTerminationNotification_set_MinorVersion(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion = (value)
#define LassoLibFederationTerminationNotification_MinorVersion_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion = (value)

/* private_key_file */
#define LassoLibFederationTerminationNotification_get_private_key_file(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file
#define LassoLibFederationTerminationNotification_private_key_file_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file
#define LassoLibFederationTerminationNotification_set_private_key_file(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file, (value))
#define LassoLibFederationTerminationNotification_private_key_file_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file, (value))

/* RequestID */
#define LassoLibFederationTerminationNotification_get_RequestID(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID
#define LassoLibFederationTerminationNotification_RequestID_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID
#define LassoLibFederationTerminationNotification_set_RequestID(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID, (value))
#define LassoLibFederationTerminationNotification_RequestID_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID, (value))

/* RespondWith */
#define LassoLibFederationTerminationNotification_get_RespondWith(self) get_string_list(LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith)
#define LassoLibFederationTerminationNotification_RespondWith_get(self) get_string_list(LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith)
#define LassoLibFederationTerminationNotification_set_RespondWith(self, value) set_string_list(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith, (value))
#define LassoLibFederationTerminationNotification_RespondWith_set(self, value) set_string_list(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith, (value))

/* sign_method */
#define LassoLibFederationTerminationNotification_get_sign_method(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method
#define LassoLibFederationTerminationNotification_sign_method_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method
#define LassoLibFederationTerminationNotification_set_sign_method(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method = (value)
#define LassoLibFederationTerminationNotification_sign_method_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method = (value)

/* sign_type */
#define LassoLibFederationTerminationNotification_get_sign_type(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type
#define LassoLibFederationTerminationNotification_sign_type_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type
#define LassoLibFederationTerminationNotification_set_sign_type(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type = (value)
#define LassoLibFederationTerminationNotification_sign_type_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type = (value)

/* Attributes implementations */

/* Extension */
#define LassoLibFederationTerminationNotification_get_Extension(self) get_xml_list((self)->Extension)
#define LassoLibFederationTerminationNotification_Extension_get(self) get_xml_list((self)->Extension)
#define LassoLibFederationTerminationNotification_set_Extension(self, value) set_xml_list(&(self)->Extension, (value))
#define LassoLibFederationTerminationNotification_Extension_set(self, value) set_xml_list(&(self)->Extension, (value))

/* NameIdentifier */
#define LassoLibFederationTerminationNotification_get_NameIdentifier(self) get_node((self)->NameIdentifier)
#define LassoLibFederationTerminationNotification_NameIdentifier_get(self) get_node((self)->NameIdentifier)
#define LassoLibFederationTerminationNotification_set_NameIdentifier(self, value) set_node((gpointer *) &(self)->NameIdentifier, (value))
#define LassoLibFederationTerminationNotification_NameIdentifier_set(self, value) set_node((gpointer *) &(self)->NameIdentifier, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoLibFederationTerminationNotification lasso_lib_federation_termination_notification_new
#define delete_LassoLibFederationTerminationNotification(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoLibFederationTerminationNotification_newFull lasso_lib_federation_termination_notification_new_full
#else
#define LibFederationTerminationNotification_newFull lasso_lib_federation_termination_notification_new_full
#endif

/* Implementations of methods inherited from LassoNode */

#define LassoLibFederationTerminationNotification_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoLibLogoutRequest(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLibLogoutRequest(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLibLogoutRequest(zend_property_reference *property_reference);
static int _propget_LassoLibLogoutRequest(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from SamlpRequestAbstract */

/* certificate_file */
#define LassoLibLogoutRequest_get_certificate_file(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file
#define LassoLibLogoutRequest_certificate_file_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file
#define LassoLibLogoutRequest_set_certificate_file(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file, (value))
#define LassoLibLogoutRequest_certificate_file_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file, (value))

/* IssueInstant */
#define LassoLibLogoutRequest_get_IssueInstant(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant
#define LassoLibLogoutRequest_IssueInstant_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant
#define LassoLibLogoutRequest_set_IssueInstant(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant, (value))
#define LassoLibLogoutRequest_IssueInstant_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant, (value))

/* MajorVersion */
#define LassoLibLogoutRequest_get_MajorVersion(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion
#define LassoLibLogoutRequest_MajorVersion_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion
#define LassoLibLogoutRequest_set_MajorVersion(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion = (value)
#define LassoLibLogoutRequest_MajorVersion_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion = (value)

/* MinorVersion */
#define LassoLibLogoutRequest_get_MinorVersion(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion
#define LassoLibLogoutRequest_MinorVersion_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion
#define LassoLibLogoutRequest_set_MinorVersion(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion = (value)
#define LassoLibLogoutRequest_MinorVersion_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion = (value)

/* private_key_file */
#define LassoLibLogoutRequest_get_private_key_file(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file
#define LassoLibLogoutRequest_private_key_file_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file
#define LassoLibLogoutRequest_set_private_key_file(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file, (value))
#define LassoLibLogoutRequest_private_key_file_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file, (value))

/* RequestID */
#define LassoLibLogoutRequest_get_RequestID(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID
#define LassoLibLogoutRequest_RequestID_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID
#define LassoLibLogoutRequest_set_RequestID(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID, (value))
#define LassoLibLogoutRequest_RequestID_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID, (value))

/* RespondWith */
#define LassoLibLogoutRequest_get_RespondWith(self) get_string_list(LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith)
#define LassoLibLogoutRequest_RespondWith_get(self) get_string_list(LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith)
#define LassoLibLogoutRequest_set_RespondWith(self, value) set_string_list(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith, (value))
#define LassoLibLogoutRequest_RespondWith_set(self, value) set_string_list(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith, (value))

/* sign_method */
#define LassoLibLogoutRequest_get_sign_method(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method
#define LassoLibLogoutRequest_sign_method_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method
#define LassoLibLogoutRequest_set_sign_method(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method = (value)
#define LassoLibLogoutRequest_sign_method_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method = (value)

/* sign_type */
#define LassoLibLogoutRequest_get_sign_type(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type
#define LassoLibLogoutRequest_sign_type_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type
#define LassoLibLogoutRequest_set_sign_type(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type = (value)
#define LassoLibLogoutRequest_sign_type_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type = (value)

/* Attributes implementations */

/* Extension */
#define LassoLibLogoutRequest_get_Extension(self) get_xml_list((self)->Extension)
#define LassoLibLogoutRequest_Extension_get(self) get_xml_list((self)->Extension)
#define LassoLibLogoutRequest_set_Extension(self, value) set_xml_list(&(self)->Extension, (value))
#define LassoLibLogoutRequest_Extension_set(self, value) set_xml_list(&(self)->Extension, (value))

/* nameIdentifier */
#define LassoLibLogoutRequest_get_NameIdentifier(self) get_node((self)->NameIdentifier)
#define LassoLibLogoutRequest_NameIdentifier_get(self) get_node((self)->NameIdentifier)
#define LassoLibLogoutRequest_set_NameIdentifier(self, value) set_node((gpointer *) &(self)->NameIdentifier, (value))
#define LassoLibLogoutRequest_NameIdentifier_set(self, value) set_node((gpointer *) &(self)->NameIdentifier, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoLibLogoutRequest lasso_lib_logout_request_new
#define delete_LassoLibLogoutRequest(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoLibLogoutRequest_newFull lasso_lib_logout_request_new_full
#else
#define LibLogoutRequest_newFull lasso_lib_logout_request_new_full
#endif

/* Implementations of methods inherited from LassoNode */

#define LassoLibLogoutRequest_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoLibLogoutResponse(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLibLogoutResponse(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLibLogoutResponse(zend_property_reference *property_reference);
static int _propget_LassoLibLogoutResponse(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from LibStatusResponse */

/* Extension */
#define LassoLibLogoutResponse_get_Extension(self) get_xml_list(LASSO_LIB_STATUS_RESPONSE(self)->Extension)
#define LassoLibLogoutResponse_Extension_get(self) get_xml_list(LASSO_LIB_STATUS_RESPONSE(self)->Extension)
#define LassoLibLogoutResponse_set_Extension(self, value) set_xml_list(&LASSO_LIB_STATUS_RESPONSE(self)->Extension, (value))
#define LassoLibLogoutResponse_Extension_set(self, value) set_xml_list(&LASSO_LIB_STATUS_RESPONSE(self)->Extension, (value))

/* providerId */
#define LassoLibLogoutResponse_get_ProviderID(self) LASSO_LIB_STATUS_RESPONSE(self)->ProviderID
#define LassoLibLogoutResponse_ProviderID_get(self) LASSO_LIB_STATUS_RESPONSE(self)->ProviderID
#define LassoLibLogoutResponse_set_ProviderID(self, value) set_string(&LASSO_LIB_STATUS_RESPONSE(self)->ProviderID, (value))
#define LassoLibLogoutResponse_ProviderID_set(self, value) set_string(&LASSO_LIB_STATUS_RESPONSE(self)->ProviderID, (value))

/* RelayState */
#define LassoLibLogoutResponse_get_RelayState(self) LASSO_LIB_STATUS_RESPONSE(self)->RelayState
#define LassoLibLogoutResponse_RelayState_get(self) LASSO_LIB_STATUS_RESPONSE(self)->RelayState
#define LassoLibLogoutResponse_set_RelayState(self, value) set_string(&LASSO_LIB_STATUS_RESPONSE(self)->RelayState, (value))
#define LassoLibLogoutResponse_RelayState_set(self, value) set_string(&LASSO_LIB_STATUS_RESPONSE(self)->RelayState, (value))

/* Status */
#define LassoLibLogoutResponse_get_Status(self) get_node(LASSO_LIB_STATUS_RESPONSE(self)->Status)
#define LassoLibLogoutResponse_Status_get(self) get_node(LASSO_LIB_STATUS_RESPONSE(self)->Status)
#define LassoLibLogoutResponse_set_Status(self, value) set_node((gpointer *) &LASSO_LIB_STATUS_RESPONSE(self)->Status, (value))
#define LassoLibLogoutResponse_Status_set(self, value) set_node((gpointer *) &LASSO_LIB_STATUS_RESPONSE(self)->Status, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoLibLogoutResponse lasso_lib_logout_response_new
#define delete_LassoLibLogoutResponse(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoLibLogoutResponse_newFull lasso_lib_logout_response_new_full
#else
#define LibLogoutResponse_newFull lasso_lib_logout_response_new_full
#endif

/* Implementations of methods inherited from LassoNode */

#define LassoLibLogoutResponse_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoLibRegisterNameIdentifierRequest(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLibRegisterNameIdentifierRequest(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLibRegisterNameIdentifierRequest(zend_property_reference *property_reference);
static int _propget_LassoLibRegisterNameIdentifierRequest(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from SamlpRequestAbstract */

/* certificate_file */
#define LassoLibRegisterNameIdentifierRequest_get_certificate_file(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file
#define LassoLibRegisterNameIdentifierRequest_certificate_file_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file
#define LassoLibRegisterNameIdentifierRequest_set_certificate_file(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file, (value))
#define LassoLibRegisterNameIdentifierRequest_certificate_file_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->certificate_file, (value))

/* IssueInstant */
#define LassoLibRegisterNameIdentifierRequest_get_IssueInstant(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant
#define LassoLibRegisterNameIdentifierRequest_IssueInstant_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant
#define LassoLibRegisterNameIdentifierRequest_set_IssueInstant(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant, (value))
#define LassoLibRegisterNameIdentifierRequest_IssueInstant_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->IssueInstant, (value))

/* MajorVersion */
#define LassoLibRegisterNameIdentifierRequest_get_MajorVersion(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion
#define LassoLibRegisterNameIdentifierRequest_MajorVersion_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion
#define LassoLibRegisterNameIdentifierRequest_set_MajorVersion(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion = (value)
#define LassoLibRegisterNameIdentifierRequest_MajorVersion_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MajorVersion = (value)

/* MinorVersion */
#define LassoLibRegisterNameIdentifierRequest_get_MinorVersion(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion
#define LassoLibRegisterNameIdentifierRequest_MinorVersion_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion
#define LassoLibRegisterNameIdentifierRequest_set_MinorVersion(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion = (value)
#define LassoLibRegisterNameIdentifierRequest_MinorVersion_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->MinorVersion = (value)

/* private_key_file */
#define LassoLibRegisterNameIdentifierRequest_get_private_key_file(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file
#define LassoLibRegisterNameIdentifierRequest_private_key_file_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file
#define LassoLibRegisterNameIdentifierRequest_set_private_key_file(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file, (value))
#define LassoLibRegisterNameIdentifierRequest_private_key_file_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->private_key_file, (value))

/* RequestID */
#define LassoLibRegisterNameIdentifierRequest_get_RequestID(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID
#define LassoLibRegisterNameIdentifierRequest_RequestID_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID
#define LassoLibRegisterNameIdentifierRequest_set_RequestID(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID, (value))
#define LassoLibRegisterNameIdentifierRequest_RequestID_set(self, value) set_string(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RequestID, (value))

/* RespondWith */
#define LassoLibRegisterNameIdentifierRequest_get_RespondWith(self) get_string_list(LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith)
#define LassoLibRegisterNameIdentifierRequest_RespondWith_get(self) get_string_list(LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith)
#define LassoLibRegisterNameIdentifierRequest_set_RespondWith(self, value) set_string_list(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith, (value))
#define LassoLibRegisterNameIdentifierRequest_RespondWith_set(self, value) set_string_list(&LASSO_SAMLP_REQUEST_ABSTRACT(self)->RespondWith, (value))

/* sign_method */
#define LassoLibRegisterNameIdentifierRequest_get_sign_method(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method
#define LassoLibRegisterNameIdentifierRequest_sign_method_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method
#define LassoLibRegisterNameIdentifierRequest_set_sign_method(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method = (value)
#define LassoLibRegisterNameIdentifierRequest_sign_method_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_method = (value)

/* sign_type */
#define LassoLibRegisterNameIdentifierRequest_get_sign_type(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type
#define LassoLibRegisterNameIdentifierRequest_sign_type_get(self) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type
#define LassoLibRegisterNameIdentifierRequest_set_sign_type(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type = (value)
#define LassoLibRegisterNameIdentifierRequest_sign_type_set(self, value) LASSO_SAMLP_REQUEST_ABSTRACT(self)->sign_type = (value)

/* Attributes implementations */

/* Extension */
#define LassoLibRegisterNameIdentifierRequest_get_Extension(self) get_xml_list((self)->Extension)
#define LassoLibRegisterNameIdentifierRequest_Extension_get(self) get_xml_list((self)->Extension)
#define LassoLibRegisterNameIdentifierRequest_set_Extension(self, value) set_xml_list(&(self)->Extension, (value))
#define LassoLibRegisterNameIdentifierRequest_Extension_set(self, value) set_xml_list(&(self)->Extension, (value))

/* idpProvidedNameIdentifier */
#define LassoLibRegisterNameIdentifierRequest_get_IDPProvidedNameIdentifier(self) get_node((self)->IDPProvidedNameIdentifier)
#define LassoLibRegisterNameIdentifierRequest_IDPProvidedNameIdentifier_get(self) get_node((self)->IDPProvidedNameIdentifier)
#define LassoLibRegisterNameIdentifierRequest_set_IDPProvidedNameIdentifier(self, value) set_node((gpointer *) &(self)->IDPProvidedNameIdentifier, (value))
#define LassoLibRegisterNameIdentifierRequest_IDPProvidedNameIdentifier_set(self, value) set_node((gpointer *) &(self)->IDPProvidedNameIdentifier, (value))

/* oldProvidedNameIdentifier */
#define LassoLibRegisterNameIdentifierRequest_get_OldProvidedNameIdentifier(self) get_node((self)->OldProvidedNameIdentifier)
#define LassoLibRegisterNameIdentifierRequest_OldProvidedNameIdentifier_get(self) get_node((self)->OldProvidedNameIdentifier)
#define LassoLibRegisterNameIdentifierRequest_set_OldProvidedNameIdentifier(self, value) set_node((gpointer *) &(self)->OldProvidedNameIdentifier, (value))
#define LassoLibRegisterNameIdentifierRequest_OldProvidedNameIdentifier_set(self, value) set_node((gpointer *) &(self)->OldProvidedNameIdentifier, (value))

/* spProvidedNameIdentifier */
#define LassoLibRegisterNameIdentifierRequest_get_SPProvidedNameIdentifier(self) get_node((self)->SPProvidedNameIdentifier)
#define LassoLibRegisterNameIdentifierRequest_SPProvidedNameIdentifier_get(self) get_node((self)->SPProvidedNameIdentifier)
#define LassoLibRegisterNameIdentifierRequest_set_SPProvidedNameIdentifier(self, value) set_node((gpointer *) &(self)->SPProvidedNameIdentifier, (value))
#define LassoLibRegisterNameIdentifierRequest_SPProvidedNameIdentifier_set(self, value) set_node((gpointer *) &(self)->SPProvidedNameIdentifier, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoLibRegisterNameIdentifierRequest lasso_lib_register_name_identifier_request_new
#define delete_LassoLibRegisterNameIdentifierRequest(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoLibRegisterNameIdentifierRequest_newFull lasso_lib_register_name_identifier_request_new_full
#else
#define LibRegisterNameIdentifierRequest_newFull lasso_lib_register_name_identifier_request_new_full
#endif

/* Implementations of methods inherited from LassoNode */

#define LassoLibRegisterNameIdentifierRequest_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoLibRegisterNameIdentifierResponse(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLibRegisterNameIdentifierResponse(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLibRegisterNameIdentifierResponse(zend_property_reference *property_reference);
static int _propget_LassoLibRegisterNameIdentifierResponse(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from LibStatusResponse */

/* Extension */
#define LassoLibRegisterNameIdentifierResponse_get_Extension(self) get_xml_list(LASSO_LIB_STATUS_RESPONSE(self)->Extension)
#define LassoLibRegisterNameIdentifierResponse_Extension_get(self) get_xml_list(LASSO_LIB_STATUS_RESPONSE(self)->Extension)
#define LassoLibRegisterNameIdentifierResponse_set_Extension(self, value) set_xml_list(&LASSO_LIB_STATUS_RESPONSE(self)->Extension, (value))
#define LassoLibRegisterNameIdentifierResponse_Extension_set(self, value) set_xml_list(&LASSO_LIB_STATUS_RESPONSE(self)->Extension, (value))

/* providerId */
#define LassoLibRegisterNameIdentifierResponse_get_ProviderID(self) LASSO_LIB_STATUS_RESPONSE(self)->ProviderID
#define LassoLibRegisterNameIdentifierResponse_ProviderID_get(self) LASSO_LIB_STATUS_RESPONSE(self)->ProviderID
#define LassoLibRegisterNameIdentifierResponse_set_ProviderID(self, value) set_string(&LASSO_LIB_STATUS_RESPONSE(self)->ProviderID, (value))
#define LassoLibRegisterNameIdentifierResponse_ProviderID_set(self, value) set_string(&LASSO_LIB_STATUS_RESPONSE(self)->ProviderID, (value))

/* RelayState */
#define LassoLibRegisterNameIdentifierResponse_get_RelayState(self) LASSO_LIB_STATUS_RESPONSE(self)->RelayState
#define LassoLibRegisterNameIdentifierResponse_RelayState_get(self) LASSO_LIB_STATUS_RESPONSE(self)->RelayState
#define LassoLibRegisterNameIdentifierResponse_set_RelayState(self, value) set_string(&LASSO_LIB_STATUS_RESPONSE(self)->RelayState, (value))
#define LassoLibRegisterNameIdentifierResponse_RelayState_set(self, value) set_string(&LASSO_LIB_STATUS_RESPONSE(self)->RelayState, (value))

/* Status */
#define LassoLibRegisterNameIdentifierResponse_get_Status(self) get_node(LASSO_LIB_STATUS_RESPONSE(self)->Status)
#define LassoLibRegisterNameIdentifierResponse_Status_get(self) get_node(LASSO_LIB_STATUS_RESPONSE(self)->Status)
#define LassoLibRegisterNameIdentifierResponse_set_Status(self, value) set_node((gpointer *) &LASSO_LIB_STATUS_RESPONSE(self)->Status, (value))
#define LassoLibRegisterNameIdentifierResponse_Status_set(self, value) set_node((gpointer *) &LASSO_LIB_STATUS_RESPONSE(self)->Status, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoLibRegisterNameIdentifierResponse lasso_lib_register_name_identifier_response_new
#define delete_LassoLibRegisterNameIdentifierResponse(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoLibRegisterNameIdentifierResponse_newFull lasso_lib_register_name_identifier_response_new_full
#else
#define LibRegisterNameIdentifierResponse_newFull lasso_lib_register_name_identifier_response_new_full
#endif

/* Implementations of methods inherited from LassoNode */

#define LassoLibRegisterNameIdentifierResponse_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoLibRequestAuthnContext(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLibRequestAuthnContext(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLibRequestAuthnContext(zend_property_reference *property_reference);
static int _propget_LassoLibRequestAuthnContext(zend_property_reference *property_reference, pval *value);


/* Attributes implementations */

/* authnContextClassRef */
#define LassoLibRequestAuthnContext_get_authnContextClassRef(self) get_string_list((self)->AuthnContextClassRef)
#define LassoLibRequestAuthnContext_authnContextClassRef_get(self) get_string_list((self)->AuthnContextClassRef)
#define LassoLibRequestAuthnContext_set_authnContextClassRef(self, value) set_string_list(&(self)->AuthnContextClassRef, (value))
#define LassoLibRequestAuthnContext_authnContextClassRef_set(self, value) set_string_list(&(self)->AuthnContextClassRef, (value))

/* authnContextStatementRef */
#define LassoLibRequestAuthnContext_get_authnContextStatementRef(self) get_string_list((self)->AuthnContextStatementRef)
#define LassoLibRequestAuthnContext_authnContextStatementRef_get(self) get_string_list((self)->AuthnContextStatementRef)
#define LassoLibRequestAuthnContext_set_authnContextStatementRef(self, value) set_string_list(&(self)->AuthnContextStatementRef, (value))
#define LassoLibRequestAuthnContext_authnContextStatementRef_set(self, value) set_string_list(&(self)->AuthnContextStatementRef, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoLibRequestAuthnContext lasso_lib_request_authn_context_new
#define delete_LassoLibRequestAuthnContext(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoLibRequestAuthnContext_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoLibStatusResponse(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLibStatusResponse(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLibStatusResponse(zend_property_reference *property_reference);
static int _propget_LassoLibStatusResponse(zend_property_reference *property_reference, pval *value);


/* Attributes implementations */

/* Extension */
#define LassoLibStatusResponse_get_Extension(self) get_xml_list((self)->Extension)
#define LassoLibStatusResponse_Extension_get(self) get_xml_list((self)->Extension)
#define LassoLibStatusResponse_set_Extension(self, value) set_xml_list(&(self)->Extension, (value))
#define LassoLibStatusResponse_Extension_set(self, value) set_xml_list(&(self)->Extension, (value))

/* Status */
#define LassoLibStatusResponse_get_Status(self) get_node((self)->Status)
#define LassoLibStatusResponse_Status_get(self) get_node((self)->Status)
#define LassoLibStatusResponse_set_Status(self, value) set_node((gpointer *) &(self)->Status, (value))
#define LassoLibStatusResponse_Status_set(self, value) set_node((gpointer *) &(self)->Status, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoLibStatusResponse lasso_lib_status_response_new
#define delete_LassoLibStatusResponse(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoLibStatusResponse_dump(self) lasso_node_dump(LASSO_NODE(self))


static int _wrap_propset_LassoProvider(zend_property_reference *property_reference, pval *value);
static int _propset_LassoProvider(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoProvider(zend_property_reference *property_reference);
static int _propget_LassoProvider(zend_property_reference *property_reference, pval *value);


/* Constructors, destructors & static methods implementations */

#define new_LassoProvider lasso_provider_new
#define delete_LassoProvider(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoProvider_newFromDump lasso_provider_new_from_dump
#else
#define Provider_newFromDump lasso_provider_new_from_dump
#endif

/* Implementations of methods inherited from LassoNode */

#define LassoProvider_dump(self) lasso_node_dump(LASSO_NODE(self))

/* Methods implementations */

#define LassoProvider_acceptHttpMethod lasso_provider_accept_http_method
#define LassoProvider_getAssertionConsumerServiceUrl lasso_provider_get_assertion_consumer_service_url
#define LassoProvider_getBase64SuccinctId lasso_provider_get_base64_succinct_id
#define LassoProvider_getFirstHttpMethod lasso_provider_get_first_http_method
#define LassoProvider_getMetadataOne lasso_provider_get_metadata_one
#define LassoProvider_hasProtocolProfile lasso_provider_has_protocol_profile
#define LassoProvider_getOrganization(self) get_xml_string(lasso_provider_get_organization(self))


static int _wrap_propset_LassoServer(zend_property_reference *property_reference, pval *value);
static int _propset_LassoServer(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoServer(zend_property_reference *property_reference);
static int _propget_LassoServer(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from Provider */

/* providerId */
#define LassoServer_get_ProviderID(self) LASSO_PROVIDER(self)->ProviderID
#define LassoServer_ProviderID_get(self) LASSO_PROVIDER(self)->ProviderID
#define LassoServer_set_ProviderID(self, value) set_string(&LASSO_PROVIDER(self)->ProviderID, (value))
#define LassoServer_ProviderID_set(self, value) set_string(&LASSO_PROVIDER(self)->ProviderID, (value))

/* ca_cert_chain */
#define LassoServer_get_ca_cert_chain(self) LASSO_PROVIDER(self)->ca_cert_chain
#define LassoServer_ca_cert_chain_get(self) LASSO_PROVIDER(self)->ca_cert_chain
#define LassoServer_set_ca_cert_chain(self, value) set_string(&LASSO_PROVIDER(self)->ca_cert_chain, (value))
#define LassoServer_ca_cert_chain_set(self, value) set_string(&LASSO_PROVIDER(self)->ca_cert_chain, (value))

/* metadata_filename */
#define LassoServer_get_metadata_filename(self) LASSO_PROVIDER(self)->metadata_filename
#define LassoServer_metadata_filename_get(self) LASSO_PROVIDER(self)->metadata_filename
#define LassoServer_set_metadata_filename(self, value) set_string(&LASSO_PROVIDER(self)->metadata_filename, (value))
#define LassoServer_metadata_filename_set(self, value) set_string(&LASSO_PROVIDER(self)->metadata_filename, (value))

/* public_key */
#define LassoServer_get_public_key(self) LASSO_PROVIDER(self)->public_key
#define LassoServer_public_key_get(self) LASSO_PROVIDER(self)->public_key
#define LassoServer_set_public_key(self, value) set_string(&LASSO_PROVIDER(self)->public_key, (value))
#define LassoServer_public_key_set(self, value) set_string(&LASSO_PROVIDER(self)->public_key, (value))

/* role */
#define LassoServer_get_role(self) LASSO_PROVIDER(self)->role
#define LassoServer_role_get(self) LASSO_PROVIDER(self)->role
#define LassoServer_set_role(self, value) LASSO_PROVIDER(self)->role = value
#define LassoServer_role_set(self, value) LASSO_PROVIDER(self)->role = value

/* Attributes implementations */

/* providerIds */
#define LassoServer_get_providerIds LassoServer_providerIds_get
LassoStringList *LassoServer_providerIds_get(LassoServer *self) {
	GPtrArray *providerIds = g_ptr_array_sized_new(g_hash_table_size(self->providers));
	g_hash_table_foreach(self->providers, (GHFunc) add_key_to_array, providerIds);
	return providerIds;
}

/* Constructors, destructors & static methods implementations */

#define new_LassoServer lasso_server_new
#define delete_LassoServer(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoServer_newFromDump lasso_server_new_from_dump
#else
#define Server_newFromDump lasso_server_new_from_dump
#endif

/* Implementations of methods inherited from Provider */

#define LassoServer_acceptHttpMethod(server, remote_provider, protocol_type, http_method, initiate_profile) lasso_provider_accept_http_method(LASSO_PROVIDER(server), remote_provider, protocol_type, http_method, initiate_profile)
#define LassoServer_getAssertionConsumerServiceUrl(server, service_id) lasso_provider_get_assertion_consumer_service_url(LASSO_PROVIDER(server), service_id)
#define LassoServer_getBase64SuccinctId(server) lasso_provider_get_base64_succinct_id(LASSO_PROVIDER(server))
#define LassoServer_getFirstHttpMethod(server, remote_provider, protocol_type) lasso_provider_get_first_http_method(LASSO_PROVIDER(server), remote_provider, protocol_type)
#define LassoServer_getMetadataOne(server, name) lasso_provider_get_metadata_one(LASSO_PROVIDER(server), name)
#define LassoServer_hasProtocolProfile(server, protocol_type, protocol_profile) lasso_provider_has_protocol_profile(LASSO_PROVIDER(server), protocol_type, protocol_profile)
#define LassoServer_getOrganization(server) get_xml_string(lasso_provider_get_organization(LASSO_PROVIDER(server)))

/* Methods implementations */

#define LassoServer_addProvider lasso_server_add_provider
#define LassoServer_addService lasso_server_add_service
#define LassoServer_dump lasso_server_dump
#define LassoServer_getProvider lasso_server_get_provider
#define LassoServer_getService lasso_server_get_service


static int _wrap_propset_LassoFederation(zend_property_reference *property_reference, pval *value);
static int _propset_LassoFederation(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoFederation(zend_property_reference *property_reference);
static int _propget_LassoFederation(zend_property_reference *property_reference, pval *value);


/* Attributes implementations */

/* localNameIdentifier */
#define LassoFederation_get_local_nameIdentifier(self) get_node((self)->local_nameIdentifier)
#define LassoFederation_local_nameIdentifier_get(self) get_node((self)->local_nameIdentifier)
#define LassoFederation_set_local_nameIdentifier(self, value) set_node((gpointer *) &(self)->local_nameIdentifier, (value))
#define LassoFederation_local_nameIdentifier_set(self, value) set_node((gpointer *) &(self)->local_nameIdentifier, (value))

/* remoteNameIdentifier */
#define LassoFederation_get_remote_nameIdentifier(self) get_node((self)->remote_nameIdentifier)
#define LassoFederation_remote_nameIdentifier_get(self) get_node((self)->remote_nameIdentifier)
#define LassoFederation_set_remote_nameIdentifier(self, value) set_node((gpointer *) &(self)->remote_nameIdentifier, (value))
#define LassoFederation_remote_nameIdentifier_set(self, value) set_node((gpointer *) &(self)->remote_nameIdentifier, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoFederation lasso_federation_new
#define delete_LassoFederation(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from LassoNode */

#define LassoFederation_dump(self) lasso_node_dump(LASSO_NODE(self))

/* Methods implementations */

#define LassoFederation_buildLocalNameIdentifier lasso_federation_build_local_name_identifier
#define LassoFederation_verifyNameIdentifier lasso_federation_verify_name_identifier


static int _wrap_propset_LassoIdentity(zend_property_reference *property_reference, pval *value);
static int _propset_LassoIdentity(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoIdentity(zend_property_reference *property_reference);
static int _propget_LassoIdentity(zend_property_reference *property_reference, pval *value);


/* Attributes implementations */

/* providerIds */
#define LassoIdentity_get_providerIds LassoIdentity_providerIds_get
LassoStringList *LassoIdentity_providerIds_get(LassoIdentity *self) {
	GPtrArray *providerIds = g_ptr_array_sized_new(g_hash_table_size(self->federations));
	g_hash_table_foreach(self->federations, (GHFunc) add_key_to_array, providerIds);
	return providerIds;
}

/* Constructors, destructors & static methods implementations */

#define new_LassoIdentity lasso_identity_new
#define delete_LassoIdentity(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoIdentity_newFromDump lasso_identity_new_from_dump
#else
#define Identity_newFromDump lasso_identity_new_from_dump
#endif

/* Methods implementations */

#define LassoIdentity_dump lasso_identity_dump
#define LassoIdentity_getFederation lasso_identity_get_federation

#ifdef LASSO_WSF_ENABLED
#define LassoIdentity_addResourceOffering lasso_identity_add_resource_offering
#define LassoIdentity_removeResourceOffering lasso_identity_remove_resource_offering

LassoNodeList *LassoIdentity_getOfferings(LassoIdentity *self, const char *service_type) {
	GPtrArray *array = NULL;
	GList *list;

	list = lasso_identity_get_offerings(self, service_type);
	if (list) {
		array = get_node_list(list);
		g_list_foreach(list, (GFunc) free_node_list_item, NULL);
		g_list_free(list);
	}
	return array;
}
#endif


static int _wrap_propset_LassoSession(zend_property_reference *property_reference, pval *value);
static int _propset_LassoSession(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoSession(zend_property_reference *property_reference);
static int _propget_LassoSession(zend_property_reference *property_reference, pval *value);


/* Attributes implementations */

/* providerIds */
#define LassoSession_get_providerIds LassoSession_providerIds_get
LassoStringList *LassoSession_providerIds_get(LassoSession *self) {
	GPtrArray *providerIds = g_ptr_array_sized_new(g_hash_table_size(self->assertions));
	g_hash_table_foreach(self->assertions, (GHFunc) add_key_to_array, providerIds);
	return providerIds;
}

/* Constructors, destructors & static methods implementations */

#define new_LassoSession lasso_session_new
#define delete_LassoSession(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoSession_newFromDump lasso_session_new_from_dump
#else
#define Session_newFromDump lasso_session_new_from_dump
#endif

/* Methods implementations */

#define LassoSession_dump lasso_session_dump

LassoNodeList *LassoSession_getAssertions(LassoSession *self, char *providerId) {
	GPtrArray *assertionsArray;
	GList *assertionsList;

	assertionsList = lasso_session_get_assertions(self, providerId);
	if (assertionsList) {
		assertionsArray = get_node_list(assertionsList);
		g_list_foreach(assertionsList, (GFunc) free_node_list_item, NULL);
		g_list_free(assertionsList);
	} else
		assertionsArray = NULL;
	return assertionsArray;
}


static int _wrap_propset_LassoDefederation(zend_property_reference *property_reference, pval *value);
static int _propset_LassoDefederation(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoDefederation(zend_property_reference *property_reference);
static int _propget_LassoDefederation(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from Profile */

/* identity */
#define LassoDefederation_get_identity(self) lasso_profile_get_identity(LASSO_PROFILE(self))
#define LassoDefederation_identity_get(self) lasso_profile_get_identity(LASSO_PROFILE(self))
#define LassoDefederation_set_identity(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->identity, (value))
#define LassoDefederation_identity_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->identity, (value))

/* isIdentityDirty */
#define LassoDefederation_get_isIdentityDirty(self) lasso_profile_is_identity_dirty(LASSO_PROFILE(self))
#define LassoDefederation_isIdentityDirty_get(self) lasso_profile_is_identity_dirty(LASSO_PROFILE(self))

/* isSessionDirty */
#define LassoDefederation_get_isSessionDirty(self) lasso_profile_is_session_dirty(LASSO_PROFILE(self))
#define LassoDefederation_isSessionDirty_get(self) lasso_profile_is_session_dirty(LASSO_PROFILE(self))

/* msgBody */
#define LassoDefederation_get_msgBody(self) LASSO_PROFILE(self)->msg_body
#define LassoDefederation_msgBody_get(self) LASSO_PROFILE(self)->msg_body

/* msgRelayState */
#define LassoDefederation_get_msgRelayState(self) LASSO_PROFILE(self)->msg_relayState
#define LassoDefederation_msgRelayState_get(self) LASSO_PROFILE(self)->msg_relayState

/* msgUrl */
#define LassoDefederation_get_msgUrl(self) LASSO_PROFILE(self)->msg_url
#define LassoDefederation_msgUrl_get(self) LASSO_PROFILE(self)->msg_url

/* nameIdentifier */
#define LassoDefederation_get_nameIdentifier(self) get_node(LASSO_PROFILE(self)->nameIdentifier)
#define LassoDefederation_nameIdentifier_get(self) get_node(LASSO_PROFILE(self)->nameIdentifier)
#define LassoDefederation_set_nameIdentifier(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->nameIdentifier, (value))
#define LassoDefederation_nameIdentifier_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->nameIdentifier, (value))

/* remoteProviderId */
#define LassoDefederation_get_remoteProviderId(self) LASSO_PROFILE(self)->remote_providerID
#define LassoDefederation_remoteProviderId_get(self) LASSO_PROFILE(self)->remote_providerID
#define LassoDefederation_set_remoteProviderId(self, value) set_string(&LASSO_PROFILE(self)->remote_providerID, (value))
#define LassoDefederation_remoteProviderId_set(self, value) set_string(&LASSO_PROFILE(self)->remote_providerID, (value))

/* request */
#define LassoDefederation_get_request(self) get_node(LASSO_PROFILE(self)->request)
#define LassoDefederation_request_get(self) get_node(LASSO_PROFILE(self)->request)
#define LassoDefederation_set_request(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->request, (value))
#define LassoDefederation_request_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->request, (value))

/* response */
#define LassoDefederation_get_response(self) get_node(LASSO_PROFILE(self)->response)
#define LassoDefederation_response_get(self) get_node(LASSO_PROFILE(self)->response)
#define LassoDefederation_set_response(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->response, (value))
#define LassoDefederation_response_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->response, (value))

/* server */
#define LassoDefederation_get_server(self) get_node(LASSO_PROFILE(self)->server)
#define LassoDefederation_server_get(self) get_node(LASSO_PROFILE(self)->server)
#define LassoDefederation_set_server(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->server, (value))
#define LassoDefederation_server_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->server, (value))

/* session */
#define LassoDefederation_get_session(self) lasso_profile_get_session(LASSO_PROFILE(self))
#define LassoDefederation_session_get(self) lasso_profile_get_session(LASSO_PROFILE(self))
#define LassoDefederation_set_session(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->session, (value))
#define LassoDefederation_session_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->session, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoDefederation lasso_defederation_new
#define delete_LassoDefederation(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from Profile */

int LassoDefederation_setIdentityFromDump(LassoDefederation *self, char *dump) {
	return lasso_profile_set_identity_from_dump(LASSO_PROFILE(self), dump);
}

int LassoDefederation_setSessionFromDump(LassoDefederation *self, char *dump) {
	return lasso_profile_set_session_from_dump(LASSO_PROFILE(self), dump);
}

/* Methods implementations */

#define LassoDefederation_buildNotificationMsg lasso_defederation_build_notification_msg
#define LassoDefederation_initNotification lasso_defederation_init_notification
#define LassoDefederation_processNotificationMsg lasso_defederation_process_notification_msg
#define LassoDefederation_validateNotification lasso_defederation_validate_notification


static int _wrap_propset_LassoLogin(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLogin(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLogin(zend_property_reference *property_reference);
static int _propget_LassoLogin(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from Profile */

/* identity */
#define LassoLogin_get_identity(self) lasso_profile_get_identity(LASSO_PROFILE(self))
#define LassoLogin_identity_get(self) lasso_profile_get_identity(LASSO_PROFILE(self))
#define LassoLogin_set_identity(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->identity, (value))
#define LassoLogin_identity_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->identity, (value))

/* isIdentityDirty */
#define LassoLogin_get_isIdentityDirty(self) lasso_profile_is_identity_dirty(LASSO_PROFILE(self))
#define LassoLogin_isIdentityDirty_get(self) lasso_profile_is_identity_dirty(LASSO_PROFILE(self))

/* isSessionDirty */
#define LassoLogin_get_isSessionDirty(self) lasso_profile_is_session_dirty(LASSO_PROFILE(self))
#define LassoLogin_isSessionDirty_get(self) lasso_profile_is_session_dirty(LASSO_PROFILE(self))

/* msgBody */
#define LassoLogin_get_msgBody(self) LASSO_PROFILE(self)->msg_body
#define LassoLogin_msgBody_get(self) LASSO_PROFILE(self)->msg_body

/* msgRelayState */
#define LassoLogin_get_msgRelayState(self) LASSO_PROFILE(self)->msg_relayState
#define LassoLogin_msgRelayState_get(self) LASSO_PROFILE(self)->msg_relayState

/* msgUrl */
#define LassoLogin_get_msgUrl(self) LASSO_PROFILE(self)->msg_url
#define LassoLogin_msgUrl_get(self) LASSO_PROFILE(self)->msg_url

/* nameIdentifier */
#define LassoLogin_get_nameIdentifier(self) get_node(LASSO_PROFILE(self)->nameIdentifier)
#define LassoLogin_nameIdentifier_get(self) get_node(LASSO_PROFILE(self)->nameIdentifier)
#define LassoLogin_set_nameIdentifier(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->nameIdentifier, (value))
#define LassoLogin_nameIdentifier_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->nameIdentifier, (value))

/* remoteProviderId */
#define LassoLogin_get_remoteProviderId(self) LASSO_PROFILE(self)->remote_providerID
#define LassoLogin_remoteProviderId_get(self) LASSO_PROFILE(self)->remote_providerID
#define LassoLogin_set_remoteProviderId(self, value) set_string(&LASSO_PROFILE(self)->remote_providerID, (value))
#define LassoLogin_remoteProviderId_set(self, value) set_string(&LASSO_PROFILE(self)->remote_providerID, (value))

/* request */
#define LassoLogin_get_request(self) get_node(LASSO_PROFILE(self)->request)
#define LassoLogin_request_get(self) get_node(LASSO_PROFILE(self)->request)
#define LassoLogin_set_request(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->request, (value))
#define LassoLogin_request_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->request, (value))

/* response */
#define LassoLogin_get_response(self) get_node(LASSO_PROFILE(self)->response)
#define LassoLogin_response_get(self) get_node(LASSO_PROFILE(self)->response)
#define LassoLogin_set_response(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->response, (value))
#define LassoLogin_response_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->response, (value))

/* server */
#define LassoLogin_get_server(self) get_node(LASSO_PROFILE(self)->server)
#define LassoLogin_server_get(self) get_node(LASSO_PROFILE(self)->server)
#define LassoLogin_set_server(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->server, (value))
#define LassoLogin_server_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->server, (value))

/* session */
#define LassoLogin_get_session(self) lasso_profile_get_session(LASSO_PROFILE(self))
#define LassoLogin_session_get(self) lasso_profile_get_session(LASSO_PROFILE(self))
#define LassoLogin_set_session(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->session, (value))
#define LassoLogin_session_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->session, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoLogin lasso_login_new
#define delete_LassoLogin(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoLogin_newFromDump lasso_login_new_from_dump
#else
#define Login_newFromDump lasso_login_new_from_dump
#endif

/* Implementations of methods inherited from Profile */

int LassoLogin_setIdentityFromDump(LassoLogin *self, char *dump) {
	return lasso_profile_set_identity_from_dump(LASSO_PROFILE(self), dump);
}

int LassoLogin_setSessionFromDump(LassoLogin *self, char *dump) {
	return lasso_profile_set_session_from_dump(LASSO_PROFILE(self), dump);
}

/* Methods implementations */

#define LassoLogin_acceptSso lasso_login_accept_sso
#define LassoLogin_buildAssertion lasso_login_build_assertion
#define LassoLogin_buildArtifactMsg lasso_login_build_artifact_msg
#define LassoLogin_buildAuthnRequestMsg lasso_login_build_authn_request_msg
#define LassoLogin_buildAuthnResponseMsg lasso_login_build_authn_response_msg
#define LassoLogin_buildRequestMsg lasso_login_build_request_msg
#define LassoLogin_buildResponseMsg lasso_login_build_response_msg
#define LassoLogin_dump lasso_login_dump
#define LassoLogin_initAuthnRequest lasso_login_init_authn_request
#define LassoLogin_initRequest lasso_login_init_request
#define LassoLogin_initIdpInitiatedAuthnRequest lasso_login_init_idp_initiated_authn_request
#define LassoLogin_mustAskForConsent lasso_login_must_ask_for_consent
#define LassoLogin_mustAuthenticate lasso_login_must_authenticate
#define LassoLogin_processAuthnRequestMsg lasso_login_process_authn_request_msg
#define LassoLogin_processAuthnResponseMsg lasso_login_process_authn_response_msg
#define LassoLogin_processRequestMsg lasso_login_process_request_msg
#define LassoLogin_processResponseMsg lasso_login_process_response_msg
#define LassoLogin_setEncryptedResourceId lasso_login_set_encryptedResourceId 
#define LassoLogin_setResourceId lasso_login_set_resourceId
#define LassoLogin_validateRequestMsg lasso_login_validate_request_msg


static int _wrap_propset_LassoLogout(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLogout(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLogout(zend_property_reference *property_reference);
static int _propget_LassoLogout(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from Profile */

/* identity */
#define LassoLogout_get_identity(self) lasso_profile_get_identity(LASSO_PROFILE(self))
#define LassoLogout_identity_get(self) lasso_profile_get_identity(LASSO_PROFILE(self))
#define LassoLogout_set_identity(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->identity, (value))
#define LassoLogout_identity_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->identity, (value))

/* isIdentityDirty */
#define LassoLogout_get_isIdentityDirty(self) lasso_profile_is_identity_dirty(LASSO_PROFILE(self))
#define LassoLogout_isIdentityDirty_get(self) lasso_profile_is_identity_dirty(LASSO_PROFILE(self))

/* isSessionDirty */
#define LassoLogout_get_isSessionDirty(self) lasso_profile_is_session_dirty(LASSO_PROFILE(self))
#define LassoLogout_isSessionDirty_get(self) lasso_profile_is_session_dirty(LASSO_PROFILE(self))

/* msgBody */
#define LassoLogout_get_msgBody(self) LASSO_PROFILE(self)->msg_body
#define LassoLogout_msgBody_get(self) LASSO_PROFILE(self)->msg_body

/* msgRelayState */
#define LassoLogout_get_msgRelayState(self) LASSO_PROFILE(self)->msg_relayState
#define LassoLogout_msgRelayState_get(self) LASSO_PROFILE(self)->msg_relayState

/* msgUrl */
#define LassoLogout_get_msgUrl(self) LASSO_PROFILE(self)->msg_url
#define LassoLogout_msgUrl_get(self) LASSO_PROFILE(self)->msg_url

/* nameIdentifier */
#define LassoLogout_get_nameIdentifier(self) get_node(LASSO_PROFILE(self)->nameIdentifier)
#define LassoLogout_nameIdentifier_get(self) get_node(LASSO_PROFILE(self)->nameIdentifier)
#define LassoLogout_set_nameIdentifier(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->nameIdentifier, (value))
#define LassoLogout_nameIdentifier_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->nameIdentifier, (value))

/* remoteProviderId */
#define LassoLogout_get_remoteProviderId(self) LASSO_PROFILE(self)->remote_providerID
#define LassoLogout_remoteProviderId_get(self) LASSO_PROFILE(self)->remote_providerID
#define LassoLogout_set_remoteProviderId(self, value) set_string(&LASSO_PROFILE(self)->remote_providerID, (value))
#define LassoLogout_remoteProviderId_set(self, value) set_string(&LASSO_PROFILE(self)->remote_providerID, (value))

/* request */
#define LassoLogout_get_request(self) get_node(LASSO_PROFILE(self)->request)
#define LassoLogout_request_get(self) get_node(LASSO_PROFILE(self)->request)
#define LassoLogout_set_request(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->request, (value))
#define LassoLogout_request_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->request, (value))

/* response */
#define LassoLogout_get_response(self) get_node(LASSO_PROFILE(self)->response)
#define LassoLogout_response_get(self) get_node(LASSO_PROFILE(self)->response)
#define LassoLogout_set_response(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->response, (value))
#define LassoLogout_response_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->response, (value))

/* server */
#define LassoLogout_get_server(self) get_node(LASSO_PROFILE(self)->server)
#define LassoLogout_server_get(self) get_node(LASSO_PROFILE(self)->server)
#define LassoLogout_set_server(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->server, (value))
#define LassoLogout_server_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->server, (value))

/* session */
#define LassoLogout_get_session(self) lasso_profile_get_session(LASSO_PROFILE(self))
#define LassoLogout_session_get(self) lasso_profile_get_session(LASSO_PROFILE(self))
#define LassoLogout_set_session(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->session, (value))
#define LassoLogout_session_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->session, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoLogout lasso_logout_new
#define delete_LassoLogout(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoLogout_newFromDump lasso_logout_new_from_dump
#else
#define Logout_newFromDump lasso_logout_new_from_dump
#endif

/* Implementations of methods inherited from Profile */

int LassoLogout_setIdentityFromDump(LassoLogout *self, char *dump) {
	return lasso_profile_set_identity_from_dump(LASSO_PROFILE(self), dump);
}

int LassoLogout_setSessionFromDump(LassoLogout *self, char *dump) {
	return lasso_profile_set_session_from_dump(LASSO_PROFILE(self), dump);
}

/* Methods implementations */

#define LassoLogout_buildRequestMsg lasso_logout_build_request_msg
#define LassoLogout_buildResponseMsg lasso_logout_build_response_msg
#define LassoLogout_dump lasso_logout_dump
#define LassoLogout_getNextProviderId lasso_logout_get_next_providerID
#define LassoLogout_initRequest lasso_logout_init_request
#define LassoLogout_processRequestMsg lasso_logout_process_request_msg
#define LassoLogout_processResponseMsg lasso_logout_process_response_msg
#define LassoLogout_resetProviderIdIndex lasso_logout_reset_providerID_index
#define LassoLogout_validateRequest lasso_logout_validate_request


static int _wrap_propset_LassoLecp(zend_property_reference *property_reference, pval *value);
static int _propset_LassoLecp(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoLecp(zend_property_reference *property_reference);
static int _propget_LassoLecp(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from Profile */

/* identity */
#define LassoLecp_get_identity(self) lasso_profile_get_identity(LASSO_PROFILE(self))
#define LassoLecp_identity_get(self) lasso_profile_get_identity(LASSO_PROFILE(self))
#define LassoLecp_set_identity(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->identity, (value))
#define LassoLecp_identity_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->identity, (value))

/* isIdentityDirty */
#define LassoLecp_get_isIdentityDirty(self) lasso_profile_is_identity_dirty(LASSO_PROFILE(self))
#define LassoLecp_isIdentityDirty_get(self) lasso_profile_is_identity_dirty(LASSO_PROFILE(self))

/* isSessionDirty */
#define LassoLecp_get_isSessionDirty(self) lasso_profile_is_session_dirty(LASSO_PROFILE(self))
#define LassoLecp_isSessionDirty_get(self) lasso_profile_is_session_dirty(LASSO_PROFILE(self))

/* msgBody */
#define LassoLecp_get_msgBody(self) LASSO_PROFILE(self)->msg_body
#define LassoLecp_msgBody_get(self) LASSO_PROFILE(self)->msg_body

/* msgRelayState */
#define LassoLecp_get_msgRelayState(self) LASSO_PROFILE(self)->msg_relayState
#define LassoLecp_msgRelayState_get(self) LASSO_PROFILE(self)->msg_relayState

/* msgUrl */
#define LassoLecp_get_msgUrl(self) LASSO_PROFILE(self)->msg_url
#define LassoLecp_msgUrl_get(self) LASSO_PROFILE(self)->msg_url

/* nameIdentifier */
#define LassoLecp_get_nameIdentifier(self) get_node(LASSO_PROFILE(self)->nameIdentifier)
#define LassoLecp_nameIdentifier_get(self) get_node(LASSO_PROFILE(self)->nameIdentifier)
#define LassoLecp_set_nameIdentifier(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->nameIdentifier, (value))
#define LassoLecp_nameIdentifier_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->nameIdentifier, (value))

/* remoteProviderId */
#define LassoLecp_get_remoteProviderId(self) LASSO_PROFILE(self)->remote_providerID
#define LassoLecp_remoteProviderId_get(self) LASSO_PROFILE(self)->remote_providerID
#define LassoLecp_set_remoteProviderId(self, value) set_string(&LASSO_PROFILE(self)->remote_providerID, (value))
#define LassoLecp_remoteProviderId_set(self, value) set_string(&LASSO_PROFILE(self)->remote_providerID, (value))

/* request */
#define LassoLecp_get_request(self) get_node(LASSO_PROFILE(self)->request)
#define LassoLecp_request_get(self) get_node(LASSO_PROFILE(self)->request)
#define LassoLecp_set_request(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->request, (value))
#define LassoLecp_request_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->request, (value))

/* response */
#define LassoLecp_get_response(self) get_node(LASSO_PROFILE(self)->response)
#define LassoLecp_response_get(self) get_node(LASSO_PROFILE(self)->response)
#define LassoLecp_set_response(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->response, (value))
#define LassoLecp_response_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->response, (value))

/* server */
#define LassoLecp_get_server(self) get_node(LASSO_PROFILE(self)->server)
#define LassoLecp_server_get(self) get_node(LASSO_PROFILE(self)->server)
#define LassoLecp_set_server(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->server, (value))
#define LassoLecp_server_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->server, (value))

/* session */
#define LassoLecp_get_session(self) lasso_profile_get_session(LASSO_PROFILE(self))
#define LassoLecp_session_get(self) lasso_profile_get_session(LASSO_PROFILE(self))
#define LassoLecp_set_session(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->session, (value))
#define LassoLecp_session_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->session, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoLecp lasso_lecp_new
#define delete_LassoLecp(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from Profile */

int LassoLecp_setIdentityFromDump(LassoLecp *self, char *dump) {
	return lasso_profile_set_identity_from_dump(LASSO_PROFILE(self), dump);
}

int LassoLecp_setSessionFromDump(LassoLecp *self, char *dump) {
	return lasso_profile_set_session_from_dump(LASSO_PROFILE(self), dump);
}

/* Implementations of methods inherited from Login */

int LassoLecp_buildAssertion(LassoLecp *self, char *authenticationMethod,
		char *authenticationInstant, char *reauthenticateOnOrAfter, char *notBefore,
		char *notOnOrAfter) {
	return lasso_login_build_assertion(LASSO_LOGIN(self), authenticationMethod,
			authenticationInstant, reauthenticateOnOrAfter, notBefore, notOnOrAfter);
}

#ifdef LASSO_WSF_ENABLED
int LassoLecp_setEncryptedResourceId(LassoLecp *self,
		LassoDiscoEncryptedResourceID *encryptedResourceId) {
	return lasso_login_set_encryptedResourceId(LASSO_LOGIN(self), encryptedResourceId);
}
#endif

int LassoLecp_setResourceId(LassoLecp *self, char *content) {
	return lasso_login_set_resourceId(LASSO_LOGIN(self), content);
}

int LassoLecp_validateRequestMsg(LassoLecp *self, gboolean authenticationResult,
		gboolean isConsentObtained) {
	return lasso_login_validate_request_msg(LASSO_LOGIN(self), authenticationResult,
			isConsentObtained);
}

/* Methods implementations */

#define LassoLecp_buildAuthnRequestEnvelopeMsg lasso_lecp_build_authn_request_envelope_msg
#define LassoLecp_buildAuthnRequestMsg lasso_lecp_build_authn_request_msg
#define LassoLecp_buildAuthnResponseEnvelopeMsg lasso_lecp_build_authn_response_envelope_msg
#define LassoLecp_buildAuthnResponseMsg lasso_lecp_build_authn_response_msg
#define LassoLecp_initAuthnRequest lasso_lecp_init_authn_request
#define LassoLecp_processAuthnRequestEnvelopeMsg lasso_lecp_process_authn_request_envelope_msg
#define LassoLecp_processAuthnRequestMsg lasso_lecp_process_authn_request_msg
#define LassoLecp_processAuthnResponseEnvelopeMsg lasso_lecp_process_authn_response_envelope_msg


static int _wrap_propset_LassoNameIdentifierMapping(zend_property_reference *property_reference, pval *value);
static int _propset_LassoNameIdentifierMapping(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoNameIdentifierMapping(zend_property_reference *property_reference);
static int _propget_LassoNameIdentifierMapping(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from Profile */

/* identity */
#define LassoNameIdentifierMapping_get_identity(self) lasso_profile_get_identity(LASSO_PROFILE(self))
#define LassoNameIdentifierMapping_identity_get(self) lasso_profile_get_identity(LASSO_PROFILE(self))
#define LassoNameIdentifierMapping_set_identity(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->identity, (value))
#define LassoNameIdentifierMapping_identity_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->identity, (value))

/* isIdentityDirty */
#define LassoNameIdentifierMapping_get_isIdentityDirty(self) lasso_profile_is_identity_dirty(LASSO_PROFILE(self))
#define LassoNameIdentifierMapping_isIdentityDirty_get(self) lasso_profile_is_identity_dirty(LASSO_PROFILE(self))

/* isSessionDirty */
#define LassoNameIdentifierMapping_get_isSessionDirty(self) lasso_profile_is_session_dirty(LASSO_PROFILE(self))
#define LassoNameIdentifierMapping_isSessionDirty_get(self) lasso_profile_is_session_dirty(LASSO_PROFILE(self))

/* msgBody */
#define LassoNameIdentifierMapping_get_msgBody(self) LASSO_PROFILE(self)->msg_body
#define LassoNameIdentifierMapping_msgBody_get(self) LASSO_PROFILE(self)->msg_body

/* msgRelayState */
#define LassoNameIdentifierMapping_get_msgRelayState(self) LASSO_PROFILE(self)->msg_relayState
#define LassoNameIdentifierMapping_msgRelayState_get(self) LASSO_PROFILE(self)->msg_relayState

/* msgUrl */
#define LassoNameIdentifierMapping_get_msgUrl(self) LASSO_PROFILE(self)->msg_url
#define LassoNameIdentifierMapping_msgUrl_get(self) LASSO_PROFILE(self)->msg_url

/* nameIdentifier */
#define LassoNameIdentifierMapping_get_nameIdentifier(self) get_node(LASSO_PROFILE(self)->nameIdentifier)
#define LassoNameIdentifierMapping_nameIdentifier_get(self) get_node(LASSO_PROFILE(self)->nameIdentifier)
#define LassoNameIdentifierMapping_set_nameIdentifier(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->nameIdentifier, (value))
#define LassoNameIdentifierMapping_nameIdentifier_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->nameIdentifier, (value))

/* remoteProviderId */
#define LassoNameIdentifierMapping_get_remoteProviderId(self) LASSO_PROFILE(self)->remote_providerID
#define LassoNameIdentifierMapping_remoteProviderId_get(self) LASSO_PROFILE(self)->remote_providerID
#define LassoNameIdentifierMapping_set_remoteProviderId(self, value) set_string(&LASSO_PROFILE(self)->remote_providerID, (value))
#define LassoNameIdentifierMapping_remoteProviderId_set(self, value) set_string(&LASSO_PROFILE(self)->remote_providerID, (value))

/* request */
#define LassoNameIdentifierMapping_get_request(self) get_node(LASSO_PROFILE(self)->request)
#define LassoNameIdentifierMapping_request_get(self) get_node(LASSO_PROFILE(self)->request)
#define LassoNameIdentifierMapping_set_request(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->request, (value))
#define LassoNameIdentifierMapping_request_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->request, (value))

/* response */
#define LassoNameIdentifierMapping_get_response(self) get_node(LASSO_PROFILE(self)->response)
#define LassoNameIdentifierMapping_response_get(self) get_node(LASSO_PROFILE(self)->response)
#define LassoNameIdentifierMapping_set_response(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->response, (value))
#define LassoNameIdentifierMapping_response_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->response, (value))

/* server */
#define LassoNameIdentifierMapping_get_server(self) get_node(LASSO_PROFILE(self)->server)
#define LassoNameIdentifierMapping_server_get(self) get_node(LASSO_PROFILE(self)->server)
#define LassoNameIdentifierMapping_set_server(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->server, (value))
#define LassoNameIdentifierMapping_server_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->server, (value))

/* session */
#define LassoNameIdentifierMapping_get_session(self) lasso_profile_get_session(LASSO_PROFILE(self))
#define LassoNameIdentifierMapping_session_get(self) lasso_profile_get_session(LASSO_PROFILE(self))
#define LassoNameIdentifierMapping_set_session(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->session, (value))
#define LassoNameIdentifierMapping_session_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->session, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoNameIdentifierMapping lasso_name_identifier_mapping_new
#define delete_LassoNameIdentifierMapping(self) lasso_node_destroy(LASSO_NODE(self))

/* Implementations of methods inherited from Profile */

int LassoNameIdentifierMapping_setIdentityFromDump(LassoNameIdentifierMapping *self, char *dump) {
	return lasso_profile_set_identity_from_dump(LASSO_PROFILE(self), dump);
}

int LassoNameIdentifierMapping_setSessionFromDump(LassoNameIdentifierMapping *self, char *dump) {
	return lasso_profile_set_session_from_dump(LASSO_PROFILE(self), dump);
}

/* Methods implementations */

#define LassoNameIdentifierMapping_buildRequestMsg lasso_name_identifier_mapping_build_request_msg
#define LassoNameIdentifierMapping_buildResponseMsg lasso_name_identifier_mapping_build_response_msg
#define LassoNameIdentifierMapping_initRequest lasso_name_identifier_mapping_init_request
#define LassoNameIdentifierMapping_processRequestMsg lasso_name_identifier_mapping_process_request_msg
#define LassoNameIdentifierMapping_processResponseMsg lasso_name_identifier_mapping_process_response_msg
#define LassoNameIdentifierMapping_validateRequest lasso_name_identifier_mapping_validate_request


static int _wrap_propset_LassoNameRegistration(zend_property_reference *property_reference, pval *value);
static int _propset_LassoNameRegistration(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LassoNameRegistration(zend_property_reference *property_reference);
static int _propget_LassoNameRegistration(zend_property_reference *property_reference, pval *value);


/* Implementations of attributes inherited from Profile */

/* identity */
#define LassoNameRegistration_get_identity(self) lasso_profile_get_identity(LASSO_PROFILE(self))
#define LassoNameRegistration_identity_get(self) lasso_profile_get_identity(LASSO_PROFILE(self))
#define LassoNameRegistration_set_identity(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->identity, (value))
#define LassoNameRegistration_identity_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->identity, (value))

/* isIdentityDirty */
#define LassoNameRegistration_get_isIdentityDirty(self) lasso_profile_is_identity_dirty(LASSO_PROFILE(self))
#define LassoNameRegistration_isIdentityDirty_get(self) lasso_profile_is_identity_dirty(LASSO_PROFILE(self))

/* isSessionDirty */
#define LassoNameRegistration_get_isSessionDirty(self) lasso_profile_is_session_dirty(LASSO_PROFILE(self))
#define LassoNameRegistration_isSessionDirty_get(self) lasso_profile_is_session_dirty(LASSO_PROFILE(self))

/* msgBody */
#define LassoNameRegistration_get_msgBody(self) LASSO_PROFILE(self)->msg_body
#define LassoNameRegistration_msgBody_get(self) LASSO_PROFILE(self)->msg_body

/* msgRelayState */
#define LassoNameRegistration_get_msgRelayState(self) LASSO_PROFILE(self)->msg_relayState
#define LassoNameRegistration_msgRelayState_get(self) LASSO_PROFILE(self)->msg_relayState

/* msgUrl */
#define LassoNameRegistration_get_msgUrl(self) LASSO_PROFILE(self)->msg_url
#define LassoNameRegistration_msgUrl_get(self) LASSO_PROFILE(self)->msg_url

/* nameIdentifier */
#define LassoNameRegistration_get_nameIdentifier(self) get_node(LASSO_PROFILE(self)->nameIdentifier)
#define LassoNameRegistration_nameIdentifier_get(self) get_node(LASSO_PROFILE(self)->nameIdentifier)
#define LassoNameRegistration_set_nameIdentifier(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->nameIdentifier, (value))
#define LassoNameRegistration_nameIdentifier_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->nameIdentifier, (value))

/* remoteProviderId */
#define LassoNameRegistration_get_remoteProviderId(self) LASSO_PROFILE(self)->remote_providerID
#define LassoNameRegistration_remoteProviderId_get(self) LASSO_PROFILE(self)->remote_providerID
#define LassoNameRegistration_set_remoteProviderId(self, value) set_string(&LASSO_PROFILE(self)->remote_providerID, (value))
#define LassoNameRegistration_remoteProviderId_set(self, value) set_string(&LASSO_PROFILE(self)->remote_providerID, (value))

/* request */
#define LassoNameRegistration_get_request(self) get_node(LASSO_PROFILE(self)->request)
#define LassoNameRegistration_request_get(self) get_node(LASSO_PROFILE(self)->request)
#define LassoNameRegistration_set_request(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->request, (value))
#define LassoNameRegistration_request_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->request, (value))

/* response */
#define LassoNameRegistration_get_response(self) get_node(LASSO_PROFILE(self)->response)
#define LassoNameRegistration_response_get(self) get_node(LASSO_PROFILE(self)->response)
#define LassoNameRegistration_set_response(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->response, (value))
#define LassoNameRegistration_response_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->response, (value))

/* server */
#define LassoNameRegistration_get_server(self) get_node(LASSO_PROFILE(self)->server)
#define LassoNameRegistration_server_get(self) get_node(LASSO_PROFILE(self)->server)
#define LassoNameRegistration_set_server(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->server, (value))
#define LassoNameRegistration_server_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->server, (value))

/* session */
#define LassoNameRegistration_get_session(self) lasso_profile_get_session(LASSO_PROFILE(self))
#define LassoNameRegistration_session_get(self) lasso_profile_get_session(LASSO_PROFILE(self))
#define LassoNameRegistration_set_session(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->session, (value))
#define LassoNameRegistration_session_set(self, value) set_node((gpointer *) &LASSO_PROFILE(self)->session, (value))

/* Attributes implementations */

/* oldNameIdentifier */
#define LassoNameRegistration_get_oldNameIdentifier(self) get_node((self)->oldNameIdentifier)
#define LassoNameRegistration_oldNameIdentifier_get(self) get_node((self)->oldNameIdentifier)
#define LassoNameRegistration_set_oldNameIdentifier(self, value) set_node((gpointer *) &(self)->oldNameIdentifier, (value))
#define LassoNameRegistration_oldNameIdentifier_set(self, value) set_node((gpointer *) &(self)->oldNameIdentifier, (value))

/* Constructors, destructors & static methods implementations */

#define new_LassoNameRegistration lasso_name_registration_new
#define delete_LassoNameRegistration(self) lasso_node_destroy(LASSO_NODE(self))
#ifdef PHP_VERSION
#define LassoNameRegistration_newFromDump lasso_name_registration_new_from_dump
#else
#define NameRegistration_newFromDump lasso_name_registration_new_from_dump
#endif

/* Implementations of methods inherited from Profile */

int LassoNameRegistration_setIdentityFromDump(LassoNameRegistration *self, char *dump) {
	return lasso_profile_set_identity_from_dump(LASSO_PROFILE(self), dump);
}

int LassoNameRegistration_setSessionFromDump(LassoNameRegistration *self, char *dump) {
	return lasso_profile_set_session_from_dump(LASSO_PROFILE(self), dump);
}

/* Methods implementations */

#define LassoNameRegistration_buildRequestMsg lasso_name_registration_build_request_msg
#define LassoNameRegistration_buildResponseMsg lasso_name_registration_build_response_msg
#define LassoNameRegistration_dump lasso_name_registration_dump
#define LassoNameRegistration_initRequest lasso_name_registration_init_request
#define LassoNameRegistration_processRequestMsg lasso_name_registration_process_request_msg
#define LassoNameRegistration_processResponseMsg lasso_name_registration_process_response_msg
#define LassoNameRegistration_validateRequest lasso_name_registration_validate_request


/* class entry subsection */
/* Function entries for LassoNode */
static zend_function_entry LassoNode_functions[] = {
	ZEND_NAMED_FE(lassonode,
		_wrap_new_LassoNode, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoNode_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoNodeList */
static zend_function_entry LassoNodeList_functions[] = {
	ZEND_NAMED_FE(lassonodelist,
		_wrap_new_LassoNodeList, NULL)
	ZEND_NAMED_FE(append,
		_wrap_LassoNodeList_append, NULL)
	ZEND_NAMED_FE(cast,
		_wrap_LassoNodeList_cast, NULL)
	ZEND_NAMED_FE(frompointer,
		_wrap_LassoNodeList_frompointer, NULL)
	ZEND_NAMED_FE(getitem,
		_wrap_LassoNodeList_getItem, NULL)
	ZEND_NAMED_FE(length,
		_wrap_LassoNodeList_length, NULL)
	ZEND_NAMED_FE(setitem,
		_wrap_LassoNodeList_setItem, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoStringList */
static zend_function_entry LassoStringList_functions[] = {
	ZEND_NAMED_FE(lassostringlist,
		_wrap_new_LassoStringList, NULL)
	ZEND_NAMED_FE(append,
		_wrap_LassoStringList_append, NULL)
	ZEND_NAMED_FE(cast,
		_wrap_LassoStringList_cast, NULL)
	ZEND_NAMED_FE(frompointer,
		_wrap_LassoStringList_frompointer, NULL)
	ZEND_NAMED_FE(getitem,
		_wrap_LassoStringList_getItem, NULL)
	ZEND_NAMED_FE(length,
		_wrap_LassoStringList_length, NULL)
	ZEND_NAMED_FE(setitem,
		_wrap_LassoStringList_setItem, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlAdvice */
static zend_function_entry LassoSamlAdvice_functions[] = {
	ZEND_NAMED_FE(lassosamladvice,
		_wrap_new_LassoSamlAdvice, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlAdvice_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlAssertion */
static zend_function_entry LassoSamlAssertion_functions[] = {
	ZEND_NAMED_FE(lassosamlassertion,
		_wrap_new_LassoSamlAssertion, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlAssertion_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlAttribute */
static zend_function_entry LassoSamlAttribute_functions[] = {
	ZEND_NAMED_FE(lassosamlattribute,
		_wrap_new_LassoSamlAttribute, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlAttribute_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlAttributeDesignator */
static zend_function_entry LassoSamlAttributeDesignator_functions[] = {
	ZEND_NAMED_FE(lassosamlattributedesignator,
		_wrap_new_LassoSamlAttributeDesignator, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlAttributeDesignator_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlAttributeStatement */
static zend_function_entry LassoSamlAttributeStatement_functions[] = {
	ZEND_NAMED_FE(lassosamlattributestatement,
		_wrap_new_LassoSamlAttributeStatement, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlAttributeStatement_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlAttributeValue */
static zend_function_entry LassoSamlAttributeValue_functions[] = {
	ZEND_NAMED_FE(lassosamlattributevalue,
		_wrap_new_LassoSamlAttributeValue, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlAttributeValue_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlAudienceRestrictionCondition */
static zend_function_entry LassoSamlAudienceRestrictionCondition_functions[] = {
	ZEND_NAMED_FE(lassosamlaudiencerestrictioncondition,
		_wrap_new_LassoSamlAudienceRestrictionCondition, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlAudienceRestrictionCondition_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlAuthenticationStatement */
static zend_function_entry LassoSamlAuthenticationStatement_functions[] = {
	ZEND_NAMED_FE(lassosamlauthenticationstatement,
		_wrap_new_LassoSamlAuthenticationStatement, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlAuthenticationStatement_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlAuthorityBinding */
static zend_function_entry LassoSamlAuthorityBinding_functions[] = {
	ZEND_NAMED_FE(lassosamlauthoritybinding,
		_wrap_new_LassoSamlAuthorityBinding, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlAuthorityBinding_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlConditionAbstract */
static zend_function_entry LassoSamlConditionAbstract_functions[] = {
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlConditionAbstract_dump, NULL)
	ZEND_NAMED_FE(lassosamlconditionabstract,
		_wrap_new_LassoSamlConditionAbstract, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlConditions */
static zend_function_entry LassoSamlConditions_functions[] = {
	ZEND_NAMED_FE(lassosamlconditions,
		_wrap_new_LassoSamlConditions, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlConditions_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlNameIdentifier */
static zend_function_entry LassoSamlNameIdentifier_functions[] = {
	ZEND_NAMED_FE(lassosamlnameidentifier,
		_wrap_new_LassoSamlNameIdentifier, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlNameIdentifier_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlStatementAbstract */
static zend_function_entry LassoSamlStatementAbstract_functions[] = {
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlStatementAbstract_dump, NULL)
	ZEND_NAMED_FE(lassosamlstatementabstract,
		_wrap_new_LassoSamlStatementAbstract, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlSubject */
static zend_function_entry LassoSamlSubject_functions[] = {
	ZEND_NAMED_FE(lassosamlsubject,
		_wrap_new_LassoSamlSubject, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlSubject_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlSubjectConfirmation */
static zend_function_entry LassoSamlSubjectConfirmation_functions[] = {
	ZEND_NAMED_FE(lassosamlsubjectconfirmation,
		_wrap_new_LassoSamlSubjectConfirmation, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlSubjectConfirmation_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlSubjectLocality */
static zend_function_entry LassoSamlSubjectLocality_functions[] = {
	ZEND_NAMED_FE(lassosamlsubjectlocality,
		_wrap_new_LassoSamlSubjectLocality, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlSubjectLocality_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlSubjectStatement */
static zend_function_entry LassoSamlSubjectStatement_functions[] = {
	ZEND_NAMED_FE(lassosamlsubjectstatement,
		_wrap_new_LassoSamlSubjectStatement, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlSubjectStatement_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlSubjectStatementAbstract */
static zend_function_entry LassoSamlSubjectStatementAbstract_functions[] = {
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlSubjectStatementAbstract_dump, NULL)
	ZEND_NAMED_FE(lassosamlsubjectstatementabstract,
		_wrap_new_LassoSamlSubjectStatementAbstract, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlpRequest */
static zend_function_entry LassoSamlpRequest_functions[] = {
	ZEND_NAMED_FE(lassosamlprequest,
		_wrap_new_LassoSamlpRequest, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlpRequest_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlpRequestAbstract */
static zend_function_entry LassoSamlpRequestAbstract_functions[] = {
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlpRequestAbstract_dump, NULL)
	ZEND_NAMED_FE(lassosamlprequestabstract,
		_wrap_new_LassoSamlpRequestAbstract, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlpResponse */
static zend_function_entry LassoSamlpResponse_functions[] = {
	ZEND_NAMED_FE(lassosamlpresponse,
		_wrap_new_LassoSamlpResponse, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlpResponse_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlpResponseAbstract */
static zend_function_entry LassoSamlpResponseAbstract_functions[] = {
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlpResponseAbstract_dump, NULL)
	ZEND_NAMED_FE(lassosamlpresponseabstract,
		_wrap_new_LassoSamlpResponseAbstract, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlpStatus */
static zend_function_entry LassoSamlpStatus_functions[] = {
	ZEND_NAMED_FE(lassosamlpstatus,
		_wrap_new_LassoSamlpStatus, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlpStatus_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSamlpStatusCode */
static zend_function_entry LassoSamlpStatusCode_functions[] = {
	ZEND_NAMED_FE(lassosamlpstatuscode,
		_wrap_new_LassoSamlpStatusCode, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSamlpStatusCode_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLibAssertion */
static zend_function_entry LassoLibAssertion_functions[] = {
	ZEND_NAMED_FE(lassolibassertion,
		_wrap_new_LassoLibAssertion, NULL)
	ZEND_NAMED_FE(newfull,
		_wrap_LassoLibAssertion_newFull, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoLibAssertion_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLibAuthnRequest */
static zend_function_entry LassoLibAuthnRequest_functions[] = {
	ZEND_NAMED_FE(lassolibauthnrequest,
		_wrap_new_LassoLibAuthnRequest, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoLibAuthnRequest_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLibAuthnResponse */
static zend_function_entry LassoLibAuthnResponse_functions[] = {
	ZEND_NAMED_FE(lassolibauthnresponse,
		_wrap_new_LassoLibAuthnResponse, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoLibAuthnResponse_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLibFederationTerminationNotification */
static zend_function_entry LassoLibFederationTerminationNotification_functions[] = {
	ZEND_NAMED_FE(lassolibfederationterminationnotification,
		_wrap_new_LassoLibFederationTerminationNotification, NULL)
	ZEND_NAMED_FE(newfull,
		_wrap_LassoLibFederationTerminationNotification_newFull, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoLibFederationTerminationNotification_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLibLogoutRequest */
static zend_function_entry LassoLibLogoutRequest_functions[] = {
	ZEND_NAMED_FE(lassoliblogoutrequest,
		_wrap_new_LassoLibLogoutRequest, NULL)
	ZEND_NAMED_FE(newfull,
		_wrap_LassoLibLogoutRequest_newFull, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoLibLogoutRequest_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLibLogoutResponse */
static zend_function_entry LassoLibLogoutResponse_functions[] = {
	ZEND_NAMED_FE(lassoliblogoutresponse,
		_wrap_new_LassoLibLogoutResponse, NULL)
	ZEND_NAMED_FE(newfull,
		_wrap_LassoLibLogoutResponse_newFull, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoLibLogoutResponse_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLibRegisterNameIdentifierRequest */
static zend_function_entry LassoLibRegisterNameIdentifierRequest_functions[] = {
	ZEND_NAMED_FE(lassolibregisternameidentifierrequest,
		_wrap_new_LassoLibRegisterNameIdentifierRequest, NULL)
	ZEND_NAMED_FE(newfull,
		_wrap_LassoLibRegisterNameIdentifierRequest_newFull, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoLibRegisterNameIdentifierRequest_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLibRegisterNameIdentifierResponse */
static zend_function_entry LassoLibRegisterNameIdentifierResponse_functions[] = {
	ZEND_NAMED_FE(lassolibregisternameidentifierresponse,
		_wrap_new_LassoLibRegisterNameIdentifierResponse, NULL)
	ZEND_NAMED_FE(newfull,
		_wrap_LassoLibRegisterNameIdentifierResponse_newFull, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoLibRegisterNameIdentifierResponse_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLibRequestAuthnContext */
static zend_function_entry LassoLibRequestAuthnContext_functions[] = {
	ZEND_NAMED_FE(lassolibrequestauthncontext,
		_wrap_new_LassoLibRequestAuthnContext, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoLibRequestAuthnContext_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLibStatusResponse */
static zend_function_entry LassoLibStatusResponse_functions[] = {
	ZEND_NAMED_FE(lassolibstatusresponse,
		_wrap_new_LassoLibStatusResponse, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoLibStatusResponse_dump, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoProvider */
static zend_function_entry LassoProvider_functions[] = {
	ZEND_NAMED_FE(lassoprovider,
		_wrap_new_LassoProvider, NULL)
	ZEND_NAMED_FE(newfromdump,
		_wrap_LassoProvider_newFromDump, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoProvider_dump, NULL)
	ZEND_NAMED_FE(accepthttpmethod,
		_wrap_LassoProvider_acceptHttpMethod, NULL)
	ZEND_NAMED_FE(getassertionconsumerserviceurl,
		_wrap_LassoProvider_getAssertionConsumerServiceUrl, NULL)
	ZEND_NAMED_FE(getbase64succinctid,
		_wrap_LassoProvider_getBase64SuccinctId, NULL)
	ZEND_NAMED_FE(getorganization,
		_wrap_LassoProvider_getOrganization, NULL)
	ZEND_NAMED_FE(getfirsthttpmethod,
		_wrap_LassoProvider_getFirstHttpMethod, NULL)
	ZEND_NAMED_FE(getmetadataone,
		_wrap_LassoProvider_getMetadataOne, NULL)
	ZEND_NAMED_FE(hasprotocolprofile,
		_wrap_LassoProvider_hasProtocolProfile, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoServer */
static zend_function_entry LassoServer_functions[] = {
	ZEND_NAMED_FE(lassoserver,
		_wrap_new_LassoServer, NULL)
	ZEND_NAMED_FE(newfromdump,
		_wrap_LassoServer_newFromDump, NULL)
	ZEND_NAMED_FE(accepthttpmethod,
		_wrap_LassoServer_acceptHttpMethod, NULL)
	ZEND_NAMED_FE(getassertionconsumerserviceurl,
		_wrap_LassoServer_getAssertionConsumerServiceUrl, NULL)
	ZEND_NAMED_FE(getbase64succinctid,
		_wrap_LassoServer_getBase64SuccinctId, NULL)
	ZEND_NAMED_FE(getorganization,
		_wrap_LassoServer_getOrganization, NULL)
	ZEND_NAMED_FE(getfirsthttpmethod,
		_wrap_LassoServer_getFirstHttpMethod, NULL)
	ZEND_NAMED_FE(getmetadataone,
		_wrap_LassoServer_getMetadataOne, NULL)
	ZEND_NAMED_FE(hasprotocolprofile,
		_wrap_LassoServer_hasProtocolProfile, NULL)
	ZEND_NAMED_FE(addprovider,
		_wrap_LassoServer_addProvider, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoServer_dump, NULL)
	ZEND_NAMED_FE(getprovider,
		_wrap_LassoServer_getProvider, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoFederation */
static zend_function_entry LassoFederation_functions[] = {
	ZEND_NAMED_FE(lassofederation,
		_wrap_new_LassoFederation, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoFederation_dump, NULL)
	ZEND_NAMED_FE(buildlocalnameidentifier,
		_wrap_LassoFederation_buildLocalNameIdentifier, NULL)
	ZEND_NAMED_FE(verifynameidentifier,
		_wrap_LassoFederation_verifyNameIdentifier, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoIdentity */
static zend_function_entry LassoIdentity_functions[] = {
	ZEND_NAMED_FE(lassoidentity,
		_wrap_new_LassoIdentity, NULL)
	ZEND_NAMED_FE(newfromdump,
		_wrap_LassoIdentity_newFromDump, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoIdentity_dump, NULL)
	ZEND_NAMED_FE(getfederation,
		_wrap_LassoIdentity_getFederation, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoSession */
static zend_function_entry LassoSession_functions[] = {
	ZEND_NAMED_FE(lassosession,
		_wrap_new_LassoSession, NULL)
	ZEND_NAMED_FE(newfromdump,
		_wrap_LassoSession_newFromDump, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoSession_dump, NULL)
	ZEND_NAMED_FE(getassertions,
		_wrap_LassoSession_getAssertions, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoDefederation */
static zend_function_entry LassoDefederation_functions[] = {
	ZEND_NAMED_FE(lassodefederation,
		_wrap_new_LassoDefederation, NULL)
	ZEND_NAMED_FE(setidentityfromdump,
		_wrap_LassoDefederation_setIdentityFromDump, NULL)
	ZEND_NAMED_FE(setsessionfromdump,
		_wrap_LassoDefederation_setSessionFromDump, NULL)
	ZEND_NAMED_FE(buildnotificationmsg,
		_wrap_LassoDefederation_buildNotificationMsg, NULL)
	ZEND_NAMED_FE(initnotification,
		_wrap_LassoDefederation_initNotification, NULL)
	ZEND_NAMED_FE(processnotificationmsg,
		_wrap_LassoDefederation_processNotificationMsg, NULL)
	ZEND_NAMED_FE(validatenotification,
		_wrap_LassoDefederation_validateNotification, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLogin */
static zend_function_entry LassoLogin_functions[] = {
	ZEND_NAMED_FE(lassologin,
		_wrap_new_LassoLogin, NULL)
	ZEND_NAMED_FE(newfromdump,
		_wrap_LassoLogin_newFromDump, NULL)
	ZEND_NAMED_FE(setidentityfromdump,
		_wrap_LassoLogin_setIdentityFromDump, NULL)
	ZEND_NAMED_FE(setsessionfromdump,
		_wrap_LassoLogin_setSessionFromDump, NULL)
	ZEND_NAMED_FE(acceptsso,
		_wrap_LassoLogin_acceptSso, NULL)
	ZEND_NAMED_FE(buildartifactmsg,
		_wrap_LassoLogin_buildArtifactMsg, NULL)
	ZEND_NAMED_FE(buildassertion,
		_wrap_LassoLogin_buildAssertion, NULL)
	ZEND_NAMED_FE(buildauthnrequestmsg,
		_wrap_LassoLogin_buildAuthnRequestMsg, NULL)
	ZEND_NAMED_FE(buildauthnresponsemsg,
		_wrap_LassoLogin_buildAuthnResponseMsg, NULL)
	ZEND_NAMED_FE(buildrequestmsg,
		_wrap_LassoLogin_buildRequestMsg, NULL)
	ZEND_NAMED_FE(buildresponsemsg,
		_wrap_LassoLogin_buildResponseMsg, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoLogin_dump, NULL)
	ZEND_NAMED_FE(initauthnrequest,
		_wrap_LassoLogin_initAuthnRequest, NULL)
	ZEND_NAMED_FE(initrequest,
		_wrap_LassoLogin_initRequest, NULL)
	ZEND_NAMED_FE(initidpinitiatedauthnrequest,
		_wrap_LassoLogin_initIdpInitiatedAuthnRequest, NULL)
	ZEND_NAMED_FE(mustaskforconsent,
		_wrap_LassoLogin_mustAskForConsent, NULL)
	ZEND_NAMED_FE(mustauthenticate,
		_wrap_LassoLogin_mustAuthenticate, NULL)
	ZEND_NAMED_FE(processauthnrequestmsg,
		_wrap_LassoLogin_processAuthnRequestMsg, NULL)
	ZEND_NAMED_FE(processauthnresponsemsg,
		_wrap_LassoLogin_processAuthnResponseMsg, NULL)
	ZEND_NAMED_FE(processrequestmsg,
		_wrap_LassoLogin_processRequestMsg, NULL)
	ZEND_NAMED_FE(processresponsemsg,
		_wrap_LassoLogin_processResponseMsg, NULL)
	ZEND_NAMED_FE(setresourceid,
		_wrap_LassoLogin_setResourceId, NULL)
	ZEND_NAMED_FE(validaterequestmsg,
		_wrap_LassoLogin_validateRequestMsg, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLogout */
static zend_function_entry LassoLogout_functions[] = {
	ZEND_NAMED_FE(lassologout,
		_wrap_new_LassoLogout, NULL)
	ZEND_NAMED_FE(newfromdump,
		_wrap_LassoLogout_newFromDump, NULL)
	ZEND_NAMED_FE(setidentityfromdump,
		_wrap_LassoLogout_setIdentityFromDump, NULL)
	ZEND_NAMED_FE(setsessionfromdump,
		_wrap_LassoLogout_setSessionFromDump, NULL)
	ZEND_NAMED_FE(buildrequestmsg,
		_wrap_LassoLogout_buildRequestMsg, NULL)
	ZEND_NAMED_FE(buildresponsemsg,
		_wrap_LassoLogout_buildResponseMsg, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoLogout_dump, NULL)
	ZEND_NAMED_FE(getnextproviderid,
		_wrap_LassoLogout_getNextProviderId, NULL)
	ZEND_NAMED_FE(initrequest,
		_wrap_LassoLogout_initRequest, NULL)
	ZEND_NAMED_FE(processrequestmsg,
		_wrap_LassoLogout_processRequestMsg, NULL)
	ZEND_NAMED_FE(processresponsemsg,
		_wrap_LassoLogout_processResponseMsg, NULL)
	ZEND_NAMED_FE(resetprovideridindex,
		_wrap_LassoLogout_resetProviderIdIndex, NULL)
	ZEND_NAMED_FE(validaterequest,
		_wrap_LassoLogout_validateRequest, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoLecp */
static zend_function_entry LassoLecp_functions[] = {
	ZEND_NAMED_FE(lassolecp,
		_wrap_new_LassoLecp, NULL)
	ZEND_NAMED_FE(setidentityfromdump,
		_wrap_LassoLecp_setIdentityFromDump, NULL)
	ZEND_NAMED_FE(setsessionfromdump,
		_wrap_LassoLecp_setSessionFromDump, NULL)
	ZEND_NAMED_FE(buildassertion,
		_wrap_LassoLecp_buildAssertion, NULL)
	ZEND_NAMED_FE(setresourceid,
		_wrap_LassoLecp_setResourceId, NULL)
	ZEND_NAMED_FE(validaterequestmsg,
		_wrap_LassoLecp_validateRequestMsg, NULL)
	ZEND_NAMED_FE(buildauthnrequestenvelopemsg,
		_wrap_LassoLecp_buildAuthnRequestEnvelopeMsg, NULL)
	ZEND_NAMED_FE(buildauthnrequestmsg,
		_wrap_LassoLecp_buildAuthnRequestMsg, NULL)
	ZEND_NAMED_FE(buildauthnresponseenvelopemsg,
		_wrap_LassoLecp_buildAuthnResponseEnvelopeMsg, NULL)
	ZEND_NAMED_FE(buildauthnresponsemsg,
		_wrap_LassoLecp_buildAuthnResponseMsg, NULL)
	ZEND_NAMED_FE(initauthnrequest,
		_wrap_LassoLecp_initAuthnRequest, NULL)
	ZEND_NAMED_FE(processauthnrequestenvelopemsg,
		_wrap_LassoLecp_processAuthnRequestEnvelopeMsg, NULL)
	ZEND_NAMED_FE(processauthnrequestmsg,
		_wrap_LassoLecp_processAuthnRequestMsg, NULL)
	ZEND_NAMED_FE(processauthnresponseenvelopemsg,
		_wrap_LassoLecp_processAuthnResponseEnvelopeMsg, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoNameIdentifierMapping */
static zend_function_entry LassoNameIdentifierMapping_functions[] = {
	ZEND_NAMED_FE(lassonameidentifiermapping,
		_wrap_new_LassoNameIdentifierMapping, NULL)
	ZEND_NAMED_FE(setidentityfromdump,
		_wrap_LassoNameIdentifierMapping_setIdentityFromDump, NULL)
	ZEND_NAMED_FE(setsessionfromdump,
		_wrap_LassoNameIdentifierMapping_setSessionFromDump, NULL)
	ZEND_NAMED_FE(buildrequestmsg,
		_wrap_LassoNameIdentifierMapping_buildRequestMsg, NULL)
	ZEND_NAMED_FE(buildresponsemsg,
		_wrap_LassoNameIdentifierMapping_buildResponseMsg, NULL)
	ZEND_NAMED_FE(initrequest,
		_wrap_LassoNameIdentifierMapping_initRequest, NULL)
	ZEND_NAMED_FE(processrequestmsg,
		_wrap_LassoNameIdentifierMapping_processRequestMsg, NULL)
	ZEND_NAMED_FE(processresponsemsg,
		_wrap_LassoNameIdentifierMapping_processResponseMsg, NULL)
	ZEND_NAMED_FE(validaterequest,
		_wrap_LassoNameIdentifierMapping_validateRequest, NULL)
	{ NULL, NULL, NULL}
};
/* Function entries for LassoNameRegistration */
static zend_function_entry LassoNameRegistration_functions[] = {
	ZEND_NAMED_FE(lassonameregistration,
		_wrap_new_LassoNameRegistration, NULL)
	ZEND_NAMED_FE(newfromdump,
		_wrap_LassoNameRegistration_newFromDump, NULL)
	ZEND_NAMED_FE(setidentityfromdump,
		_wrap_LassoNameRegistration_setIdentityFromDump, NULL)
	ZEND_NAMED_FE(setsessionfromdump,
		_wrap_LassoNameRegistration_setSessionFromDump, NULL)
	ZEND_NAMED_FE(buildrequestmsg,
		_wrap_LassoNameRegistration_buildRequestMsg, NULL)
	ZEND_NAMED_FE(buildresponsemsg,
		_wrap_LassoNameRegistration_buildResponseMsg, NULL)
	ZEND_NAMED_FE(dump,
		_wrap_LassoNameRegistration_dump, NULL)
	ZEND_NAMED_FE(initrequest,
		_wrap_LassoNameRegistration_initRequest, NULL)
	ZEND_NAMED_FE(processrequestmsg,
		_wrap_LassoNameRegistration_processRequestMsg, NULL)
	ZEND_NAMED_FE(processresponsemsg,
		_wrap_LassoNameRegistration_processResponseMsg, NULL)
	ZEND_NAMED_FE(validaterequest,
		_wrap_LassoNameRegistration_validateRequest, NULL)
	{ NULL, NULL, NULL}
};


/* entry subsection */
/* Every non-class user visible function must have an entry here */
function_entry lasso_functions[] = {
	ZEND_NAMED_FE(lasso_init,
		_wrap_lasso_init, NULL)
	ZEND_NAMED_FE(lasso_shutdown,
		_wrap_lasso_shutdown, NULL)
	ZEND_NAMED_FE(lasso_check_version,
		_wrap_lasso_check_version, NULL)
	ZEND_NAMED_FE(lasso_register_dst_service,
		_wrap_lasso_register_dst_service, NULL)
	ZEND_NAMED_FE(lasso_getrequesttypefromsoapmsg,
		_wrap_lasso_getRequestTypeFromSoapMsg, NULL)
	ZEND_NAMED_FE(lasso_islibertyquery,
		_wrap_lasso_isLibertyQuery, NULL)
	{NULL, NULL, NULL}
};

zend_module_entry lasso_module_entry = {
#if ZEND_MODULE_API_NO > 20010900
    STANDARD_MODULE_HEADER,
#endif
    "lasso",
    lasso_functions,
    PHP_MINIT(lasso),
    PHP_MSHUTDOWN(lasso),
    PHP_RINIT(lasso),
    PHP_RSHUTDOWN(lasso),
    PHP_MINFO(lasso),
#if ZEND_MODULE_API_NO > 20010900
    NO_VERSION_YET,
#endif
    STANDARD_MODULE_PROPERTIES
};
zend_module_entry* SWIG_module_entry = &lasso_module_entry;


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_LassoMdProtocolType[] = {{"_p_LassoMdProtocolType", 0, "LassoMdProtocolType *", 0, 0, 0, 0},{"_p_LassoMdProtocolType", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoNodeList[] = {{"_p_LassoNodeList", 0, "LassoNodeList *", 0, 0, 0, 0},{"_p_LassoNodeList", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlpStatusCode[] = {{"_p_LassoSamlpStatusCode", 0, "LassoSamlpStatusCode *", 0, 0, 0, 0},{"_p_LassoSamlpStatusCode", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlAudienceRestrictionCondition[] = {{"_p_LassoSamlAudienceRestrictionCondition", 0, "LassoSamlAudienceRestrictionCondition *", 0, 0, 0, 0},{"_p_LassoSamlAudienceRestrictionCondition", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlConditions[] = {{"_p_LassoSamlConditions", 0, "LassoSamlConditions *", 0, 0, 0, 0},{"_p_LassoSamlConditions", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLogout[] = {{"_p_LassoLogout", 0, "LassoLogout *", 0, 0, 0, 0},{"_p_LassoLogout", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlSubjectStatement[] = {{"_p_LassoSamlSubjectStatement", 0, "LassoSamlSubjectStatement *", 0, 0, 0, 0},{"_p_LassoSamlSubjectStatement", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlAuthenticationStatement[] = {{"_p_LassoSamlAuthenticationStatement", 0, "LassoSamlAuthenticationStatement *", 0, 0, 0, 0},{"_p_LassoSamlAuthenticationStatement", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlAttributeStatement[] = {{"_p_LassoSamlAttributeStatement", 0, "LassoSamlAttributeStatement *", 0, 0, 0, 0},{"_p_LassoSamlAttributeStatement", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_char[] = {{"_p_char", 0, "char *", 0, 0, 0, 0},{"_p_char", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLibFederationTerminationNotification[] = {{"_p_LassoLibFederationTerminationNotification", 0, "LassoLibFederationTerminationNotification *", 0, 0, 0, 0},{"_p_LassoLibFederationTerminationNotification", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlpRequestAbstract[] = {{"_p_LassoSamlpRequestAbstract", 0, "LassoSamlpRequestAbstract *", 0, 0, 0, 0},{"_p_LassoSamlpRequestAbstract", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlSubjectStatementAbstract[] = {{"_p_LassoSamlSubjectStatementAbstract", 0, "LassoSamlSubjectStatementAbstract *", 0, 0, 0, 0},{"_p_LassoSamlSubjectStatementAbstract", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlStatementAbstract[] = {{"_p_LassoSamlStatementAbstract", 0, "LassoSamlStatementAbstract *", 0, 0, 0, 0},{"_p_LassoSamlStatementAbstract", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlConditionAbstract[] = {{"_p_LassoSamlConditionAbstract", 0, "LassoSamlConditionAbstract *", 0, 0, 0, 0},{"_p_LassoSamlConditionAbstract", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoHttpMethod[] = {{"_p_LassoHttpMethod", 0, "enum LassoHttpMethod *|LassoHttpMethod *", 0, 0, 0, 0},{"_p_LassoHttpMethod", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlpResponseAbstract[] = {{"_p_LassoSamlpResponseAbstract", 0, "LassoSamlpResponseAbstract *", 0, 0, 0, 0},{"_p_LassoSamlpResponseAbstract", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoStringList[] = {{"_p_LassoStringList", 0, "LassoStringList *", 0, 0, 0, 0},{"_p_LassoStringList", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_void[] = {{"_p_void", 0, "void *", 0, 0, 0, 0},{"_p_void", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__int[] = {{"_int", 0, "int", 0, 0, 0, 0},{"_int", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoFederation[] = {{"_p_LassoFederation", 0, "LassoFederation *", 0, 0, 0, 0},{"_p_LassoFederation", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoDefederation[] = {{"_p_LassoDefederation", 0, "LassoDefederation *", 0, 0, 0, 0},{"_p_LassoDefederation", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLogin[] = {{"_p_LassoLogin", 0, "LassoLogin *", 0, 0, 0, 0},{"_p_LassoLogin", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoCheckVersionMode[] = {{"_p_LassoCheckVersionMode", 0, "enum LassoCheckVersionMode *|LassoCheckVersionMode *", 0, 0, 0, 0},{"_p_LassoCheckVersionMode", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlAuthorityBinding[] = {{"_p_LassoSamlAuthorityBinding", 0, "LassoSamlAuthorityBinding *", 0, 0, 0, 0},{"_p_LassoSamlAuthorityBinding", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoRequestType[] = {{"_p_LassoRequestType", 0, "enum LassoRequestType *|LassoRequestType *", 0, 0, 0, 0},{"_p_LassoRequestType", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlpRequest[] = {{"_p_LassoSamlpRequest", 0, "LassoSamlpRequest *", 0, 0, 0, 0},{"_p_LassoSamlpRequest", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLibAuthnRequest[] = {{"_p_LassoLibAuthnRequest", 0, "LassoLibAuthnRequest *", 0, 0, 0, 0},{"_p_LassoLibAuthnRequest", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLibLogoutRequest[] = {{"_p_LassoLibLogoutRequest", 0, "LassoLibLogoutRequest *", 0, 0, 0, 0},{"_p_LassoLibLogoutRequest", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLibRegisterNameIdentifierRequest[] = {{"_p_LassoLibRegisterNameIdentifierRequest", 0, "LassoLibRegisterNameIdentifierRequest *", 0, 0, 0, 0},{"_p_LassoLibRegisterNameIdentifierRequest", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSignatureType[] = {{"_p_LassoSignatureType", 0, "LassoSignatureType *", 0, 0, 0, 0},{"_p_LassoSignatureType", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlAdvice[] = {{"_p_LassoSamlAdvice", 0, "LassoSamlAdvice *", 0, 0, 0, 0},{"_p_LassoSamlAdvice", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlAssertion[] = {{"_p_LassoSamlAssertion", 0, "LassoSamlAssertion *", 0, 0, 0, 0},{"_p_LassoSamlAssertion", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLibAssertion[] = {{"_p_LassoLibAssertion", 0, "LassoLibAssertion *", 0, 0, 0, 0},{"_p_LassoLibAssertion", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLecp[] = {{"_p_LassoLecp", 0, "LassoLecp *", 0, 0, 0, 0},{"_p_LassoLecp", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSignatureMethod[] = {{"_p_LassoSignatureMethod", 0, "enum LassoSignatureMethod *|LassoSignatureMethod *", 0, 0, 0, 0},{"_p_LassoSignatureMethod", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLibRequestAuthnContext[] = {{"_p_LassoLibRequestAuthnContext", 0, "LassoLibRequestAuthnContext *", 0, 0, 0, 0},{"_p_LassoLibRequestAuthnContext", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLoginProtocolProfile[] = {{"_p_LassoLoginProtocolProfile", 0, "enum LassoLoginProtocolProfile *|LassoLoginProtocolProfile *", 0, 0, 0, 0},{"_p_LassoLoginProtocolProfile", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlNameIdentifier[] = {{"_p_LassoSamlNameIdentifier", 0, "LassoSamlNameIdentifier *", 0, 0, 0, 0},{"_p_LassoSamlNameIdentifier", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoNameRegistration[] = {{"_p_LassoNameRegistration", 0, "LassoNameRegistration *", 0, 0, 0, 0},{"_p_LassoNameRegistration", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlSubject[] = {{"_p_LassoSamlSubject", 0, "LassoSamlSubject *", 0, 0, 0, 0},{"_p_LassoSamlSubject", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlAttributeDesignator[] = {{"_p_LassoSamlAttributeDesignator", 0, "LassoSamlAttributeDesignator *", 0, 0, 0, 0},{"_p_LassoSamlAttributeDesignator", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlpResponse[] = {{"_p_LassoSamlpResponse", 0, "LassoSamlpResponse *", 0, 0, 0, 0},{"_p_LassoSamlpResponse", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLibAuthnResponse[] = {{"_p_LassoLibAuthnResponse", 0, "LassoLibAuthnResponse *", 0, 0, 0, 0},{"_p_LassoLibAuthnResponse", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLibLogoutResponse[] = {{"_p_LassoLibLogoutResponse", 0, "LassoLibLogoutResponse *", 0, 0, 0, 0},{"_p_LassoLibLogoutResponse", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLibRegisterNameIdentifierResponse[] = {{"_p_LassoLibRegisterNameIdentifierResponse", 0, "LassoLibRegisterNameIdentifierResponse *", 0, 0, 0, 0},{"_p_LassoLibRegisterNameIdentifierResponse", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoLibStatusResponse[] = {{"_p_LassoLibStatusResponse", 0, "LassoLibStatusResponse *", 0, 0, 0, 0},{"_p_LassoLibStatusResponse", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoServer[] = {{"_p_LassoServer", 0, "LassoServer *", 0, 0, 0, 0},{"_p_LassoServer", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSession[] = {{"_p_LassoSession", 0, "LassoSession *", 0, 0, 0, 0},{"_p_LassoSession", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlAttribute[] = {{"_p_LassoSamlAttribute", 0, "LassoSamlAttribute *", 0, 0, 0, 0},{"_p_LassoSamlAttribute", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlpStatus[] = {{"_p_LassoSamlpStatus", 0, "LassoSamlpStatus *", 0, 0, 0, 0},{"_p_LassoSamlpStatus", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoIdentity[] = {{"_p_LassoIdentity", 0, "LassoIdentity *", 0, 0, 0, 0},{"_p_LassoIdentity", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoProviderRole[] = {{"_p_LassoProviderRole", 0, "enum LassoProviderRole *|LassoProviderRole *", 0, 0, 0, 0},{"_p_LassoProviderRole", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlSubjectLocality[] = {{"_p_LassoSamlSubjectLocality", 0, "LassoSamlSubjectLocality *", 0, 0, 0, 0},{"_p_LassoSamlSubjectLocality", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlSubjectConfirmation[] = {{"_p_LassoSamlSubjectConfirmation", 0, "LassoSamlSubjectConfirmation *", 0, 0, 0, 0},{"_p_LassoSamlSubjectConfirmation", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoSamlAttributeValue[] = {{"_p_LassoSamlAttributeValue", 0, "LassoSamlAttributeValue *", 0, 0, 0, 0},{"_p_LassoSamlAttributeValue", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoProvider[] = {{"_p_LassoProvider", 0, "LassoProvider *", 0, 0, 0, 0},{"_p_LassoProvider", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoNameIdentifierMapping[] = {{"_p_LassoNameIdentifierMapping", 0, "LassoNameIdentifierMapping *", 0, 0, 0, 0},{"_p_LassoNameIdentifierMapping", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_LassoNode[] = {{"_p_LassoNode", 0, "LassoNode *", 0, 0, 0, 0},{"_p_LassoNode", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_LassoMdProtocolType, 
_swigt__p_LassoNodeList, 
_swigt__p_LassoSamlpStatusCode, 
_swigt__p_LassoSamlAudienceRestrictionCondition, 
_swigt__p_LassoSamlConditions, 
_swigt__p_LassoLogout, 
_swigt__p_LassoSamlSubjectStatement, 
_swigt__p_LassoSamlAuthenticationStatement, 
_swigt__p_LassoSamlAttributeStatement, 
_swigt__p_char, 
_swigt__p_LassoLibFederationTerminationNotification, 
_swigt__p_LassoSamlpRequestAbstract, 
_swigt__p_LassoSamlSubjectStatementAbstract, 
_swigt__p_LassoSamlStatementAbstract, 
_swigt__p_LassoSamlConditionAbstract, 
_swigt__p_LassoHttpMethod, 
_swigt__p_LassoSamlpResponseAbstract, 
_swigt__p_LassoStringList, 
_swigt__p_void, 
_swigt__int, 
_swigt__p_LassoFederation, 
_swigt__p_LassoDefederation, 
_swigt__p_LassoLogin, 
_swigt__p_LassoCheckVersionMode, 
_swigt__p_LassoSamlAuthorityBinding, 
_swigt__p_LassoRequestType, 
_swigt__p_LassoSamlpRequest, 
_swigt__p_LassoLibAuthnRequest, 
_swigt__p_LassoLibLogoutRequest, 
_swigt__p_LassoLibRegisterNameIdentifierRequest, 
_swigt__p_LassoSignatureType, 
_swigt__p_LassoSamlAdvice, 
_swigt__p_LassoSamlAssertion, 
_swigt__p_LassoLibAssertion, 
_swigt__p_LassoLecp, 
_swigt__p_LassoSignatureMethod, 
_swigt__p_LassoLibRequestAuthnContext, 
_swigt__p_LassoLoginProtocolProfile, 
_swigt__p_LassoSamlNameIdentifier, 
_swigt__p_LassoNameRegistration, 
_swigt__p_LassoSamlSubject, 
_swigt__p_LassoSamlAttributeDesignator, 
_swigt__p_LassoSamlpResponse, 
_swigt__p_LassoLibAuthnResponse, 
_swigt__p_LassoLibLogoutResponse, 
_swigt__p_LassoLibRegisterNameIdentifierResponse, 
_swigt__p_LassoLibStatusResponse, 
_swigt__p_LassoServer, 
_swigt__p_LassoSession, 
_swigt__p_LassoSamlAttribute, 
_swigt__p_LassoSamlpStatus, 
_swigt__p_LassoIdentity, 
_swigt__p_LassoProviderRole, 
_swigt__p_LassoSamlSubjectLocality, 
_swigt__p_LassoSamlSubjectConfirmation, 
_swigt__p_LassoSamlAttributeValue, 
_swigt__p_LassoProvider, 
_swigt__p_LassoNameIdentifierMapping, 
_swigt__p_LassoNode, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* vdecl subsection */
static zend_class_entry ce_swig_LassoNode;
static zend_class_entry* ptr_ce_swig_LassoNode=NULL;
static zend_class_entry ce_swig_LassoNodeList;
static zend_class_entry* ptr_ce_swig_LassoNodeList=NULL;
static zend_class_entry ce_swig_LassoStringList;
static zend_class_entry* ptr_ce_swig_LassoStringList=NULL;
static zend_class_entry ce_swig_LassoSamlAdvice;
static zend_class_entry* ptr_ce_swig_LassoSamlAdvice=NULL;
static zend_class_entry ce_swig_LassoSamlAssertion;
static zend_class_entry* ptr_ce_swig_LassoSamlAssertion=NULL;
static zend_class_entry ce_swig_LassoSamlAttribute;
static zend_class_entry* ptr_ce_swig_LassoSamlAttribute=NULL;
static zend_class_entry ce_swig_LassoSamlAttributeDesignator;
static zend_class_entry* ptr_ce_swig_LassoSamlAttributeDesignator=NULL;
static zend_class_entry ce_swig_LassoSamlAttributeStatement;
static zend_class_entry* ptr_ce_swig_LassoSamlAttributeStatement=NULL;
static zend_class_entry ce_swig_LassoSamlAttributeValue;
static zend_class_entry* ptr_ce_swig_LassoSamlAttributeValue=NULL;
static zend_class_entry ce_swig_LassoSamlAudienceRestrictionCondition;
static zend_class_entry* ptr_ce_swig_LassoSamlAudienceRestrictionCondition=NULL;
static zend_class_entry ce_swig_LassoSamlAuthenticationStatement;
static zend_class_entry* ptr_ce_swig_LassoSamlAuthenticationStatement=NULL;
static zend_class_entry ce_swig_LassoSamlAuthorityBinding;
static zend_class_entry* ptr_ce_swig_LassoSamlAuthorityBinding=NULL;
static zend_class_entry ce_swig_LassoSamlConditionAbstract;
static zend_class_entry* ptr_ce_swig_LassoSamlConditionAbstract=NULL;
static zend_class_entry ce_swig_LassoSamlConditions;
static zend_class_entry* ptr_ce_swig_LassoSamlConditions=NULL;
static zend_class_entry ce_swig_LassoSamlNameIdentifier;
static zend_class_entry* ptr_ce_swig_LassoSamlNameIdentifier=NULL;
static zend_class_entry ce_swig_LassoSamlStatementAbstract;
static zend_class_entry* ptr_ce_swig_LassoSamlStatementAbstract=NULL;
static zend_class_entry ce_swig_LassoSamlSubject;
static zend_class_entry* ptr_ce_swig_LassoSamlSubject=NULL;
static zend_class_entry ce_swig_LassoSamlSubjectConfirmation;
static zend_class_entry* ptr_ce_swig_LassoSamlSubjectConfirmation=NULL;
static zend_class_entry ce_swig_LassoSamlSubjectLocality;
static zend_class_entry* ptr_ce_swig_LassoSamlSubjectLocality=NULL;
static zend_class_entry ce_swig_LassoSamlSubjectStatement;
static zend_class_entry* ptr_ce_swig_LassoSamlSubjectStatement=NULL;
static zend_class_entry ce_swig_LassoSamlSubjectStatementAbstract;
static zend_class_entry* ptr_ce_swig_LassoSamlSubjectStatementAbstract=NULL;
static zend_class_entry ce_swig_LassoSamlpRequest;
static zend_class_entry* ptr_ce_swig_LassoSamlpRequest=NULL;
static zend_class_entry ce_swig_LassoSamlpRequestAbstract;
static zend_class_entry* ptr_ce_swig_LassoSamlpRequestAbstract=NULL;
static zend_class_entry ce_swig_LassoSamlpResponse;
static zend_class_entry* ptr_ce_swig_LassoSamlpResponse=NULL;
static zend_class_entry ce_swig_LassoSamlpResponseAbstract;
static zend_class_entry* ptr_ce_swig_LassoSamlpResponseAbstract=NULL;
static zend_class_entry ce_swig_LassoSamlpStatus;
static zend_class_entry* ptr_ce_swig_LassoSamlpStatus=NULL;
static zend_class_entry ce_swig_LassoSamlpStatusCode;
static zend_class_entry* ptr_ce_swig_LassoSamlpStatusCode=NULL;
static zend_class_entry ce_swig_LassoLibAssertion;
static zend_class_entry* ptr_ce_swig_LassoLibAssertion=NULL;
static zend_class_entry ce_swig_LassoLibAuthnRequest;
static zend_class_entry* ptr_ce_swig_LassoLibAuthnRequest=NULL;
static zend_class_entry ce_swig_LassoLibAuthnResponse;
static zend_class_entry* ptr_ce_swig_LassoLibAuthnResponse=NULL;
static zend_class_entry ce_swig_LassoLibFederationTerminationNotification;
static zend_class_entry* ptr_ce_swig_LassoLibFederationTerminationNotification=NULL;
static zend_class_entry ce_swig_LassoLibLogoutRequest;
static zend_class_entry* ptr_ce_swig_LassoLibLogoutRequest=NULL;
static zend_class_entry ce_swig_LassoLibLogoutResponse;
static zend_class_entry* ptr_ce_swig_LassoLibLogoutResponse=NULL;
static zend_class_entry ce_swig_LassoLibRegisterNameIdentifierRequest;
static zend_class_entry* ptr_ce_swig_LassoLibRegisterNameIdentifierRequest=NULL;
static zend_class_entry ce_swig_LassoLibRegisterNameIdentifierResponse;
static zend_class_entry* ptr_ce_swig_LassoLibRegisterNameIdentifierResponse=NULL;
static zend_class_entry ce_swig_LassoLibRequestAuthnContext;
static zend_class_entry* ptr_ce_swig_LassoLibRequestAuthnContext=NULL;
static zend_class_entry ce_swig_LassoLibStatusResponse;
static zend_class_entry* ptr_ce_swig_LassoLibStatusResponse=NULL;
static zend_class_entry ce_swig_LassoProvider;
static zend_class_entry* ptr_ce_swig_LassoProvider=NULL;
static zend_class_entry ce_swig_LassoServer;
static zend_class_entry* ptr_ce_swig_LassoServer=NULL;
static zend_class_entry ce_swig_LassoFederation;
static zend_class_entry* ptr_ce_swig_LassoFederation=NULL;
static zend_class_entry ce_swig_LassoIdentity;
static zend_class_entry* ptr_ce_swig_LassoIdentity=NULL;
static zend_class_entry ce_swig_LassoSession;
static zend_class_entry* ptr_ce_swig_LassoSession=NULL;
static zend_class_entry ce_swig_LassoDefederation;
static zend_class_entry* ptr_ce_swig_LassoDefederation=NULL;
static zend_class_entry ce_swig_LassoLogin;
static zend_class_entry* ptr_ce_swig_LassoLogin=NULL;
static zend_class_entry ce_swig_LassoLogout;
static zend_class_entry* ptr_ce_swig_LassoLogout=NULL;
static zend_class_entry ce_swig_LassoLecp;
static zend_class_entry* ptr_ce_swig_LassoLecp=NULL;
static zend_class_entry ce_swig_LassoNameIdentifierMapping;
static zend_class_entry* ptr_ce_swig_LassoNameIdentifierMapping=NULL;
static zend_class_entry ce_swig_LassoNameRegistration;
static zend_class_entry* ptr_ce_swig_LassoNameRegistration=NULL;
static int le_swig__p_LassoMdProtocolType=0; /* handle for  */
static int le_swig__p_LassoNodeList=0; /* handle for LassoNodeList */
static int le_swig__p_LassoSamlpStatusCode=0; /* handle for LassoSamlpStatusCode */
static int le_swig__p_LassoSamlAudienceRestrictionCondition=0; /* handle for LassoSamlAudienceRestrictionCondition */
static int le_swig__p_LassoSamlConditions=0; /* handle for LassoSamlConditions */
static int le_swig__p_LassoLogout=0; /* handle for LassoLogout */
static int le_swig__p_LassoSamlSubjectStatement=0; /* handle for LassoSamlSubjectStatement */
static int le_swig__p_LassoSamlAuthenticationStatement=0; /* handle for LassoSamlAuthenticationStatement */
static int le_swig__p_LassoSamlAttributeStatement=0; /* handle for LassoSamlAttributeStatement */
static int le_swig__p_char=0; /* handle for LassoSamlAttributeStatement */
static int le_swig__p_LassoLibFederationTerminationNotification=0; /* handle for LassoLibFederationTerminationNotification */
static int le_swig__p_LassoSamlpRequestAbstract=0; /* handle for LassoSamlpRequestAbstract */
static int le_swig__p_LassoSamlSubjectStatementAbstract=0; /* handle for LassoSamlSubjectStatementAbstract */
static int le_swig__p_LassoSamlStatementAbstract=0; /* handle for LassoSamlStatementAbstract */
static int le_swig__p_LassoSamlConditionAbstract=0; /* handle for LassoSamlConditionAbstract */
static int le_swig__p_LassoHttpMethod=0; /* handle for LassoSamlConditionAbstract */
static int le_swig__p_LassoSamlpResponseAbstract=0; /* handle for LassoSamlpResponseAbstract */
static int le_swig__p_LassoStringList=0; /* handle for LassoStringList */
static int le_swig__p_void=0; /* handle for LassoStringList */
static int le_swig__int=0; /* handle for LassoStringList */
static int le_swig__p_LassoFederation=0; /* handle for LassoFederation */
static int le_swig__p_LassoDefederation=0; /* handle for LassoDefederation */
static int le_swig__p_LassoLogin=0; /* handle for LassoLogin */
static int le_swig__p_LassoCheckVersionMode=0; /* handle for LassoLogin */
static int le_swig__p_LassoSamlAuthorityBinding=0; /* handle for LassoSamlAuthorityBinding */
static int le_swig__p_LassoRequestType=0; /* handle for LassoSamlAuthorityBinding */
static int le_swig__p_LassoSamlpRequest=0; /* handle for LassoSamlpRequest */
static int le_swig__p_LassoLibAuthnRequest=0; /* handle for LassoLibAuthnRequest */
static int le_swig__p_LassoLibLogoutRequest=0; /* handle for LassoLibLogoutRequest */
static int le_swig__p_LassoLibRegisterNameIdentifierRequest=0; /* handle for LassoLibRegisterNameIdentifierRequest */
static int le_swig__p_LassoSignatureType=0; /* handle for LassoLibRegisterNameIdentifierRequest */
static int le_swig__p_LassoSamlAdvice=0; /* handle for LassoSamlAdvice */
static int le_swig__p_LassoSamlAssertion=0; /* handle for LassoSamlAssertion */
static int le_swig__p_LassoLibAssertion=0; /* handle for LassoLibAssertion */
static int le_swig__p_LassoLecp=0; /* handle for LassoLecp */
static int le_swig__p_LassoSignatureMethod=0; /* handle for LassoLecp */
static int le_swig__p_LassoLibRequestAuthnContext=0; /* handle for LassoLibRequestAuthnContext */
static int le_swig__p_LassoLoginProtocolProfile=0; /* handle for LassoLibRequestAuthnContext */
static int le_swig__p_LassoSamlNameIdentifier=0; /* handle for LassoSamlNameIdentifier */
static int le_swig__p_LassoNameRegistration=0; /* handle for LassoNameRegistration */
static int le_swig__p_LassoSamlSubject=0; /* handle for LassoSamlSubject */
static int le_swig__p_LassoSamlAttributeDesignator=0; /* handle for LassoSamlAttributeDesignator */
static int le_swig__p_LassoSamlpResponse=0; /* handle for LassoSamlpResponse */
static int le_swig__p_LassoLibAuthnResponse=0; /* handle for LassoLibAuthnResponse */
static int le_swig__p_LassoLibLogoutResponse=0; /* handle for LassoLibLogoutResponse */
static int le_swig__p_LassoLibRegisterNameIdentifierResponse=0; /* handle for LassoLibRegisterNameIdentifierResponse */
static int le_swig__p_LassoLibStatusResponse=0; /* handle for LassoLibStatusResponse */
static int le_swig__p_LassoServer=0; /* handle for LassoServer */
static int le_swig__p_LassoSession=0; /* handle for LassoSession */
static int le_swig__p_LassoSamlAttribute=0; /* handle for LassoSamlAttribute */
static int le_swig__p_LassoSamlpStatus=0; /* handle for LassoSamlpStatus */
static int le_swig__p_LassoIdentity=0; /* handle for LassoIdentity */
static int le_swig__p_LassoProviderRole=0; /* handle for LassoIdentity */
static int le_swig__p_LassoSamlSubjectLocality=0; /* handle for LassoSamlSubjectLocality */
static int le_swig__p_LassoSamlSubjectConfirmation=0; /* handle for LassoSamlSubjectConfirmation */
static int le_swig__p_LassoSamlAttributeValue=0; /* handle for LassoSamlAttributeValue */
static int le_swig__p_LassoProvider=0; /* handle for LassoProvider */
static int le_swig__p_LassoNameIdentifierMapping=0; /* handle for LassoNameIdentifierMapping */
static int le_swig__p_LassoNode=0; /* handle for LassoNode */
/* end vdecl subsection */
/* wrapper section */
ZEND_NAMED_FUNCTION(_wrap_lasso_init) {
    int result;
    zval **args[1];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (int)lasso_init();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_lasso_shutdown) {
    int result;
    zval **args[1];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (int)lasso_shutdown();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_lasso_check_version) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    LassoCheckVersionMode arg4 = (LassoCheckVersionMode) LASSO_CHECK_VERSION_NUMERIC ;
    int result;
    zval **args[5];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(3-argbase) || arg_count>(4-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    convert_to_long_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (int) Z_LVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (int) Z_LVAL_PP(args[1-argbase]);
    
    
    convert_to_long_ex(args[2-argbase]);
    arg3 = (int) Z_LVAL_PP(args[2-argbase]);
    
    if(arg_count > 3 - argbase) {
        convert_to_long_ex(args[3-argbase]);
        arg4 = (LassoCheckVersionMode) Z_LVAL_PP(args[3-argbase]);
        
    }
    result = (int)lasso_check_version(arg1,arg2,arg3,(LassoCheckVersionMode )arg4);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_lasso_register_dst_service) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    lasso_register_dst_service((char const *)arg1,(char const *)arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoNode) {
    LassoNode *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoNode *)new_LassoNode();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoNode, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoNode(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoNode *arg1 = (LassoNode *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoNode TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoNode resource already free'd");
    delete_LassoNode(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoNode) {
    LassoNode *arg1 = (LassoNode *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoNode)
                break;
                if (super && SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of delete_LassoNode. Expected %s",
            1-argbase, SWIGTYPE_p_LassoNode->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoNode(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNode_dump) {
    LassoNode *arg1 = (LassoNode *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoNode)
                break;
                if (super && SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoNode_dump. Expected %s",
            1-argbase, SWIGTYPE_p_LassoNode->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *)LassoNode_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoNode */
static pval _wrap_propget_LassoNode(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoNode(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoNode(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_propset_LassoNode(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoNode(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoNode */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoNode(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_LassoNodeList) {
    LassoNodeList *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoNodeList *)new_LassoNodeList();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNodeList, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNodeList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoNodeList(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoNodeList *arg1 = (LassoNodeList *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoNodeList TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoNodeList resource already free'd");
    delete_LassoNodeList(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoNodeList) {
    LassoNodeList *arg1 = (LassoNodeList *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoNodeList. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoNodeList(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNodeList_append) {
    LassoNodeList *arg1 = (LassoNodeList *) 0 ;
    LassoNode *arg2 = (LassoNode *) 0 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNodeList_append. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*args[1-argbase])->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoNode)
                break;
                if (super && SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoNodeList_append. Expected %s",
            2-argbase, SWIGTYPE_p_LassoNode->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoNodeList_append(arg1,arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNodeList_cast) {
    LassoNodeList *arg1 = (LassoNodeList *) 0 ;
    void *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNodeList_cast. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    result = (void *)LassoNodeList_cast(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_void, 0);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNodeList_frompointer) {
    void *arg1 = (void *) 0 ;
    LassoNodeList *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, 0) < 0) {
        /* Allow NULL from php for void* */
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type==IS_NULL) arg1=0;
        else zend_error(E_ERROR, "Type error in argument %d of LassoNodeList_frompointer. Expected %s", 1-argbase, SWIGTYPE_p_void->name);
    }
    
    result = (LassoNodeList *)LassoNodeList_frompointer(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNodeList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNodeList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoNodeList_getItem) {
    LassoNodeList *arg1 = (LassoNodeList *) 0 ;
    int arg2 ;
    LassoNode *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNodeList_getItem. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (int) Z_LVAL_PP(args[1-argbase]);
    
    {
        if (arg2 < 0 || arg2 >= arg1->len) {
            char errorMsg[256];
            sprintf(errorMsg, "%d", arg2);
            SWIG_exception(SWIG_IndexError, errorMsg);
        }
        result = (LassoNode *)LassoNodeList_getItem(arg1,arg2);
        
    }
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoNode, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoNodeList_length) {
    LassoNodeList *arg1 = (LassoNodeList *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNodeList_length. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    result = (int)LassoNodeList_length(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNodeList_setItem) {
    LassoNodeList *arg1 = (LassoNodeList *) 0 ;
    int arg2 ;
    LassoNode *arg3 = (LassoNode *) 0 ;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNodeList_setItem. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (int) Z_LVAL_PP(args[1-argbase]);
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*args[2-argbase])->type == IS_NULL)
        arg3=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoNode)
                break;
                if (super && SWIG_ConvertPtr(*args[2-argbase], (void **) &arg3, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoNodeList_setItem. Expected %s",
            3-argbase, SWIGTYPE_p_LassoNode->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    {
        if (arg2 < 0 || arg2 >= arg1->len) {
            char errorMsg[256];
            sprintf(errorMsg, "%d", arg2);
            SWIG_exception(SWIG_IndexError, errorMsg);
        }
        LassoNodeList_setItem(arg1,arg2,arg3);
        
    }
    
}


/* property handler for class LassoNodeList */
static pval _wrap_propget_LassoNodeList(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoNodeList(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoNodeList(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_propset_LassoNodeList(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoNodeList(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoNodeList */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoNodeList(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_LassoStringList) {
    LassoStringList *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoStringList *)new_LassoStringList();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoStringList(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoStringList *arg1 = (LassoStringList *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoStringList TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoStringList resource already free'd");
    delete_LassoStringList(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoStringList) {
    LassoStringList *arg1 = (LassoStringList *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoStringList. Expected %s",
        1-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoStringList(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoStringList_append) {
    LassoStringList *arg1 = (LassoStringList *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoStringList_append. Expected %s",
        1-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    LassoStringList_append(arg1,arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoStringList_cast) {
    LassoStringList *arg1 = (LassoStringList *) 0 ;
    void *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoStringList_cast. Expected %s",
        1-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    result = (void *)LassoStringList_cast(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_void, 0);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoStringList_frompointer) {
    void *arg1 = (void *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, 0) < 0) {
        /* Allow NULL from php for void* */
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type==IS_NULL) arg1=0;
        else zend_error(E_ERROR, "Type error in argument %d of LassoStringList_frompointer. Expected %s", 1-argbase, SWIGTYPE_p_void->name);
    }
    
    result = (LassoStringList *)LassoStringList_frompointer(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoStringList_getItem) {
    LassoStringList *arg1 = (LassoStringList *) 0 ;
    int arg2 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoStringList_getItem. Expected %s",
        1-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (int) Z_LVAL_PP(args[1-argbase]);
    
    {
        if (arg2 < 0 || arg2 >= arg1->len) {
            char errorMsg[256];
            sprintf(errorMsg, "%d", arg2);
            SWIG_exception(SWIG_IndexError, errorMsg);
        }
        result = (char *)LassoStringList_getItem(arg1,arg2);
        
    }
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoStringList_length) {
    LassoStringList *arg1 = (LassoStringList *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoStringList_length. Expected %s",
        1-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    result = (int)LassoStringList_length(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoStringList_setItem) {
    LassoStringList *arg1 = (LassoStringList *) 0 ;
    int arg2 ;
    char *arg3 = (char *) 0 ;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoStringList_setItem. Expected %s",
        1-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (int) Z_LVAL_PP(args[1-argbase]);
    
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    {
        if (arg2 < 0 || arg2 >= arg1->len) {
            char errorMsg[256];
            sprintf(errorMsg, "%d", arg2);
            SWIG_exception(SWIG_IndexError, errorMsg);
        }
        LassoStringList_setItem(arg1,arg2,arg3);
        
    }
    
}


/* property handler for class LassoStringList */
static pval _wrap_propget_LassoStringList(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoStringList(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoStringList(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_propset_LassoStringList(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoStringList(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoStringList */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoStringList(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_LassoSamlAdvice_Assertion_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAdvice *arg1 = (LassoSamlAdvice *) 0 ;
    LassoSamlAssertion *arg2 = (LassoSamlAssertion *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAdvice) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAdvice_Assertion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAdvice->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAdvice_Assertion_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    LassoSamlAdvice_Assertion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAdvice_Assertion_get(zend_property_reference *property_reference) {
    LassoSamlAdvice *arg1 = (LassoSamlAdvice *) 0 ;
    LassoSamlAssertion *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAdvice) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAdvice_Assertion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAdvice->name);
    }
    
    result = (LassoSamlAssertion *)LassoSamlAdvice_Assertion_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAssertion, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAssertion);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoSamlAdvice_assertionIdReference_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAdvice *arg1 = (LassoSamlAdvice *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAdvice) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAdvice_assertionIdReference_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAdvice->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAdvice_assertionIdReference_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoSamlAdvice_assertionIdReference_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAdvice_assertionIdReference_get(zend_property_reference *property_reference) {
    LassoSamlAdvice *arg1 = (LassoSamlAdvice *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAdvice) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAdvice_assertionIdReference_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAdvice->name);
    }
    
    result = (LassoStringList *)LassoSamlAdvice_assertionIdReference_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlAdvice) {
    LassoSamlAdvice *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlAdvice *)new_LassoSamlAdvice();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAdvice, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAdvice);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlAdvice(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlAdvice *arg1 = (LassoSamlAdvice *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlAdvice TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlAdvice resource already free'd");
    delete_LassoSamlAdvice(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlAdvice) {
    LassoSamlAdvice *arg1 = (LassoSamlAdvice *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAdvice) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlAdvice. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAdvice->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlAdvice(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlAdvice_dump) {
    LassoSamlAdvice *arg1 = (LassoSamlAdvice *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAdvice) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAdvice_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAdvice->name);
    }
    
    result = (char *)LassoSamlAdvice_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlAdvice */
static pval _wrap_propget_LassoSamlAdvice(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlAdvice(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlAdvice(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"assertionIdReference")==0) {
    *value=_wrap_LassoSamlAdvice_assertionIdReference_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Assertion")==0) {
    *value=_wrap_LassoSamlAdvice_Assertion_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlAdvice(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlAdvice(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlAdvice */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlAdvice(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"assertionIdReference")==0) {
    return _wrap_LassoSamlAdvice_assertionIdReference_set(property_reference, value);
  } else  if (strcmp(propname,"Assertion")==0) {
    return _wrap_LassoSamlAdvice_Assertion_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlAssertion_AssertionID_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_AssertionID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->AssertionID) free((char*)arg1->AssertionID);
        if (arg2) {
            arg1->AssertionID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->AssertionID,arg2);
        } else {
            arg1->AssertionID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_AssertionID_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_AssertionID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (char *) ((arg1)->AssertionID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlAssertion_certificate_file_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_certificate_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->certificate_file) free((char*)arg1->certificate_file);
        if (arg2) {
            arg1->certificate_file = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->certificate_file,arg2);
        } else {
            arg1->certificate_file = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_certificate_file_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_certificate_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (char *) ((arg1)->certificate_file);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlAssertion_IssueInstant_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_IssueInstant_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->IssueInstant) free((char*)arg1->IssueInstant);
        if (arg2) {
            arg1->IssueInstant = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->IssueInstant,arg2);
        } else {
            arg1->IssueInstant = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_IssueInstant_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_IssueInstant_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (char *) ((arg1)->IssueInstant);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlAssertion_Issuer_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_Issuer_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->Issuer) free((char*)arg1->Issuer);
        if (arg2) {
            arg1->Issuer = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->Issuer,arg2);
        } else {
            arg1->Issuer = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_Issuer_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_Issuer_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (char *) ((arg1)->Issuer);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlAssertion_MajorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_MajorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->MajorVersion = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_MajorVersion_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_MajorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (int) ((arg1)->MajorVersion);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlAssertion_MinorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_MinorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->MinorVersion = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_MinorVersion_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_MinorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (int) ((arg1)->MinorVersion);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlAssertion_private_key_file_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_private_key_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->private_key_file) free((char*)arg1->private_key_file);
        if (arg2) {
            arg1->private_key_file = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->private_key_file,arg2);
        } else {
            arg1->private_key_file = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_private_key_file_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_private_key_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (char *) ((arg1)->private_key_file);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlAssertion_sign_method_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSignatureMethod arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_sign_method_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (LassoSignatureMethod) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->sign_method = (LassoSignatureMethod )arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_sign_method_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSignatureMethod result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_sign_method_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (LassoSignatureMethod) ((arg1)->sign_method);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlAssertion_sign_type_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSignatureType arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_sign_type_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_sign_type_set. Expected %s", 2-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg2 = *argp;
    }
    if (arg1) (arg1)->sign_type = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_sign_type_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSignatureType result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_sign_type_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result =  ((arg1)->sign_type);
    
    {
        LassoSignatureType * resultobj = (LassoSignatureType *) emalloc(sizeof(LassoSignatureType));
        memmove(resultobj, &result, sizeof(LassoSignatureType));
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_LassoSignatureType, 0);
    }
    return _return_value;
}


static int _wrap_LassoSamlAssertion_Advice_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSamlAdvice *arg2 = (LassoSamlAdvice *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_Advice_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlAdvice) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_Advice_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlAdvice->name);
    }
    
    LassoSamlAssertion_Advice_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_Advice_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSamlAdvice *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_Advice_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (LassoSamlAdvice *)LassoSamlAssertion_Advice_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAdvice, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAdvice);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoSamlAssertion_AttributeStatement_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSamlAttributeStatement *arg2 = (LassoSamlAttributeStatement *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_AttributeStatement_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlAttributeStatement) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_AttributeStatement_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlAttributeStatement->name);
    }
    
    LassoSamlAssertion_AttributeStatement_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_AttributeStatement_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSamlAttributeStatement *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_AttributeStatement_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (LassoSamlAttributeStatement *)LassoSamlAssertion_AttributeStatement_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAttributeStatement, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAttributeStatement);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoSamlAssertion_AuthenticationStatement_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSamlAuthenticationStatement *arg2 = (LassoSamlAuthenticationStatement *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_AuthenticationStatement_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlAuthenticationStatement) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_AuthenticationStatement_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlAuthenticationStatement->name);
    }
    
    LassoSamlAssertion_AuthenticationStatement_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_AuthenticationStatement_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSamlAuthenticationStatement *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_AuthenticationStatement_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (LassoSamlAuthenticationStatement *)LassoSamlAssertion_AuthenticationStatement_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAuthenticationStatement, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAuthenticationStatement);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoSamlAssertion_Conditions_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSamlConditions *arg2 = (LassoSamlConditions *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_Conditions_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlConditions) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_Conditions_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlConditions->name);
    }
    
    LassoSamlAssertion_Conditions_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_Conditions_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSamlConditions *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_Conditions_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (LassoSamlConditions *)LassoSamlAssertion_Conditions_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlConditions, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlConditions);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoSamlAssertion_SubjectStatement_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSamlSubjectStatement *arg2 = (LassoSamlSubjectStatement *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_SubjectStatement_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlSubjectStatement) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_SubjectStatement_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlSubjectStatement->name);
    }
    
    LassoSamlAssertion_SubjectStatement_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAssertion_SubjectStatement_get(zend_property_reference *property_reference) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    LassoSamlSubjectStatement *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_SubjectStatement_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (LassoSamlSubjectStatement *)LassoSamlAssertion_SubjectStatement_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlSubjectStatement, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlSubjectStatement);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlAssertion) {
    LassoSamlAssertion *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlAssertion *)new_LassoSamlAssertion();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAssertion, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAssertion);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlAssertion(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlAssertion TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlAssertion resource already free'd");
    delete_LassoSamlAssertion(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlAssertion) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlAssertion. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlAssertion(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlAssertion_dump) {
    LassoSamlAssertion *arg1 = (LassoSamlAssertion *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAssertion) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAssertion_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAssertion->name);
    }
    
    result = (char *)LassoSamlAssertion_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlAssertion */
static pval _wrap_propget_LassoSamlAssertion(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlAssertion(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlAssertion(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"sign_method")==0) {
    *value=_wrap_LassoSamlAssertion_sign_method_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"SubjectStatement")==0) {
    *value=_wrap_LassoSamlAssertion_SubjectStatement_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AuthenticationStatement")==0) {
    *value=_wrap_LassoSamlAssertion_AuthenticationStatement_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AttributeStatement")==0) {
    *value=_wrap_LassoSamlAssertion_AttributeStatement_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"IssueInstant")==0) {
    *value=_wrap_LassoSamlAssertion_IssueInstant_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Issuer")==0) {
    *value=_wrap_LassoSamlAssertion_Issuer_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Conditions")==0) {
    *value=_wrap_LassoSamlAssertion_Conditions_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_type")==0) {
    *value=_wrap_LassoSamlAssertion_sign_type_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AssertionID")==0) {
    *value=_wrap_LassoSamlAssertion_AssertionID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MinorVersion")==0) {
    *value=_wrap_LassoSamlAssertion_MinorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MajorVersion")==0) {
    *value=_wrap_LassoSamlAssertion_MajorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Advice")==0) {
    *value=_wrap_LassoSamlAssertion_Advice_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"private_key_file")==0) {
    *value=_wrap_LassoSamlAssertion_private_key_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"certificate_file")==0) {
    *value=_wrap_LassoSamlAssertion_certificate_file_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlAssertion(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlAssertion(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlAssertion */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlAssertion(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"SubjectStatement")==0) {
    return _wrap_LassoSamlAssertion_SubjectStatement_set(property_reference, value);
  } else  if (strcmp(propname,"AuthenticationStatement")==0) {
    return _wrap_LassoSamlAssertion_AuthenticationStatement_set(property_reference, value);
  } else  if (strcmp(propname,"AttributeStatement")==0) {
    return _wrap_LassoSamlAssertion_AttributeStatement_set(property_reference, value);
  } else  if (strcmp(propname,"IssueInstant")==0) {
    return _wrap_LassoSamlAssertion_IssueInstant_set(property_reference, value);
  } else  if (strcmp(propname,"Conditions")==0) {
    return _wrap_LassoSamlAssertion_Conditions_set(property_reference, value);
  } else  if (strcmp(propname,"Issuer")==0) {
    return _wrap_LassoSamlAssertion_Issuer_set(property_reference, value);
  } else  if (strcmp(propname,"sign_type")==0) {
    return _wrap_LassoSamlAssertion_sign_type_set(property_reference, value);
  } else  if (strcmp(propname,"AssertionID")==0) {
    return _wrap_LassoSamlAssertion_AssertionID_set(property_reference, value);
  } else  if (strcmp(propname,"MinorVersion")==0) {
    return _wrap_LassoSamlAssertion_MinorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"MajorVersion")==0) {
    return _wrap_LassoSamlAssertion_MajorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"Advice")==0) {
    return _wrap_LassoSamlAssertion_Advice_set(property_reference, value);
  } else  if (strcmp(propname,"private_key_file")==0) {
    return _wrap_LassoSamlAssertion_private_key_file_set(property_reference, value);
  } else  if (strcmp(propname,"certificate_file")==0) {
    return _wrap_LassoSamlAssertion_certificate_file_set(property_reference, value);
  } else  if (strcmp(propname,"sign_method")==0) {
    return _wrap_LassoSamlAssertion_sign_method_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlAttribute_AttributeName_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAttribute *arg1 = (LassoSamlAttribute *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttribute) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttribute_AttributeName_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttribute->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoSamlAttribute_AttributeName_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAttribute_AttributeName_get(zend_property_reference *property_reference) {
    LassoSamlAttribute *arg1 = (LassoSamlAttribute *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttribute) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttribute_AttributeName_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttribute->name);
    }
    
    result = (char *)LassoSamlAttribute_AttributeName_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlAttribute_AttributeNamespace_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAttribute *arg1 = (LassoSamlAttribute *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttribute) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttribute_AttributeNamespace_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttribute->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoSamlAttribute_AttributeNamespace_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAttribute_AttributeNamespace_get(zend_property_reference *property_reference) {
    LassoSamlAttribute *arg1 = (LassoSamlAttribute *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttribute) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttribute_AttributeNamespace_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttribute->name);
    }
    
    result = (char *)LassoSamlAttribute_AttributeNamespace_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlAttribute_AttributeValue_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAttribute *arg1 = (LassoSamlAttribute *) 0 ;
    LassoNodeList *arg2 = (LassoNodeList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttribute) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttribute_AttributeValue_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttribute->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttribute_AttributeValue_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    LassoSamlAttribute_AttributeValue_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAttribute_AttributeValue_get(zend_property_reference *property_reference) {
    LassoSamlAttribute *arg1 = (LassoSamlAttribute *) 0 ;
    LassoNodeList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttribute) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttribute_AttributeValue_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttribute->name);
    }
    
    result = (LassoNodeList *)LassoSamlAttribute_AttributeValue_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNodeList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNodeList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlAttribute) {
    LassoSamlAttribute *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlAttribute *)new_LassoSamlAttribute();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAttribute, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAttribute);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlAttribute(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlAttribute *arg1 = (LassoSamlAttribute *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlAttribute TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlAttribute resource already free'd");
    delete_LassoSamlAttribute(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlAttribute) {
    LassoSamlAttribute *arg1 = (LassoSamlAttribute *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAttribute) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlAttribute. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttribute->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlAttribute(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlAttribute_dump) {
    LassoSamlAttribute *arg1 = (LassoSamlAttribute *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAttribute) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttribute_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttribute->name);
    }
    
    result = (char *)LassoSamlAttribute_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlAttribute */
static pval _wrap_propget_LassoSamlAttribute(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlAttribute(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlAttribute(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"AttributeValue")==0) {
    *value=_wrap_LassoSamlAttribute_AttributeValue_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AttributeName")==0) {
    *value=_wrap_LassoSamlAttribute_AttributeName_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AttributeNamespace")==0) {
    *value=_wrap_LassoSamlAttribute_AttributeNamespace_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlAttribute(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlAttribute(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlAttribute */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlAttribute(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"AttributeName")==0) {
    return _wrap_LassoSamlAttribute_AttributeName_set(property_reference, value);
  } else  if (strcmp(propname,"AttributeNamespace")==0) {
    return _wrap_LassoSamlAttribute_AttributeNamespace_set(property_reference, value);
  } else  if (strcmp(propname,"AttributeValue")==0) {
    return _wrap_LassoSamlAttribute_AttributeValue_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlAttributeDesignator_AttributeName_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAttributeDesignator *arg1 = (LassoSamlAttributeDesignator *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeDesignator) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeDesignator_AttributeName_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeDesignator->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->AttributeName) free((char*)arg1->AttributeName);
        if (arg2) {
            arg1->AttributeName = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->AttributeName,arg2);
        } else {
            arg1->AttributeName = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAttributeDesignator_AttributeName_get(zend_property_reference *property_reference) {
    LassoSamlAttributeDesignator *arg1 = (LassoSamlAttributeDesignator *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeDesignator) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeDesignator_AttributeName_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeDesignator->name);
    }
    
    result = (char *) ((arg1)->AttributeName);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlAttributeDesignator_AttributeNamespace_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAttributeDesignator *arg1 = (LassoSamlAttributeDesignator *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeDesignator) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeDesignator_AttributeNamespace_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeDesignator->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->AttributeNamespace) free((char*)arg1->AttributeNamespace);
        if (arg2) {
            arg1->AttributeNamespace = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->AttributeNamespace,arg2);
        } else {
            arg1->AttributeNamespace = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAttributeDesignator_AttributeNamespace_get(zend_property_reference *property_reference) {
    LassoSamlAttributeDesignator *arg1 = (LassoSamlAttributeDesignator *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeDesignator) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeDesignator_AttributeNamespace_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeDesignator->name);
    }
    
    result = (char *) ((arg1)->AttributeNamespace);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlAttributeDesignator) {
    LassoSamlAttributeDesignator *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlAttributeDesignator *)new_LassoSamlAttributeDesignator();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAttributeDesignator, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAttributeDesignator);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlAttributeDesignator(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlAttributeDesignator *arg1 = (LassoSamlAttributeDesignator *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlAttributeDesignator TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlAttributeDesignator resource already free'd");
    delete_LassoSamlAttributeDesignator(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlAttributeDesignator) {
    LassoSamlAttributeDesignator *arg1 = (LassoSamlAttributeDesignator *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeDesignator) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlAttributeDesignator. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeDesignator->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlAttributeDesignator(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlAttributeDesignator_dump) {
    LassoSamlAttributeDesignator *arg1 = (LassoSamlAttributeDesignator *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeDesignator) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeDesignator_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeDesignator->name);
    }
    
    result = (char *)LassoSamlAttributeDesignator_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlAttributeDesignator */
static pval _wrap_propget_LassoSamlAttributeDesignator(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlAttributeDesignator(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlAttributeDesignator(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"AttributeName")==0) {
    *value=_wrap_LassoSamlAttributeDesignator_AttributeName_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AttributeNamespace")==0) {
    *value=_wrap_LassoSamlAttributeDesignator_AttributeNamespace_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlAttributeDesignator(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlAttributeDesignator(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlAttributeDesignator */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlAttributeDesignator(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"AttributeName")==0) {
    return _wrap_LassoSamlAttributeDesignator_AttributeName_set(property_reference, value);
  } else  if (strcmp(propname,"AttributeNamespace")==0) {
    return _wrap_LassoSamlAttributeDesignator_AttributeNamespace_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlAttributeStatement_Subject_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAttributeStatement *arg1 = (LassoSamlAttributeStatement *) 0 ;
    LassoSamlSubject *arg2 = (LassoSamlSubject *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeStatement_Subject_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeStatement->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlSubject) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeStatement_Subject_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlSubject->name);
    }
    
    LassoSamlAttributeStatement_Subject_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAttributeStatement_Subject_get(zend_property_reference *property_reference) {
    LassoSamlAttributeStatement *arg1 = (LassoSamlAttributeStatement *) 0 ;
    LassoSamlSubject *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeStatement_Subject_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeStatement->name);
    }
    
    result = (LassoSamlSubject *)LassoSamlAttributeStatement_Subject_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlSubject, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlSubject);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoSamlAttributeStatement_Attribute_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAttributeStatement *arg1 = (LassoSamlAttributeStatement *) 0 ;
    LassoNodeList *arg2 = (LassoNodeList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeStatement_Attribute_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeStatement->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeStatement_Attribute_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    LassoSamlAttributeStatement_Attribute_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAttributeStatement_Attribute_get(zend_property_reference *property_reference) {
    LassoSamlAttributeStatement *arg1 = (LassoSamlAttributeStatement *) 0 ;
    LassoNodeList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeStatement_Attribute_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeStatement->name);
    }
    
    result = (LassoNodeList *)LassoSamlAttributeStatement_Attribute_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNodeList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNodeList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlAttributeStatement) {
    LassoSamlAttributeStatement *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlAttributeStatement *)new_LassoSamlAttributeStatement();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAttributeStatement, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAttributeStatement);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlAttributeStatement(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlAttributeStatement *arg1 = (LassoSamlAttributeStatement *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlAttributeStatement TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlAttributeStatement resource already free'd");
    delete_LassoSamlAttributeStatement(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlAttributeStatement) {
    LassoSamlAttributeStatement *arg1 = (LassoSamlAttributeStatement *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeStatement) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlAttributeStatement. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeStatement->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlAttributeStatement(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlAttributeStatement_dump) {
    LassoSamlAttributeStatement *arg1 = (LassoSamlAttributeStatement *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeStatement) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeStatement_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeStatement->name);
    }
    
    result = (char *)LassoSamlAttributeStatement_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlAttributeStatement */
static pval _wrap_propget_LassoSamlAttributeStatement(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlAttributeStatement(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlAttributeStatement(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Subject")==0) {
    *value=_wrap_LassoSamlAttributeStatement_Subject_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Attribute")==0) {
    *value=_wrap_LassoSamlAttributeStatement_Attribute_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlAttributeStatement(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlAttributeStatement(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlAttributeStatement */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlAttributeStatement(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Attribute")==0) {
    return _wrap_LassoSamlAttributeStatement_Attribute_set(property_reference, value);
  } else  if (strcmp(propname,"Subject")==0) {
    return _wrap_LassoSamlAttributeStatement_Subject_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlAttributeValue_any_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAttributeValue *arg1 = (LassoSamlAttributeValue *) 0 ;
    LassoNodeList *arg2 = (LassoNodeList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeValue) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeValue_any_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeValue->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeValue_any_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    LassoSamlAttributeValue_any_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAttributeValue_any_get(zend_property_reference *property_reference) {
    LassoSamlAttributeValue *arg1 = (LassoSamlAttributeValue *) 0 ;
    LassoNodeList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeValue) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeValue_any_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeValue->name);
    }
    
    result = (LassoNodeList *)LassoSamlAttributeValue_any_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNodeList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNodeList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlAttributeValue) {
    LassoSamlAttributeValue *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlAttributeValue *)new_LassoSamlAttributeValue();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAttributeValue, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAttributeValue);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlAttributeValue(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlAttributeValue *arg1 = (LassoSamlAttributeValue *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlAttributeValue TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlAttributeValue resource already free'd");
    delete_LassoSamlAttributeValue(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlAttributeValue) {
    LassoSamlAttributeValue *arg1 = (LassoSamlAttributeValue *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeValue) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlAttributeValue. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeValue->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlAttributeValue(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlAttributeValue_dump) {
    LassoSamlAttributeValue *arg1 = (LassoSamlAttributeValue *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAttributeValue) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAttributeValue_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAttributeValue->name);
    }
    
    result = (char *)LassoSamlAttributeValue_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlAttributeValue */
static pval _wrap_propget_LassoSamlAttributeValue(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlAttributeValue(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlAttributeValue(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"any")==0) {
    *value=_wrap_LassoSamlAttributeValue_any_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlAttributeValue(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlAttributeValue(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlAttributeValue */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlAttributeValue(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"any")==0) {
    return _wrap_LassoSamlAttributeValue_any_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlAudienceRestrictionCondition_audience_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAudienceRestrictionCondition *arg1 = (LassoSamlAudienceRestrictionCondition *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAudienceRestrictionCondition) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAudienceRestrictionCondition_audience_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAudienceRestrictionCondition->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAudienceRestrictionCondition_audience_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoSamlAudienceRestrictionCondition_audience_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAudienceRestrictionCondition_audience_get(zend_property_reference *property_reference) {
    LassoSamlAudienceRestrictionCondition *arg1 = (LassoSamlAudienceRestrictionCondition *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAudienceRestrictionCondition) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAudienceRestrictionCondition_audience_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAudienceRestrictionCondition->name);
    }
    
    result = (LassoStringList *)LassoSamlAudienceRestrictionCondition_audience_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlAudienceRestrictionCondition) {
    LassoSamlAudienceRestrictionCondition *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlAudienceRestrictionCondition *)new_LassoSamlAudienceRestrictionCondition();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAudienceRestrictionCondition, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAudienceRestrictionCondition);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlAudienceRestrictionCondition(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlAudienceRestrictionCondition *arg1 = (LassoSamlAudienceRestrictionCondition *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlAudienceRestrictionCondition TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlAudienceRestrictionCondition resource already free'd");
    delete_LassoSamlAudienceRestrictionCondition(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlAudienceRestrictionCondition) {
    LassoSamlAudienceRestrictionCondition *arg1 = (LassoSamlAudienceRestrictionCondition *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAudienceRestrictionCondition) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlAudienceRestrictionCondition. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAudienceRestrictionCondition->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlAudienceRestrictionCondition(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlAudienceRestrictionCondition_dump) {
    LassoSamlAudienceRestrictionCondition *arg1 = (LassoSamlAudienceRestrictionCondition *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAudienceRestrictionCondition) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAudienceRestrictionCondition_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAudienceRestrictionCondition->name);
    }
    
    result = (char *)LassoSamlAudienceRestrictionCondition_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlAudienceRestrictionCondition */
static pval _wrap_propget_LassoSamlAudienceRestrictionCondition(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlAudienceRestrictionCondition(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlAudienceRestrictionCondition(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"audience")==0) {
    *value=_wrap_LassoSamlAudienceRestrictionCondition_audience_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlAudienceRestrictionCondition(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlAudienceRestrictionCondition(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlAudienceRestrictionCondition */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlAudienceRestrictionCondition(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"audience")==0) {
    return _wrap_LassoSamlAudienceRestrictionCondition_audience_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlAuthenticationStatement_AuthenticationInstant_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAuthenticationStatement *arg1 = (LassoSamlAuthenticationStatement *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthenticationStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthenticationStatement_AuthenticationInstant_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthenticationStatement->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->AuthenticationInstant) free((char*)arg1->AuthenticationInstant);
        if (arg2) {
            arg1->AuthenticationInstant = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->AuthenticationInstant,arg2);
        } else {
            arg1->AuthenticationInstant = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAuthenticationStatement_AuthenticationInstant_get(zend_property_reference *property_reference) {
    LassoSamlAuthenticationStatement *arg1 = (LassoSamlAuthenticationStatement *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthenticationStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthenticationStatement_AuthenticationInstant_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthenticationStatement->name);
    }
    
    result = (char *) ((arg1)->AuthenticationInstant);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlAuthenticationStatement_AuthenticationMethod_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAuthenticationStatement *arg1 = (LassoSamlAuthenticationStatement *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthenticationStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthenticationStatement_AuthenticationMethod_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthenticationStatement->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->AuthenticationMethod) free((char*)arg1->AuthenticationMethod);
        if (arg2) {
            arg1->AuthenticationMethod = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->AuthenticationMethod,arg2);
        } else {
            arg1->AuthenticationMethod = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAuthenticationStatement_AuthenticationMethod_get(zend_property_reference *property_reference) {
    LassoSamlAuthenticationStatement *arg1 = (LassoSamlAuthenticationStatement *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthenticationStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthenticationStatement_AuthenticationMethod_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthenticationStatement->name);
    }
    
    result = (char *) ((arg1)->AuthenticationMethod);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlAuthenticationStatement_AuthorityBinding_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAuthenticationStatement *arg1 = (LassoSamlAuthenticationStatement *) 0 ;
    LassoNodeList *arg2 = (LassoNodeList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthenticationStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthenticationStatement_AuthorityBinding_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthenticationStatement->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthenticationStatement_AuthorityBinding_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    LassoSamlAuthenticationStatement_AuthorityBinding_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAuthenticationStatement_AuthorityBinding_get(zend_property_reference *property_reference) {
    LassoSamlAuthenticationStatement *arg1 = (LassoSamlAuthenticationStatement *) 0 ;
    LassoNodeList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthenticationStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthenticationStatement_AuthorityBinding_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthenticationStatement->name);
    }
    
    result = (LassoNodeList *)LassoSamlAuthenticationStatement_AuthorityBinding_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNodeList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNodeList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoSamlAuthenticationStatement_SubjectLocality_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAuthenticationStatement *arg1 = (LassoSamlAuthenticationStatement *) 0 ;
    LassoSamlSubjectLocality *arg2 = (LassoSamlSubjectLocality *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthenticationStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthenticationStatement_SubjectLocality_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthenticationStatement->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlSubjectLocality) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthenticationStatement_SubjectLocality_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlSubjectLocality->name);
    }
    
    LassoSamlAuthenticationStatement_SubjectLocality_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAuthenticationStatement_SubjectLocality_get(zend_property_reference *property_reference) {
    LassoSamlAuthenticationStatement *arg1 = (LassoSamlAuthenticationStatement *) 0 ;
    LassoSamlSubjectLocality *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthenticationStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthenticationStatement_SubjectLocality_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthenticationStatement->name);
    }
    
    result = (LassoSamlSubjectLocality *)LassoSamlAuthenticationStatement_SubjectLocality_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlSubjectLocality, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlSubjectLocality);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlAuthenticationStatement) {
    LassoSamlAuthenticationStatement *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlAuthenticationStatement *)new_LassoSamlAuthenticationStatement();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAuthenticationStatement, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAuthenticationStatement);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlAuthenticationStatement(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlAuthenticationStatement *arg1 = (LassoSamlAuthenticationStatement *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlAuthenticationStatement TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlAuthenticationStatement resource already free'd");
    delete_LassoSamlAuthenticationStatement(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlAuthenticationStatement) {
    LassoSamlAuthenticationStatement *arg1 = (LassoSamlAuthenticationStatement *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthenticationStatement) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlAuthenticationStatement. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthenticationStatement->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlAuthenticationStatement(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlAuthenticationStatement_dump) {
    LassoSamlAuthenticationStatement *arg1 = (LassoSamlAuthenticationStatement *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthenticationStatement) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthenticationStatement_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthenticationStatement->name);
    }
    
    result = (char *)LassoSamlAuthenticationStatement_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlAuthenticationStatement */
static pval _wrap_propget_LassoSamlAuthenticationStatement(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlAuthenticationStatement(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlAuthenticationStatement(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"AuthenticationInstant")==0) {
    *value=_wrap_LassoSamlAuthenticationStatement_AuthenticationInstant_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AuthorityBinding")==0) {
    *value=_wrap_LassoSamlAuthenticationStatement_AuthorityBinding_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AuthenticationMethod")==0) {
    *value=_wrap_LassoSamlAuthenticationStatement_AuthenticationMethod_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"SubjectLocality")==0) {
    *value=_wrap_LassoSamlAuthenticationStatement_SubjectLocality_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlAuthenticationStatement(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlAuthenticationStatement(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlAuthenticationStatement */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlAuthenticationStatement(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"AuthenticationInstant")==0) {
    return _wrap_LassoSamlAuthenticationStatement_AuthenticationInstant_set(property_reference, value);
  } else  if (strcmp(propname,"AuthorityBinding")==0) {
    return _wrap_LassoSamlAuthenticationStatement_AuthorityBinding_set(property_reference, value);
  } else  if (strcmp(propname,"AuthenticationMethod")==0) {
    return _wrap_LassoSamlAuthenticationStatement_AuthenticationMethod_set(property_reference, value);
  } else  if (strcmp(propname,"SubjectLocality")==0) {
    return _wrap_LassoSamlAuthenticationStatement_SubjectLocality_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlAuthorityBinding_AuthorityKind_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAuthorityBinding *arg1 = (LassoSamlAuthorityBinding *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthorityBinding) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthorityBinding_AuthorityKind_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthorityBinding->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->AuthorityKind) free((char*)arg1->AuthorityKind);
        if (arg2) {
            arg1->AuthorityKind = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->AuthorityKind,arg2);
        } else {
            arg1->AuthorityKind = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAuthorityBinding_AuthorityKind_get(zend_property_reference *property_reference) {
    LassoSamlAuthorityBinding *arg1 = (LassoSamlAuthorityBinding *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthorityBinding) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthorityBinding_AuthorityKind_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthorityBinding->name);
    }
    
    result = (char *) ((arg1)->AuthorityKind);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlAuthorityBinding_Location_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAuthorityBinding *arg1 = (LassoSamlAuthorityBinding *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthorityBinding) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthorityBinding_Location_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthorityBinding->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->Location) free((char*)arg1->Location);
        if (arg2) {
            arg1->Location = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->Location,arg2);
        } else {
            arg1->Location = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAuthorityBinding_Location_get(zend_property_reference *property_reference) {
    LassoSamlAuthorityBinding *arg1 = (LassoSamlAuthorityBinding *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthorityBinding) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthorityBinding_Location_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthorityBinding->name);
    }
    
    result = (char *) ((arg1)->Location);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlAuthorityBinding_Binding_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlAuthorityBinding *arg1 = (LassoSamlAuthorityBinding *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthorityBinding) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthorityBinding_Binding_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthorityBinding->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->Binding) free((char*)arg1->Binding);
        if (arg2) {
            arg1->Binding = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->Binding,arg2);
        } else {
            arg1->Binding = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlAuthorityBinding_Binding_get(zend_property_reference *property_reference) {
    LassoSamlAuthorityBinding *arg1 = (LassoSamlAuthorityBinding *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthorityBinding) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthorityBinding_Binding_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthorityBinding->name);
    }
    
    result = (char *) ((arg1)->Binding);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlAuthorityBinding) {
    LassoSamlAuthorityBinding *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlAuthorityBinding *)new_LassoSamlAuthorityBinding();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAuthorityBinding, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAuthorityBinding);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlAuthorityBinding(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlAuthorityBinding *arg1 = (LassoSamlAuthorityBinding *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlAuthorityBinding TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlAuthorityBinding resource already free'd");
    delete_LassoSamlAuthorityBinding(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlAuthorityBinding) {
    LassoSamlAuthorityBinding *arg1 = (LassoSamlAuthorityBinding *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthorityBinding) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlAuthorityBinding. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthorityBinding->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlAuthorityBinding(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlAuthorityBinding_dump) {
    LassoSamlAuthorityBinding *arg1 = (LassoSamlAuthorityBinding *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlAuthorityBinding) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlAuthorityBinding_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlAuthorityBinding->name);
    }
    
    result = (char *)LassoSamlAuthorityBinding_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlAuthorityBinding */
static pval _wrap_propget_LassoSamlAuthorityBinding(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlAuthorityBinding(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlAuthorityBinding(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Binding")==0) {
    *value=_wrap_LassoSamlAuthorityBinding_Binding_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AuthorityKind")==0) {
    *value=_wrap_LassoSamlAuthorityBinding_AuthorityKind_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Location")==0) {
    *value=_wrap_LassoSamlAuthorityBinding_Location_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlAuthorityBinding(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlAuthorityBinding(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlAuthorityBinding */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlAuthorityBinding(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Binding")==0) {
    return _wrap_LassoSamlAuthorityBinding_Binding_set(property_reference, value);
  } else  if (strcmp(propname,"AuthorityKind")==0) {
    return _wrap_LassoSamlAuthorityBinding_AuthorityKind_set(property_reference, value);
  } else  if (strcmp(propname,"Location")==0) {
    return _wrap_LassoSamlAuthorityBinding_Location_set(property_reference, value);
  } else  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_LassoSamlConditionAbstract_dump) {
    LassoSamlConditionAbstract *arg1 = (LassoSamlConditionAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlConditionAbstract) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlConditionAbstract_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlConditionAbstract->name);
    }
    
    result = (char *)LassoSamlConditionAbstract_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlConditionAbstract) {
    zend_error(E_ERROR,"Cannot create swig object type: LassoSamlConditionAbstract as the underlying object is abstract");
}





/* property handler for class LassoSamlConditionAbstract */
static pval _wrap_propget_LassoSamlConditionAbstract(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlConditionAbstract(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlConditionAbstract(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_propset_LassoSamlConditionAbstract(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlConditionAbstract(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlConditionAbstract */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlConditionAbstract(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_LassoSamlConditions_NotBefore_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlConditions *arg1 = (LassoSamlConditions *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlConditions) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlConditions_NotBefore_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlConditions->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->NotBefore) free((char*)arg1->NotBefore);
        if (arg2) {
            arg1->NotBefore = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->NotBefore,arg2);
        } else {
            arg1->NotBefore = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlConditions_NotBefore_get(zend_property_reference *property_reference) {
    LassoSamlConditions *arg1 = (LassoSamlConditions *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlConditions) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlConditions_NotBefore_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlConditions->name);
    }
    
    result = (char *) ((arg1)->NotBefore);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlConditions_NotOnOrAfter_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlConditions *arg1 = (LassoSamlConditions *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlConditions) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlConditions_NotOnOrAfter_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlConditions->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->NotOnOrAfter) free((char*)arg1->NotOnOrAfter);
        if (arg2) {
            arg1->NotOnOrAfter = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->NotOnOrAfter,arg2);
        } else {
            arg1->NotOnOrAfter = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlConditions_NotOnOrAfter_get(zend_property_reference *property_reference) {
    LassoSamlConditions *arg1 = (LassoSamlConditions *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlConditions) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlConditions_NotOnOrAfter_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlConditions->name);
    }
    
    result = (char *) ((arg1)->NotOnOrAfter);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlConditions_AudienceRestrictionCondition_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlConditions *arg1 = (LassoSamlConditions *) 0 ;
    LassoNodeList *arg2 = (LassoNodeList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlConditions) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlConditions_AudienceRestrictionCondition_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlConditions->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlConditions_AudienceRestrictionCondition_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    LassoSamlConditions_AudienceRestrictionCondition_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlConditions_AudienceRestrictionCondition_get(zend_property_reference *property_reference) {
    LassoSamlConditions *arg1 = (LassoSamlConditions *) 0 ;
    LassoNodeList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlConditions) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlConditions_AudienceRestrictionCondition_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlConditions->name);
    }
    
    result = (LassoNodeList *)LassoSamlConditions_AudienceRestrictionCondition_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNodeList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNodeList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoSamlConditions_Condition_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlConditions *arg1 = (LassoSamlConditions *) 0 ;
    LassoNodeList *arg2 = (LassoNodeList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlConditions) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlConditions_Condition_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlConditions->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlConditions_Condition_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    LassoSamlConditions_Condition_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlConditions_Condition_get(zend_property_reference *property_reference) {
    LassoSamlConditions *arg1 = (LassoSamlConditions *) 0 ;
    LassoNodeList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlConditions) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlConditions_Condition_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlConditions->name);
    }
    
    result = (LassoNodeList *)LassoSamlConditions_Condition_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNodeList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNodeList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlConditions) {
    LassoSamlConditions *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlConditions *)new_LassoSamlConditions();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlConditions, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlConditions);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlConditions(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlConditions *arg1 = (LassoSamlConditions *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlConditions TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlConditions resource already free'd");
    delete_LassoSamlConditions(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlConditions) {
    LassoSamlConditions *arg1 = (LassoSamlConditions *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlConditions) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlConditions. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlConditions->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlConditions(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlConditions_dump) {
    LassoSamlConditions *arg1 = (LassoSamlConditions *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlConditions) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlConditions_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlConditions->name);
    }
    
    result = (char *)LassoSamlConditions_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlConditions */
static pval _wrap_propget_LassoSamlConditions(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlConditions(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlConditions(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"NotOnOrAfter")==0) {
    *value=_wrap_LassoSamlConditions_NotOnOrAfter_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AudienceRestrictionCondition")==0) {
    *value=_wrap_LassoSamlConditions_AudienceRestrictionCondition_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"NotBefore")==0) {
    *value=_wrap_LassoSamlConditions_NotBefore_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Condition")==0) {
    *value=_wrap_LassoSamlConditions_Condition_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlConditions(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlConditions(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlConditions */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlConditions(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"NotOnOrAfter")==0) {
    return _wrap_LassoSamlConditions_NotOnOrAfter_set(property_reference, value);
  } else  if (strcmp(propname,"NotBefore")==0) {
    return _wrap_LassoSamlConditions_NotBefore_set(property_reference, value);
  } else  if (strcmp(propname,"AudienceRestrictionCondition")==0) {
    return _wrap_LassoSamlConditions_AudienceRestrictionCondition_set(property_reference, value);
  } else  if (strcmp(propname,"Condition")==0) {
    return _wrap_LassoSamlConditions_Condition_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlNameIdentifier_content_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlNameIdentifier *arg1 = (LassoSamlNameIdentifier *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlNameIdentifier_content_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->content) free((char*)arg1->content);
        if (arg2) {
            arg1->content = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->content,arg2);
        } else {
            arg1->content = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlNameIdentifier_content_get(zend_property_reference *property_reference) {
    LassoSamlNameIdentifier *arg1 = (LassoSamlNameIdentifier *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlNameIdentifier_content_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    result = (char *) ((arg1)->content);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlNameIdentifier_Format_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlNameIdentifier *arg1 = (LassoSamlNameIdentifier *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlNameIdentifier_Format_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->Format) free((char*)arg1->Format);
        if (arg2) {
            arg1->Format = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->Format,arg2);
        } else {
            arg1->Format = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlNameIdentifier_Format_get(zend_property_reference *property_reference) {
    LassoSamlNameIdentifier *arg1 = (LassoSamlNameIdentifier *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlNameIdentifier_Format_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    result = (char *) ((arg1)->Format);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlNameIdentifier_NameQualifier_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlNameIdentifier *arg1 = (LassoSamlNameIdentifier *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlNameIdentifier_NameQualifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->NameQualifier) free((char*)arg1->NameQualifier);
        if (arg2) {
            arg1->NameQualifier = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->NameQualifier,arg2);
        } else {
            arg1->NameQualifier = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlNameIdentifier_NameQualifier_get(zend_property_reference *property_reference) {
    LassoSamlNameIdentifier *arg1 = (LassoSamlNameIdentifier *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlNameIdentifier_NameQualifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    result = (char *) ((arg1)->NameQualifier);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlNameIdentifier) {
    LassoSamlNameIdentifier *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlNameIdentifier *)new_LassoSamlNameIdentifier();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlNameIdentifier(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlNameIdentifier *arg1 = (LassoSamlNameIdentifier *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlNameIdentifier TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlNameIdentifier resource already free'd");
    delete_LassoSamlNameIdentifier(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlNameIdentifier) {
    LassoSamlNameIdentifier *arg1 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlNameIdentifier. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlNameIdentifier(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlNameIdentifier_dump) {
    LassoSamlNameIdentifier *arg1 = (LassoSamlNameIdentifier *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlNameIdentifier_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    result = (char *)LassoSamlNameIdentifier_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlNameIdentifier */
static pval _wrap_propget_LassoSamlNameIdentifier(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlNameIdentifier(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlNameIdentifier(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"content")==0) {
    *value=_wrap_LassoSamlNameIdentifier_content_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Format")==0) {
    *value=_wrap_LassoSamlNameIdentifier_Format_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"NameQualifier")==0) {
    *value=_wrap_LassoSamlNameIdentifier_NameQualifier_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlNameIdentifier(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlNameIdentifier(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlNameIdentifier */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlNameIdentifier(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"content")==0) {
    return _wrap_LassoSamlNameIdentifier_content_set(property_reference, value);
  } else  if (strcmp(propname,"Format")==0) {
    return _wrap_LassoSamlNameIdentifier_Format_set(property_reference, value);
  } else  if (strcmp(propname,"NameQualifier")==0) {
    return _wrap_LassoSamlNameIdentifier_NameQualifier_set(property_reference, value);
  } else  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_LassoSamlStatementAbstract_dump) {
    LassoSamlStatementAbstract *arg1 = (LassoSamlStatementAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlStatementAbstract) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlStatementAbstract_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlStatementAbstract->name);
    }
    
    result = (char *)LassoSamlStatementAbstract_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlStatementAbstract) {
    zend_error(E_ERROR,"Cannot create swig object type: LassoSamlStatementAbstract as the underlying object is abstract");
}





/* property handler for class LassoSamlStatementAbstract */
static pval _wrap_propget_LassoSamlStatementAbstract(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlStatementAbstract(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlStatementAbstract(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_propset_LassoSamlStatementAbstract(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlStatementAbstract(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlStatementAbstract */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlStatementAbstract(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_LassoSamlSubject_NameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlSubject *arg1 = (LassoSamlSubject *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubject) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubject_NameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubject->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubject_NameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoSamlSubject_NameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlSubject_NameIdentifier_get(zend_property_reference *property_reference) {
    LassoSamlSubject *arg1 = (LassoSamlSubject *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubject) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubject_NameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubject->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoSamlSubject_NameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoSamlSubject_SubjectConfirmation_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlSubject *arg1 = (LassoSamlSubject *) 0 ;
    LassoSamlSubjectConfirmation *arg2 = (LassoSamlSubjectConfirmation *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubject) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubject_SubjectConfirmation_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubject->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlSubjectConfirmation) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubject_SubjectConfirmation_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlSubjectConfirmation->name);
    }
    
    LassoSamlSubject_SubjectConfirmation_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlSubject_SubjectConfirmation_get(zend_property_reference *property_reference) {
    LassoSamlSubject *arg1 = (LassoSamlSubject *) 0 ;
    LassoSamlSubjectConfirmation *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubject) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubject_SubjectConfirmation_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubject->name);
    }
    
    result = (LassoSamlSubjectConfirmation *)LassoSamlSubject_SubjectConfirmation_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlSubjectConfirmation, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlSubjectConfirmation);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlSubject) {
    LassoSamlSubject *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlSubject *)new_LassoSamlSubject();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlSubject, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlSubject);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlSubject(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlSubject *arg1 = (LassoSamlSubject *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlSubject TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlSubject resource already free'd");
    delete_LassoSamlSubject(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlSubject) {
    LassoSamlSubject *arg1 = (LassoSamlSubject *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlSubject) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlSubject. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubject->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlSubject(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlSubject_dump) {
    LassoSamlSubject *arg1 = (LassoSamlSubject *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlSubject) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubject_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubject->name);
    }
    
    result = (char *)LassoSamlSubject_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlSubject */
static pval _wrap_propget_LassoSamlSubject(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlSubject(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlSubject(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"SubjectConfirmation")==0) {
    *value=_wrap_LassoSamlSubject_SubjectConfirmation_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"NameIdentifier")==0) {
    *value=_wrap_LassoSamlSubject_NameIdentifier_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlSubject(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlSubject(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlSubject */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlSubject(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"NameIdentifier")==0) {
    return _wrap_LassoSamlSubject_NameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"SubjectConfirmation")==0) {
    return _wrap_LassoSamlSubject_SubjectConfirmation_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlSubjectConfirmation_SubjectConfirmationData_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlSubjectConfirmation *arg1 = (LassoSamlSubjectConfirmation *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectConfirmation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectConfirmation_SubjectConfirmationData_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectConfirmation->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->SubjectConfirmationData) free((char*)arg1->SubjectConfirmationData);
        if (arg2) {
            arg1->SubjectConfirmationData = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->SubjectConfirmationData,arg2);
        } else {
            arg1->SubjectConfirmationData = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlSubjectConfirmation_SubjectConfirmationData_get(zend_property_reference *property_reference) {
    LassoSamlSubjectConfirmation *arg1 = (LassoSamlSubjectConfirmation *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectConfirmation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectConfirmation_SubjectConfirmationData_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectConfirmation->name);
    }
    
    result = (char *) ((arg1)->SubjectConfirmationData);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlSubjectConfirmation_confirmationMethod_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlSubjectConfirmation *arg1 = (LassoSamlSubjectConfirmation *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectConfirmation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectConfirmation_confirmationMethod_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectConfirmation->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectConfirmation_confirmationMethod_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoSamlSubjectConfirmation_confirmationMethod_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlSubjectConfirmation_confirmationMethod_get(zend_property_reference *property_reference) {
    LassoSamlSubjectConfirmation *arg1 = (LassoSamlSubjectConfirmation *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectConfirmation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectConfirmation_confirmationMethod_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectConfirmation->name);
    }
    
    result = (LassoStringList *)LassoSamlSubjectConfirmation_confirmationMethod_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlSubjectConfirmation) {
    LassoSamlSubjectConfirmation *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlSubjectConfirmation *)new_LassoSamlSubjectConfirmation();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlSubjectConfirmation, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlSubjectConfirmation);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlSubjectConfirmation(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlSubjectConfirmation *arg1 = (LassoSamlSubjectConfirmation *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlSubjectConfirmation TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlSubjectConfirmation resource already free'd");
    delete_LassoSamlSubjectConfirmation(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlSubjectConfirmation) {
    LassoSamlSubjectConfirmation *arg1 = (LassoSamlSubjectConfirmation *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectConfirmation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlSubjectConfirmation. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectConfirmation->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlSubjectConfirmation(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlSubjectConfirmation_dump) {
    LassoSamlSubjectConfirmation *arg1 = (LassoSamlSubjectConfirmation *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectConfirmation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectConfirmation_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectConfirmation->name);
    }
    
    result = (char *)LassoSamlSubjectConfirmation_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlSubjectConfirmation */
static pval _wrap_propget_LassoSamlSubjectConfirmation(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlSubjectConfirmation(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlSubjectConfirmation(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"confirmationMethod")==0) {
    *value=_wrap_LassoSamlSubjectConfirmation_confirmationMethod_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"SubjectConfirmationData")==0) {
    *value=_wrap_LassoSamlSubjectConfirmation_SubjectConfirmationData_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlSubjectConfirmation(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlSubjectConfirmation(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlSubjectConfirmation */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlSubjectConfirmation(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"confirmationMethod")==0) {
    return _wrap_LassoSamlSubjectConfirmation_confirmationMethod_set(property_reference, value);
  } else  if (strcmp(propname,"SubjectConfirmationData")==0) {
    return _wrap_LassoSamlSubjectConfirmation_SubjectConfirmationData_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlSubjectLocality_DNSAddress_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlSubjectLocality *arg1 = (LassoSamlSubjectLocality *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectLocality) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectLocality_DNSAddress_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectLocality->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->DNSAddress) free((char*)arg1->DNSAddress);
        if (arg2) {
            arg1->DNSAddress = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->DNSAddress,arg2);
        } else {
            arg1->DNSAddress = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlSubjectLocality_DNSAddress_get(zend_property_reference *property_reference) {
    LassoSamlSubjectLocality *arg1 = (LassoSamlSubjectLocality *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectLocality) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectLocality_DNSAddress_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectLocality->name);
    }
    
    result = (char *) ((arg1)->DNSAddress);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlSubjectLocality_IPAddress_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlSubjectLocality *arg1 = (LassoSamlSubjectLocality *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectLocality) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectLocality_IPAddress_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectLocality->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->IPAddress) free((char*)arg1->IPAddress);
        if (arg2) {
            arg1->IPAddress = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->IPAddress,arg2);
        } else {
            arg1->IPAddress = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlSubjectLocality_IPAddress_get(zend_property_reference *property_reference) {
    LassoSamlSubjectLocality *arg1 = (LassoSamlSubjectLocality *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectLocality) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectLocality_IPAddress_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectLocality->name);
    }
    
    result = (char *) ((arg1)->IPAddress);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlSubjectLocality) {
    LassoSamlSubjectLocality *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlSubjectLocality *)new_LassoSamlSubjectLocality();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlSubjectLocality, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlSubjectLocality);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlSubjectLocality(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlSubjectLocality *arg1 = (LassoSamlSubjectLocality *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlSubjectLocality TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlSubjectLocality resource already free'd");
    delete_LassoSamlSubjectLocality(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlSubjectLocality) {
    LassoSamlSubjectLocality *arg1 = (LassoSamlSubjectLocality *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectLocality) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlSubjectLocality. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectLocality->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlSubjectLocality(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlSubjectLocality_dump) {
    LassoSamlSubjectLocality *arg1 = (LassoSamlSubjectLocality *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectLocality) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectLocality_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectLocality->name);
    }
    
    result = (char *)LassoSamlSubjectLocality_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlSubjectLocality */
static pval _wrap_propget_LassoSamlSubjectLocality(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlSubjectLocality(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlSubjectLocality(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"DNSAddress")==0) {
    *value=_wrap_LassoSamlSubjectLocality_DNSAddress_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"IPAddress")==0) {
    *value=_wrap_LassoSamlSubjectLocality_IPAddress_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlSubjectLocality(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlSubjectLocality(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlSubjectLocality */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlSubjectLocality(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"DNSAddress")==0) {
    return _wrap_LassoSamlSubjectLocality_DNSAddress_set(property_reference, value);
  } else  if (strcmp(propname,"IPAddress")==0) {
    return _wrap_LassoSamlSubjectLocality_IPAddress_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlSubjectStatement_Subject_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlSubjectStatement *arg1 = (LassoSamlSubjectStatement *) 0 ;
    LassoSamlSubject *arg2 = (LassoSamlSubject *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectStatement_Subject_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectStatement->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlSubject) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectStatement_Subject_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlSubject->name);
    }
    
    LassoSamlSubjectStatement_Subject_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlSubjectStatement_Subject_get(zend_property_reference *property_reference) {
    LassoSamlSubjectStatement *arg1 = (LassoSamlSubjectStatement *) 0 ;
    LassoSamlSubject *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectStatement) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectStatement_Subject_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectStatement->name);
    }
    
    result = (LassoSamlSubject *)LassoSamlSubjectStatement_Subject_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlSubject, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlSubject);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlSubjectStatement) {
    LassoSamlSubjectStatement *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlSubjectStatement *)new_LassoSamlSubjectStatement();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlSubjectStatement, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlSubjectStatement);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlSubjectStatement(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlSubjectStatement *arg1 = (LassoSamlSubjectStatement *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlSubjectStatement TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlSubjectStatement resource already free'd");
    delete_LassoSamlSubjectStatement(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlSubjectStatement) {
    LassoSamlSubjectStatement *arg1 = (LassoSamlSubjectStatement *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectStatement) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlSubjectStatement. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectStatement->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlSubjectStatement(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlSubjectStatement_dump) {
    LassoSamlSubjectStatement *arg1 = (LassoSamlSubjectStatement *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectStatement) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectStatement_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectStatement->name);
    }
    
    result = (char *)LassoSamlSubjectStatement_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlSubjectStatement */
static pval _wrap_propget_LassoSamlSubjectStatement(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlSubjectStatement(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlSubjectStatement(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Subject")==0) {
    *value=_wrap_LassoSamlSubjectStatement_Subject_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlSubjectStatement(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlSubjectStatement(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlSubjectStatement */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlSubjectStatement(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Subject")==0) {
    return _wrap_LassoSamlSubjectStatement_Subject_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlSubjectStatementAbstract_Subject_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlSubjectStatementAbstract *arg1 = (LassoSamlSubjectStatementAbstract *) 0 ;
    LassoSamlSubject *arg2 = (LassoSamlSubject *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectStatementAbstract) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectStatementAbstract_Subject_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectStatementAbstract->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlSubject) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectStatementAbstract_Subject_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlSubject->name);
    }
    
    LassoSamlSubjectStatementAbstract_Subject_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlSubjectStatementAbstract_Subject_get(zend_property_reference *property_reference) {
    LassoSamlSubjectStatementAbstract *arg1 = (LassoSamlSubjectStatementAbstract *) 0 ;
    LassoSamlSubject *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectStatementAbstract) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectStatementAbstract_Subject_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectStatementAbstract->name);
    }
    
    result = (LassoSamlSubject *)LassoSamlSubjectStatementAbstract_Subject_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlSubject, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlSubject);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlSubjectStatementAbstract_dump) {
    LassoSamlSubjectStatementAbstract *arg1 = (LassoSamlSubjectStatementAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlSubjectStatementAbstract) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlSubjectStatementAbstract_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlSubjectStatementAbstract->name);
    }
    
    result = (char *)LassoSamlSubjectStatementAbstract_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlSubjectStatementAbstract) {
    zend_error(E_ERROR,"Cannot create swig object type: LassoSamlSubjectStatementAbstract as the underlying object is abstract");
}





/* property handler for class LassoSamlSubjectStatementAbstract */
static pval _wrap_propget_LassoSamlSubjectStatementAbstract(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlSubjectStatementAbstract(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlSubjectStatementAbstract(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Subject")==0) {
    *value=_wrap_LassoSamlSubjectStatementAbstract_Subject_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlSubjectStatementAbstract(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlSubjectStatementAbstract(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlSubjectStatementAbstract */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlSubjectStatementAbstract(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Subject")==0) {
    return _wrap_LassoSamlSubjectStatementAbstract_Subject_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlpRequest_AssertionArtifact_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_AssertionArtifact_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->AssertionArtifact) free((char*)arg1->AssertionArtifact);
        if (arg2) {
            arg1->AssertionArtifact = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->AssertionArtifact,arg2);
        } else {
            arg1->AssertionArtifact = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequest_AssertionArtifact_get(zend_property_reference *property_reference) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_AssertionArtifact_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    result = (char *) ((arg1)->AssertionArtifact);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpRequest_certificate_file_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_certificate_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoSamlpRequest_certificate_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequest_certificate_file_get(zend_property_reference *property_reference) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_certificate_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    result = (char *)LassoSamlpRequest_certificate_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpRequest_IssueInstant_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_IssueInstant_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoSamlpRequest_IssueInstant_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequest_IssueInstant_get(zend_property_reference *property_reference) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_IssueInstant_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    result = (char *)LassoSamlpRequest_IssueInstant_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpRequest_MajorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_MajorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoSamlpRequest_MajorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequest_MajorVersion_get(zend_property_reference *property_reference) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_MajorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    result = (int)LassoSamlpRequest_MajorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlpRequest_MinorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_MinorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoSamlpRequest_MinorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequest_MinorVersion_get(zend_property_reference *property_reference) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_MinorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    result = (int)LassoSamlpRequest_MinorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlpRequest_private_key_file_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_private_key_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoSamlpRequest_private_key_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequest_private_key_file_get(zend_property_reference *property_reference) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_private_key_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    result = (char *)LassoSamlpRequest_private_key_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpRequest_RequestID_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_RequestID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoSamlpRequest_RequestID_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequest_RequestID_get(zend_property_reference *property_reference) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_RequestID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    result = (char *)LassoSamlpRequest_RequestID_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpRequest_RespondWith_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_RespondWith_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_RespondWith_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoSamlpRequest_RespondWith_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequest_RespondWith_get(zend_property_reference *property_reference) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_RespondWith_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    result = (LassoStringList *)LassoSamlpRequest_RespondWith_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoSamlpRequest_sign_method_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    LassoSignatureMethod arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_sign_method_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (LassoSignatureMethod) Z_LVAL_PP(&value);
    
    LassoSamlpRequest_sign_method_set(arg1,(LassoSignatureMethod )arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequest_sign_method_get(zend_property_reference *property_reference) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    LassoSignatureMethod result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_sign_method_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    result = (LassoSignatureMethod)LassoSamlpRequest_sign_method_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlpRequest_sign_type_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    LassoSignatureType arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_sign_type_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_sign_type_set. Expected %s", 2-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg2 = *argp;
    }
    LassoSamlpRequest_sign_type_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequest_sign_type_get(zend_property_reference *property_reference) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    LassoSignatureType result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_sign_type_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    result = LassoSamlpRequest_sign_type_get(arg1);
    
    {
        LassoSignatureType * resultobj = (LassoSignatureType *) emalloc(sizeof(LassoSignatureType));
        memmove(resultobj, &result, sizeof(LassoSignatureType));
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_LassoSignatureType, 0);
    }
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlpRequest) {
    LassoSamlpRequest *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlpRequest *)new_LassoSamlpRequest();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlpRequest, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlpRequest);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlpRequest(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlpRequest TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlpRequest resource already free'd");
    delete_LassoSamlpRequest(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlpRequest) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlpRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlpRequest(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlpRequest_dump) {
    LassoSamlpRequest *arg1 = (LassoSamlpRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlpRequest) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequest_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpRequest->name);
    }
    
    result = (char *)LassoSamlpRequest_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlpRequest */
static pval _wrap_propget_LassoSamlpRequest(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlpRequest(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlpRequest(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"AssertionArtifact")==0) {
    *value=_wrap_LassoSamlpRequest_AssertionArtifact_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"certificate_file")==0) {
    *value=_wrap_LassoSamlpRequest_certificate_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MajorVersion")==0) {
    *value=_wrap_LassoSamlpRequest_MajorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MinorVersion")==0) {
    *value=_wrap_LassoSamlpRequest_MinorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"private_key_file")==0) {
    *value=_wrap_LassoSamlpRequest_private_key_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RespondWith")==0) {
    *value=_wrap_LassoSamlpRequest_RespondWith_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"IssueInstant")==0) {
    *value=_wrap_LassoSamlpRequest_IssueInstant_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_type")==0) {
    *value=_wrap_LassoSamlpRequest_sign_type_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RequestID")==0) {
    *value=_wrap_LassoSamlpRequest_RequestID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_method")==0) {
    *value=_wrap_LassoSamlpRequest_sign_method_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlpRequest(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlpRequest(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlpRequest */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlpRequest(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"IssueInstant")==0) {
    return _wrap_LassoSamlpRequest_IssueInstant_set(property_reference, value);
  } else  if (strcmp(propname,"sign_type")==0) {
    return _wrap_LassoSamlpRequest_sign_type_set(property_reference, value);
  } else  if (strcmp(propname,"RequestID")==0) {
    return _wrap_LassoSamlpRequest_RequestID_set(property_reference, value);
  } else  if (strcmp(propname,"sign_method")==0) {
    return _wrap_LassoSamlpRequest_sign_method_set(property_reference, value);
  } else  if (strcmp(propname,"AssertionArtifact")==0) {
    return _wrap_LassoSamlpRequest_AssertionArtifact_set(property_reference, value);
  } else  if (strcmp(propname,"certificate_file")==0) {
    return _wrap_LassoSamlpRequest_certificate_file_set(property_reference, value);
  } else  if (strcmp(propname,"MajorVersion")==0) {
    return _wrap_LassoSamlpRequest_MajorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"MinorVersion")==0) {
    return _wrap_LassoSamlpRequest_MinorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"private_key_file")==0) {
    return _wrap_LassoSamlpRequest_private_key_file_set(property_reference, value);
  } else  if (strcmp(propname,"RespondWith")==0) {
    return _wrap_LassoSamlpRequest_RespondWith_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlpRequestAbstract_certificate_file_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_certificate_file_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->certificate_file) free((char*)arg1->certificate_file);
        if (arg2) {
            arg1->certificate_file = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->certificate_file,arg2);
        } else {
            arg1->certificate_file = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequestAbstract_certificate_file_get(zend_property_reference *property_reference) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_certificate_file_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *) ((arg1)->certificate_file);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpRequestAbstract_IssueInstant_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_IssueInstant_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->IssueInstant) free((char*)arg1->IssueInstant);
        if (arg2) {
            arg1->IssueInstant = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->IssueInstant,arg2);
        } else {
            arg1->IssueInstant = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequestAbstract_IssueInstant_get(zend_property_reference *property_reference) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_IssueInstant_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *) ((arg1)->IssueInstant);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpRequestAbstract_MajorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_MajorVersion_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->MajorVersion = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequestAbstract_MajorVersion_get(zend_property_reference *property_reference) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_MajorVersion_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (int) ((arg1)->MajorVersion);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlpRequestAbstract_MinorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_MinorVersion_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->MinorVersion = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequestAbstract_MinorVersion_get(zend_property_reference *property_reference) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_MinorVersion_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (int) ((arg1)->MinorVersion);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlpRequestAbstract_private_key_file_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_private_key_file_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->private_key_file) free((char*)arg1->private_key_file);
        if (arg2) {
            arg1->private_key_file = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->private_key_file,arg2);
        } else {
            arg1->private_key_file = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequestAbstract_private_key_file_get(zend_property_reference *property_reference) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_private_key_file_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *) ((arg1)->private_key_file);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpRequestAbstract_RequestID_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_RequestID_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->RequestID) free((char*)arg1->RequestID);
        if (arg2) {
            arg1->RequestID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->RequestID,arg2);
        } else {
            arg1->RequestID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequestAbstract_RequestID_get(zend_property_reference *property_reference) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_RequestID_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *) ((arg1)->RequestID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpRequestAbstract_sign_method_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    LassoSignatureMethod arg2 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_sign_method_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_long_ex(&value);
    arg2 = (LassoSignatureMethod) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->sign_method = (LassoSignatureMethod )arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequestAbstract_sign_method_get(zend_property_reference *property_reference) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    LassoSignatureMethod result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_sign_method_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (LassoSignatureMethod) ((arg1)->sign_method);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlpRequestAbstract_sign_type_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    LassoSignatureType arg2 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_sign_type_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_sign_type_set. Expected %s", 2-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg2 = *argp;
    }
    if (arg1) (arg1)->sign_type = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequestAbstract_sign_type_get(zend_property_reference *property_reference) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    LassoSignatureType result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_sign_type_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result =  ((arg1)->sign_type);
    
    {
        LassoSignatureType * resultobj = (LassoSignatureType *) emalloc(sizeof(LassoSignatureType));
        memmove(resultobj, &result, sizeof(LassoSignatureType));
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_LassoSignatureType, 0);
    }
    return _return_value;
}


static int _wrap_LassoSamlpRequestAbstract_RespondWith_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_RespondWith_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_RespondWith_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoSamlpRequestAbstract_RespondWith_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpRequestAbstract_RespondWith_get(zend_property_reference *property_reference) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_RespondWith_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (LassoStringList *)LassoSamlpRequestAbstract_RespondWith_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlpRequestAbstract_dump) {
    LassoSamlpRequestAbstract *arg1 = (LassoSamlpRequestAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpRequestAbstract_dump. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *)LassoSamlpRequestAbstract_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlpRequestAbstract) {
    zend_error(E_ERROR,"Cannot create swig object type: LassoSamlpRequestAbstract as the underlying object is abstract");
}





/* property handler for class LassoSamlpRequestAbstract */
static pval _wrap_propget_LassoSamlpRequestAbstract(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlpRequestAbstract(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlpRequestAbstract(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"certificate_file")==0) {
    *value=_wrap_LassoSamlpRequestAbstract_certificate_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MajorVersion")==0) {
    *value=_wrap_LassoSamlpRequestAbstract_MajorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MinorVersion")==0) {
    *value=_wrap_LassoSamlpRequestAbstract_MinorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"private_key_file")==0) {
    *value=_wrap_LassoSamlpRequestAbstract_private_key_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RespondWith")==0) {
    *value=_wrap_LassoSamlpRequestAbstract_RespondWith_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"IssueInstant")==0) {
    *value=_wrap_LassoSamlpRequestAbstract_IssueInstant_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_type")==0) {
    *value=_wrap_LassoSamlpRequestAbstract_sign_type_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RequestID")==0) {
    *value=_wrap_LassoSamlpRequestAbstract_RequestID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_method")==0) {
    *value=_wrap_LassoSamlpRequestAbstract_sign_method_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlpRequestAbstract(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlpRequestAbstract(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlpRequestAbstract */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlpRequestAbstract(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"IssueInstant")==0) {
    return _wrap_LassoSamlpRequestAbstract_IssueInstant_set(property_reference, value);
  } else  if (strcmp(propname,"sign_type")==0) {
    return _wrap_LassoSamlpRequestAbstract_sign_type_set(property_reference, value);
  } else  if (strcmp(propname,"RequestID")==0) {
    return _wrap_LassoSamlpRequestAbstract_RequestID_set(property_reference, value);
  } else  if (strcmp(propname,"sign_method")==0) {
    return _wrap_LassoSamlpRequestAbstract_sign_method_set(property_reference, value);
  } else  if (strcmp(propname,"certificate_file")==0) {
    return _wrap_LassoSamlpRequestAbstract_certificate_file_set(property_reference, value);
  } else  if (strcmp(propname,"MajorVersion")==0) {
    return _wrap_LassoSamlpRequestAbstract_MajorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"MinorVersion")==0) {
    return _wrap_LassoSamlpRequestAbstract_MinorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"private_key_file")==0) {
    return _wrap_LassoSamlpRequestAbstract_private_key_file_set(property_reference, value);
  } else  if (strcmp(propname,"RespondWith")==0) {
    return _wrap_LassoSamlpRequestAbstract_RespondWith_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlpResponse_certificate_file_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_certificate_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoSamlpResponse_certificate_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponse_certificate_file_get(zend_property_reference *property_reference) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_certificate_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = (char *)LassoSamlpResponse_certificate_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpResponse_InResponseTo_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_InResponseTo_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoSamlpResponse_InResponseTo_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponse_InResponseTo_get(zend_property_reference *property_reference) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_InResponseTo_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = (char *)LassoSamlpResponse_InResponseTo_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpResponse_IssueInstant_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_IssueInstant_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoSamlpResponse_IssueInstant_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponse_IssueInstant_get(zend_property_reference *property_reference) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_IssueInstant_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = (char *)LassoSamlpResponse_IssueInstant_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpResponse_MajorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_MajorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoSamlpResponse_MajorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponse_MajorVersion_get(zend_property_reference *property_reference) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_MajorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = (int)LassoSamlpResponse_MajorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlpResponse_MinorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_MinorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoSamlpResponse_MinorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponse_MinorVersion_get(zend_property_reference *property_reference) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_MinorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = (int)LassoSamlpResponse_MinorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlpResponse_private_key_file_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_private_key_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoSamlpResponse_private_key_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponse_private_key_file_get(zend_property_reference *property_reference) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_private_key_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = (char *)LassoSamlpResponse_private_key_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpResponse_Recipient_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_Recipient_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoSamlpResponse_Recipient_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponse_Recipient_get(zend_property_reference *property_reference) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_Recipient_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = (char *)LassoSamlpResponse_Recipient_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpResponse_ResponseID_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_ResponseID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoSamlpResponse_ResponseID_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponse_ResponseID_get(zend_property_reference *property_reference) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_ResponseID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = (char *)LassoSamlpResponse_ResponseID_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpResponse_sign_method_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    LassoSignatureMethod arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_sign_method_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (LassoSignatureMethod) Z_LVAL_PP(&value);
    
    LassoSamlpResponse_sign_method_set(arg1,(LassoSignatureMethod )arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponse_sign_method_get(zend_property_reference *property_reference) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    LassoSignatureMethod result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_sign_method_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = (LassoSignatureMethod)LassoSamlpResponse_sign_method_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlpResponse_sign_type_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    LassoSignatureType arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_sign_type_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_sign_type_set. Expected %s", 2-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg2 = *argp;
    }
    LassoSamlpResponse_sign_type_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponse_sign_type_get(zend_property_reference *property_reference) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    LassoSignatureType result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_sign_type_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = LassoSamlpResponse_sign_type_get(arg1);
    
    {
        LassoSignatureType * resultobj = (LassoSignatureType *) emalloc(sizeof(LassoSignatureType));
        memmove(resultobj, &result, sizeof(LassoSignatureType));
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_LassoSignatureType, 0);
    }
    return _return_value;
}


static int _wrap_LassoSamlpResponse_Assertion_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    LassoNodeList *arg2 = (LassoNodeList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_Assertion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoNodeList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_Assertion_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoNodeList->name);
    }
    
    LassoSamlpResponse_Assertion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponse_Assertion_get(zend_property_reference *property_reference) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    LassoNodeList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_Assertion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = (LassoNodeList *)LassoSamlpResponse_Assertion_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNodeList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNodeList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoSamlpResponse_Status_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    LassoSamlpStatus *arg2 = (LassoSamlpStatus *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_Status_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlpStatus) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_Status_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlpStatus->name);
    }
    
    LassoSamlpResponse_Status_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponse_Status_get(zend_property_reference *property_reference) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    LassoSamlpStatus *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_Status_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = (LassoSamlpStatus *)LassoSamlpResponse_Status_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlpStatus, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlpStatus);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlpResponse) {
    LassoSamlpResponse *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlpResponse *)new_LassoSamlpResponse();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlpResponse, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlpResponse);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlpResponse(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlpResponse TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlpResponse resource already free'd");
    delete_LassoSamlpResponse(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlpResponse) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlpResponse. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlpResponse(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlpResponse_dump) {
    LassoSamlpResponse *arg1 = (LassoSamlpResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlpResponse) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponse_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpResponse->name);
    }
    
    result = (char *)LassoSamlpResponse_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlpResponse */
static pval _wrap_propget_LassoSamlpResponse(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlpResponse(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlpResponse(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Status")==0) {
    *value=_wrap_LassoSamlpResponse_Status_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"certificate_file")==0) {
    *value=_wrap_LassoSamlpResponse_certificate_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MajorVersion")==0) {
    *value=_wrap_LassoSamlpResponse_MajorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MinorVersion")==0) {
    *value=_wrap_LassoSamlpResponse_MinorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"private_key_file")==0) {
    *value=_wrap_LassoSamlpResponse_private_key_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Assertion")==0) {
    *value=_wrap_LassoSamlpResponse_Assertion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"InResponseTo")==0) {
    *value=_wrap_LassoSamlpResponse_InResponseTo_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"IssueInstant")==0) {
    *value=_wrap_LassoSamlpResponse_IssueInstant_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Recipient")==0) {
    *value=_wrap_LassoSamlpResponse_Recipient_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_type")==0) {
    *value=_wrap_LassoSamlpResponse_sign_type_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ResponseID")==0) {
    *value=_wrap_LassoSamlpResponse_ResponseID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_method")==0) {
    *value=_wrap_LassoSamlpResponse_sign_method_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlpResponse(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlpResponse(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlpResponse */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlpResponse(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"InResponseTo")==0) {
    return _wrap_LassoSamlpResponse_InResponseTo_set(property_reference, value);
  } else  if (strcmp(propname,"IssueInstant")==0) {
    return _wrap_LassoSamlpResponse_IssueInstant_set(property_reference, value);
  } else  if (strcmp(propname,"Recipient")==0) {
    return _wrap_LassoSamlpResponse_Recipient_set(property_reference, value);
  } else  if (strcmp(propname,"sign_type")==0) {
    return _wrap_LassoSamlpResponse_sign_type_set(property_reference, value);
  } else  if (strcmp(propname,"ResponseID")==0) {
    return _wrap_LassoSamlpResponse_ResponseID_set(property_reference, value);
  } else  if (strcmp(propname,"sign_method")==0) {
    return _wrap_LassoSamlpResponse_sign_method_set(property_reference, value);
  } else  if (strcmp(propname,"Status")==0) {
    return _wrap_LassoSamlpResponse_Status_set(property_reference, value);
  } else  if (strcmp(propname,"certificate_file")==0) {
    return _wrap_LassoSamlpResponse_certificate_file_set(property_reference, value);
  } else  if (strcmp(propname,"MajorVersion")==0) {
    return _wrap_LassoSamlpResponse_MajorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"MinorVersion")==0) {
    return _wrap_LassoSamlpResponse_MinorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"private_key_file")==0) {
    return _wrap_LassoSamlpResponse_private_key_file_set(property_reference, value);
  } else  if (strcmp(propname,"Assertion")==0) {
    return _wrap_LassoSamlpResponse_Assertion_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlpResponseAbstract_certificate_file_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_certificate_file_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->certificate_file) free((char*)arg1->certificate_file);
        if (arg2) {
            arg1->certificate_file = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->certificate_file,arg2);
        } else {
            arg1->certificate_file = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponseAbstract_certificate_file_get(zend_property_reference *property_reference) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_certificate_file_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *) ((arg1)->certificate_file);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpResponseAbstract_InResponseTo_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_InResponseTo_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->InResponseTo) free((char*)arg1->InResponseTo);
        if (arg2) {
            arg1->InResponseTo = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->InResponseTo,arg2);
        } else {
            arg1->InResponseTo = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponseAbstract_InResponseTo_get(zend_property_reference *property_reference) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_InResponseTo_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *) ((arg1)->InResponseTo);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpResponseAbstract_IssueInstant_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_IssueInstant_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->IssueInstant) free((char*)arg1->IssueInstant);
        if (arg2) {
            arg1->IssueInstant = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->IssueInstant,arg2);
        } else {
            arg1->IssueInstant = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponseAbstract_IssueInstant_get(zend_property_reference *property_reference) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_IssueInstant_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *) ((arg1)->IssueInstant);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpResponseAbstract_MajorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_MajorVersion_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->MajorVersion = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponseAbstract_MajorVersion_get(zend_property_reference *property_reference) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_MajorVersion_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (int) ((arg1)->MajorVersion);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlpResponseAbstract_MinorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_MinorVersion_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->MinorVersion = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponseAbstract_MinorVersion_get(zend_property_reference *property_reference) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_MinorVersion_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (int) ((arg1)->MinorVersion);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlpResponseAbstract_private_key_file_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_private_key_file_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->private_key_file) free((char*)arg1->private_key_file);
        if (arg2) {
            arg1->private_key_file = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->private_key_file,arg2);
        } else {
            arg1->private_key_file = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponseAbstract_private_key_file_get(zend_property_reference *property_reference) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_private_key_file_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *) ((arg1)->private_key_file);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpResponseAbstract_Recipient_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_Recipient_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->Recipient) free((char*)arg1->Recipient);
        if (arg2) {
            arg1->Recipient = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->Recipient,arg2);
        } else {
            arg1->Recipient = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponseAbstract_Recipient_get(zend_property_reference *property_reference) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_Recipient_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *) ((arg1)->Recipient);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpResponseAbstract_ResponseID_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_ResponseID_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->ResponseID) free((char*)arg1->ResponseID);
        if (arg2) {
            arg1->ResponseID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->ResponseID,arg2);
        } else {
            arg1->ResponseID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponseAbstract_ResponseID_get(zend_property_reference *property_reference) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_ResponseID_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *) ((arg1)->ResponseID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpResponseAbstract_sign_method_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    LassoSignatureMethod arg2 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_sign_method_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    convert_to_long_ex(&value);
    arg2 = (LassoSignatureMethod) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->sign_method = (LassoSignatureMethod )arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponseAbstract_sign_method_get(zend_property_reference *property_reference) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    LassoSignatureMethod result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_sign_method_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (LassoSignatureMethod) ((arg1)->sign_method);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoSamlpResponseAbstract_sign_type_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    LassoSignatureType arg2 ;
    zval **args[3];
    int argbase=0 ;

    TSRMLS_FETCH();
    {
        node_info *info, *super;
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_sign_type_set. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_sign_type_set. Expected %s", 2-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg2 = *argp;
    }
    if (arg1) (arg1)->sign_type = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpResponseAbstract_sign_type_get(zend_property_reference *property_reference) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    LassoSignatureType result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_sign_type_get. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result =  ((arg1)->sign_type);
    
    {
        LassoSignatureType * resultobj = (LassoSignatureType *) emalloc(sizeof(LassoSignatureType));
        memmove(resultobj, &result, sizeof(LassoSignatureType));
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_LassoSignatureType, 0);
    }
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlpResponseAbstract_dump) {
    LassoSamlpResponseAbstract *arg1 = (LassoSamlpResponseAbstract *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoSamlpResponseAbstract_dump. Expected %s",
            1-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    result = (char *)LassoSamlpResponseAbstract_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlpResponseAbstract) {
    zend_error(E_ERROR,"Cannot create swig object type: LassoSamlpResponseAbstract as the underlying object is abstract");
}





/* property handler for class LassoSamlpResponseAbstract */
static pval _wrap_propget_LassoSamlpResponseAbstract(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlpResponseAbstract(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlpResponseAbstract(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"certificate_file")==0) {
    *value=_wrap_LassoSamlpResponseAbstract_certificate_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MajorVersion")==0) {
    *value=_wrap_LassoSamlpResponseAbstract_MajorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MinorVersion")==0) {
    *value=_wrap_LassoSamlpResponseAbstract_MinorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"private_key_file")==0) {
    *value=_wrap_LassoSamlpResponseAbstract_private_key_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"InResponseTo")==0) {
    *value=_wrap_LassoSamlpResponseAbstract_InResponseTo_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"IssueInstant")==0) {
    *value=_wrap_LassoSamlpResponseAbstract_IssueInstant_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Recipient")==0) {
    *value=_wrap_LassoSamlpResponseAbstract_Recipient_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_type")==0) {
    *value=_wrap_LassoSamlpResponseAbstract_sign_type_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ResponseID")==0) {
    *value=_wrap_LassoSamlpResponseAbstract_ResponseID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_method")==0) {
    *value=_wrap_LassoSamlpResponseAbstract_sign_method_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlpResponseAbstract(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlpResponseAbstract(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlpResponseAbstract */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlpResponseAbstract(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"InResponseTo")==0) {
    return _wrap_LassoSamlpResponseAbstract_InResponseTo_set(property_reference, value);
  } else  if (strcmp(propname,"IssueInstant")==0) {
    return _wrap_LassoSamlpResponseAbstract_IssueInstant_set(property_reference, value);
  } else  if (strcmp(propname,"Recipient")==0) {
    return _wrap_LassoSamlpResponseAbstract_Recipient_set(property_reference, value);
  } else  if (strcmp(propname,"sign_type")==0) {
    return _wrap_LassoSamlpResponseAbstract_sign_type_set(property_reference, value);
  } else  if (strcmp(propname,"ResponseID")==0) {
    return _wrap_LassoSamlpResponseAbstract_ResponseID_set(property_reference, value);
  } else  if (strcmp(propname,"sign_method")==0) {
    return _wrap_LassoSamlpResponseAbstract_sign_method_set(property_reference, value);
  } else  if (strcmp(propname,"certificate_file")==0) {
    return _wrap_LassoSamlpResponseAbstract_certificate_file_set(property_reference, value);
  } else  if (strcmp(propname,"MajorVersion")==0) {
    return _wrap_LassoSamlpResponseAbstract_MajorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"MinorVersion")==0) {
    return _wrap_LassoSamlpResponseAbstract_MinorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"private_key_file")==0) {
    return _wrap_LassoSamlpResponseAbstract_private_key_file_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlpStatus_StatusMessage_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpStatus *arg1 = (LassoSamlpStatus *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpStatus) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpStatus_StatusMessage_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpStatus->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->StatusMessage) free((char*)arg1->StatusMessage);
        if (arg2) {
            arg1->StatusMessage = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->StatusMessage,arg2);
        } else {
            arg1->StatusMessage = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpStatus_StatusMessage_get(zend_property_reference *property_reference) {
    LassoSamlpStatus *arg1 = (LassoSamlpStatus *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpStatus) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpStatus_StatusMessage_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpStatus->name);
    }
    
    result = (char *) ((arg1)->StatusMessage);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpStatus_StatusCode_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpStatus *arg1 = (LassoSamlpStatus *) 0 ;
    LassoSamlpStatusCode *arg2 = (LassoSamlpStatusCode *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpStatus) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpStatus_StatusCode_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpStatus->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlpStatusCode) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpStatus_StatusCode_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlpStatusCode->name);
    }
    
    LassoSamlpStatus_StatusCode_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpStatus_StatusCode_get(zend_property_reference *property_reference) {
    LassoSamlpStatus *arg1 = (LassoSamlpStatus *) 0 ;
    LassoSamlpStatusCode *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpStatus) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpStatus_StatusCode_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpStatus->name);
    }
    
    result = (LassoSamlpStatusCode *)LassoSamlpStatus_StatusCode_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlpStatusCode, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlpStatusCode);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlpStatus) {
    LassoSamlpStatus *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlpStatus *)new_LassoSamlpStatus();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlpStatus, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlpStatus);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlpStatus(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlpStatus *arg1 = (LassoSamlpStatus *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlpStatus TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlpStatus resource already free'd");
    delete_LassoSamlpStatus(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlpStatus) {
    LassoSamlpStatus *arg1 = (LassoSamlpStatus *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlpStatus) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlpStatus. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpStatus->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlpStatus(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlpStatus_dump) {
    LassoSamlpStatus *arg1 = (LassoSamlpStatus *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlpStatus) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpStatus_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpStatus->name);
    }
    
    result = (char *)LassoSamlpStatus_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlpStatus */
static pval _wrap_propget_LassoSamlpStatus(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlpStatus(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlpStatus(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"StatusMessage")==0) {
    *value=_wrap_LassoSamlpStatus_StatusMessage_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"StatusCode")==0) {
    *value=_wrap_LassoSamlpStatus_StatusCode_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlpStatus(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlpStatus(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlpStatus */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlpStatus(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"StatusMessage")==0) {
    return _wrap_LassoSamlpStatus_StatusMessage_set(property_reference, value);
  } else  if (strcmp(propname,"StatusCode")==0) {
    return _wrap_LassoSamlpStatus_StatusCode_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoSamlpStatusCode_Value_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpStatusCode *arg1 = (LassoSamlpStatusCode *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpStatusCode) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpStatusCode_Value_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpStatusCode->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->Value) free((char*)arg1->Value);
        if (arg2) {
            arg1->Value = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->Value,arg2);
        } else {
            arg1->Value = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpStatusCode_Value_get(zend_property_reference *property_reference) {
    LassoSamlpStatusCode *arg1 = (LassoSamlpStatusCode *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpStatusCode) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpStatusCode_Value_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpStatusCode->name);
    }
    
    result = (char *) ((arg1)->Value);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoSamlpStatusCode_StatusCode_set(zend_property_reference *property_reference, pval *value) {
    LassoSamlpStatusCode *arg1 = (LassoSamlpStatusCode *) 0 ;
    LassoSamlpStatusCode *arg2 = (LassoSamlpStatusCode *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpStatusCode) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpStatusCode_StatusCode_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpStatusCode->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlpStatusCode) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpStatusCode_StatusCode_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlpStatusCode->name);
    }
    
    LassoSamlpStatusCode_StatusCode_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoSamlpStatusCode_StatusCode_get(zend_property_reference *property_reference) {
    LassoSamlpStatusCode *arg1 = (LassoSamlpStatusCode *) 0 ;
    LassoSamlpStatusCode *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSamlpStatusCode) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpStatusCode_StatusCode_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpStatusCode->name);
    }
    
    result = (LassoSamlpStatusCode *)LassoSamlpStatusCode_StatusCode_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlpStatusCode, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlpStatusCode);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSamlpStatusCode) {
    LassoSamlpStatusCode *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSamlpStatusCode *)new_LassoSamlpStatusCode();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlpStatusCode, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlpStatusCode);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSamlpStatusCode(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSamlpStatusCode *arg1 = (LassoSamlpStatusCode *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSamlpStatusCode TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSamlpStatusCode resource already free'd");
    delete_LassoSamlpStatusCode(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSamlpStatusCode) {
    LassoSamlpStatusCode *arg1 = (LassoSamlpStatusCode *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlpStatusCode) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSamlpStatusCode. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpStatusCode->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSamlpStatusCode(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSamlpStatusCode_dump) {
    LassoSamlpStatusCode *arg1 = (LassoSamlpStatusCode *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSamlpStatusCode) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSamlpStatusCode_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSamlpStatusCode->name);
    }
    
    result = (char *)LassoSamlpStatusCode_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoSamlpStatusCode */
static pval _wrap_propget_LassoSamlpStatusCode(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSamlpStatusCode(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSamlpStatusCode(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Value")==0) {
    *value=_wrap_LassoSamlpStatusCode_Value_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"StatusCode")==0) {
    *value=_wrap_LassoSamlpStatusCode_StatusCode_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSamlpStatusCode(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSamlpStatusCode(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSamlpStatusCode */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSamlpStatusCode(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Value")==0) {
    return _wrap_LassoSamlpStatusCode_Value_set(property_reference, value);
  } else  if (strcmp(propname,"StatusCode")==0) {
    return _wrap_LassoSamlpStatusCode_StatusCode_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoLibAssertion_Advice_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSamlAdvice *arg2 = (LassoSamlAdvice *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_Advice_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlAdvice) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_Advice_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlAdvice->name);
    }
    
    LassoLibAssertion_Advice_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_Advice_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSamlAdvice *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_Advice_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (LassoSamlAdvice *)LassoLibAssertion_Advice_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAdvice, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAdvice);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibAssertion_AssertionID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_AssertionID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibAssertion_AssertionID_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_AssertionID_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_AssertionID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (char *)LassoLibAssertion_AssertionID_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAssertion_AttributeStatement_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSamlAttributeStatement *arg2 = (LassoSamlAttributeStatement *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_AttributeStatement_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlAttributeStatement) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_AttributeStatement_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlAttributeStatement->name);
    }
    
    LassoLibAssertion_AttributeStatement_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_AttributeStatement_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSamlAttributeStatement *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_AttributeStatement_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (LassoSamlAttributeStatement *)LassoLibAssertion_AttributeStatement_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAttributeStatement, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAttributeStatement);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibAssertion_AuthenticationStatement_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSamlAuthenticationStatement *arg2 = (LassoSamlAuthenticationStatement *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_AuthenticationStatement_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlAuthenticationStatement) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_AuthenticationStatement_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlAuthenticationStatement->name);
    }
    
    LassoLibAssertion_AuthenticationStatement_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_AuthenticationStatement_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSamlAuthenticationStatement *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_AuthenticationStatement_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (LassoSamlAuthenticationStatement *)LassoLibAssertion_AuthenticationStatement_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlAuthenticationStatement, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlAuthenticationStatement);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibAssertion_certificate_file_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_certificate_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibAssertion_certificate_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_certificate_file_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_certificate_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (char *)LassoLibAssertion_certificate_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAssertion_Conditions_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSamlConditions *arg2 = (LassoSamlConditions *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_Conditions_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlConditions) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_Conditions_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlConditions->name);
    }
    
    LassoLibAssertion_Conditions_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_Conditions_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSamlConditions *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_Conditions_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (LassoSamlConditions *)LassoLibAssertion_Conditions_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlConditions, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlConditions);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibAssertion_IssueInstant_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_IssueInstant_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibAssertion_IssueInstant_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_IssueInstant_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_IssueInstant_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (char *)LassoLibAssertion_IssueInstant_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAssertion_Issuer_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_Issuer_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibAssertion_Issuer_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_Issuer_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_Issuer_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (char *)LassoLibAssertion_Issuer_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAssertion_MajorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_MajorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoLibAssertion_MajorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_MajorVersion_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_MajorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (int)LassoLibAssertion_MajorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibAssertion_MinorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_MinorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoLibAssertion_MinorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_MinorVersion_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_MinorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (int)LassoLibAssertion_MinorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibAssertion_private_key_file_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_private_key_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibAssertion_private_key_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_private_key_file_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_private_key_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (char *)LassoLibAssertion_private_key_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAssertion_sign_method_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSignatureMethod arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_sign_method_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (LassoSignatureMethod) Z_LVAL_PP(&value);
    
    LassoLibAssertion_sign_method_set(arg1,(LassoSignatureMethod )arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_sign_method_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSignatureMethod result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_sign_method_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (LassoSignatureMethod)LassoLibAssertion_sign_method_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibAssertion_sign_type_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSignatureType arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_sign_type_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_sign_type_set. Expected %s", 2-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg2 = *argp;
    }
    LassoLibAssertion_sign_type_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_sign_type_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSignatureType result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_sign_type_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = LassoLibAssertion_sign_type_get(arg1);
    
    {
        LassoSignatureType * resultobj = (LassoSignatureType *) emalloc(sizeof(LassoSignatureType));
        memmove(resultobj, &result, sizeof(LassoSignatureType));
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_LassoSignatureType, 0);
    }
    return _return_value;
}


static int _wrap_LassoLibAssertion_SubjectStatement_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSamlSubjectStatement *arg2 = (LassoSamlSubjectStatement *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_SubjectStatement_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlSubjectStatement) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_SubjectStatement_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlSubjectStatement->name);
    }
    
    LassoLibAssertion_SubjectStatement_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAssertion_SubjectStatement_get(zend_property_reference *property_reference) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    LassoSamlSubjectStatement *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_SubjectStatement_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (LassoSamlSubjectStatement *)LassoLibAssertion_SubjectStatement_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlSubjectStatement, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlSubjectStatement);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLibAssertion) {
    LassoLibAssertion *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoLibAssertion *)new_LassoLibAssertion();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibAssertion, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibAssertion);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLibAssertion(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLibAssertion TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLibAssertion resource already free'd");
    delete_LassoLibAssertion(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLibAssertion) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLibAssertion. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLibAssertion(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibAssertion_newFull) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    LassoLibAssertion *result;
    zval **args[6];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 5) || (zend_get_parameters_array_ex(5-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    
    convert_to_string_ex(args[3-argbase]);
    arg4 = (char *) Z_STRVAL_PP(args[3-argbase]);
    
    
    convert_to_string_ex(args[4-argbase]);
    arg5 = (char *) Z_STRVAL_PP(args[4-argbase]);
    
    result = (LassoLibAssertion *)LassoLibAssertion_newFull(arg1,arg2,arg3,arg4,arg5);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibAssertion, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibAssertion);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibAssertion_dump) {
    LassoLibAssertion *arg1 = (LassoLibAssertion *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibAssertion) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAssertion_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAssertion->name);
    }
    
    result = (char *)LassoLibAssertion_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoLibAssertion */
static pval _wrap_propget_LassoLibAssertion(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLibAssertion(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLibAssertion(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"sign_method")==0) {
    *value=_wrap_LassoLibAssertion_sign_method_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"SubjectStatement")==0) {
    *value=_wrap_LassoLibAssertion_SubjectStatement_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"IssueInstant")==0) {
    *value=_wrap_LassoLibAssertion_IssueInstant_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AuthenticationStatement")==0) {
    *value=_wrap_LassoLibAssertion_AuthenticationStatement_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AttributeStatement")==0) {
    *value=_wrap_LassoLibAssertion_AttributeStatement_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Issuer")==0) {
    *value=_wrap_LassoLibAssertion_Issuer_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Conditions")==0) {
    *value=_wrap_LassoLibAssertion_Conditions_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_type")==0) {
    *value=_wrap_LassoLibAssertion_sign_type_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AssertionID")==0) {
    *value=_wrap_LassoLibAssertion_AssertionID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MinorVersion")==0) {
    *value=_wrap_LassoLibAssertion_MinorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MajorVersion")==0) {
    *value=_wrap_LassoLibAssertion_MajorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Advice")==0) {
    *value=_wrap_LassoLibAssertion_Advice_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"private_key_file")==0) {
    *value=_wrap_LassoLibAssertion_private_key_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"certificate_file")==0) {
    *value=_wrap_LassoLibAssertion_certificate_file_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLibAssertion(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLibAssertion(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLibAssertion */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLibAssertion(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"SubjectStatement")==0) {
    return _wrap_LassoLibAssertion_SubjectStatement_set(property_reference, value);
  } else  if (strcmp(propname,"IssueInstant")==0) {
    return _wrap_LassoLibAssertion_IssueInstant_set(property_reference, value);
  } else  if (strcmp(propname,"AuthenticationStatement")==0) {
    return _wrap_LassoLibAssertion_AuthenticationStatement_set(property_reference, value);
  } else  if (strcmp(propname,"AttributeStatement")==0) {
    return _wrap_LassoLibAssertion_AttributeStatement_set(property_reference, value);
  } else  if (strcmp(propname,"Conditions")==0) {
    return _wrap_LassoLibAssertion_Conditions_set(property_reference, value);
  } else  if (strcmp(propname,"Issuer")==0) {
    return _wrap_LassoLibAssertion_Issuer_set(property_reference, value);
  } else  if (strcmp(propname,"sign_type")==0) {
    return _wrap_LassoLibAssertion_sign_type_set(property_reference, value);
  } else  if (strcmp(propname,"AssertionID")==0) {
    return _wrap_LassoLibAssertion_AssertionID_set(property_reference, value);
  } else  if (strcmp(propname,"MinorVersion")==0) {
    return _wrap_LassoLibAssertion_MinorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"MajorVersion")==0) {
    return _wrap_LassoLibAssertion_MajorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"Advice")==0) {
    return _wrap_LassoLibAssertion_Advice_set(property_reference, value);
  } else  if (strcmp(propname,"private_key_file")==0) {
    return _wrap_LassoLibAssertion_private_key_file_set(property_reference, value);
  } else  if (strcmp(propname,"certificate_file")==0) {
    return _wrap_LassoLibAssertion_certificate_file_set(property_reference, value);
  } else  if (strcmp(propname,"sign_method")==0) {
    return _wrap_LassoLibAssertion_sign_method_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoLibAuthnRequest_AffiliationID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_AffiliationID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->AffiliationID) free((char*)arg1->AffiliationID);
        if (arg2) {
            arg1->AffiliationID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->AffiliationID,arg2);
        } else {
            arg1->AffiliationID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_AffiliationID_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_AffiliationID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (char *) ((arg1)->AffiliationID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_AssertionConsumerServiceID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_AssertionConsumerServiceID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->AssertionConsumerServiceID) free((char*)arg1->AssertionConsumerServiceID);
        if (arg2) {
            arg1->AssertionConsumerServiceID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->AssertionConsumerServiceID,arg2);
        } else {
            arg1->AssertionConsumerServiceID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_AssertionConsumerServiceID_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_AssertionConsumerServiceID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (char *) ((arg1)->AssertionConsumerServiceID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_consent_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_consent_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->consent) free((char*)arg1->consent);
        if (arg2) {
            arg1->consent = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->consent,arg2);
        } else {
            arg1->consent = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_consent_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_consent_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (char *) ((arg1)->consent);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_ForceAuthn_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    bool arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_ForceAuthn_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_boolean_ex(&value);
    arg2 = (bool) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->ForceAuthn = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_ForceAuthn_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_ForceAuthn_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (bool) ((arg1)->ForceAuthn);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_IsPassive_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    bool arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_IsPassive_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_boolean_ex(&value);
    arg2 = (bool) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->IsPassive = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_IsPassive_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_IsPassive_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (bool) ((arg1)->IsPassive);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_NameIDPolicy_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_NameIDPolicy_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->NameIDPolicy) free((char*)arg1->NameIDPolicy);
        if (arg2) {
            arg1->NameIDPolicy = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->NameIDPolicy,arg2);
        } else {
            arg1->NameIDPolicy = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_NameIDPolicy_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_NameIDPolicy_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (char *) ((arg1)->NameIDPolicy);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_ProtocolProfile_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_ProtocolProfile_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->ProtocolProfile) free((char*)arg1->ProtocolProfile);
        if (arg2) {
            arg1->ProtocolProfile = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->ProtocolProfile,arg2);
        } else {
            arg1->ProtocolProfile = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_ProtocolProfile_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_ProtocolProfile_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (char *) ((arg1)->ProtocolProfile);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_ProviderID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_ProviderID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->ProviderID) free((char*)arg1->ProviderID);
        if (arg2) {
            arg1->ProviderID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->ProviderID,arg2);
        } else {
            arg1->ProviderID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_ProviderID_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_ProviderID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (char *) ((arg1)->ProviderID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_RelayState_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_RelayState_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->RelayState) free((char*)arg1->RelayState);
        if (arg2) {
            arg1->RelayState = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->RelayState,arg2);
        } else {
            arg1->RelayState = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_RelayState_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_RelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (char *) ((arg1)->RelayState);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_certificate_file_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_certificate_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibAuthnRequest_certificate_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_certificate_file_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_certificate_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (char *)LassoLibAuthnRequest_certificate_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_IssueInstant_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_IssueInstant_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibAuthnRequest_IssueInstant_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_IssueInstant_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_IssueInstant_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (char *)LassoLibAuthnRequest_IssueInstant_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_MajorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_MajorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoLibAuthnRequest_MajorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_MajorVersion_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_MajorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (int)LassoLibAuthnRequest_MajorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_MinorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_MinorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoLibAuthnRequest_MinorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_MinorVersion_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_MinorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (int)LassoLibAuthnRequest_MinorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_private_key_file_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_private_key_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibAuthnRequest_private_key_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_private_key_file_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_private_key_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (char *)LassoLibAuthnRequest_private_key_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_RequestID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_RequestID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibAuthnRequest_RequestID_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_RequestID_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_RequestID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (char *)LassoLibAuthnRequest_RequestID_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_RespondWith_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_RespondWith_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_RespondWith_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibAuthnRequest_RespondWith_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_RespondWith_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_RespondWith_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (LassoStringList *)LassoLibAuthnRequest_RespondWith_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_sign_method_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    LassoSignatureMethod arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_sign_method_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (LassoSignatureMethod) Z_LVAL_PP(&value);
    
    LassoLibAuthnRequest_sign_method_set(arg1,(LassoSignatureMethod )arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_sign_method_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    LassoSignatureMethod result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_sign_method_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (LassoSignatureMethod)LassoLibAuthnRequest_sign_method_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_sign_type_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    LassoSignatureType arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_sign_type_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_sign_type_set. Expected %s", 2-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg2 = *argp;
    }
    LassoLibAuthnRequest_sign_type_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_sign_type_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    LassoSignatureType result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_sign_type_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = LassoLibAuthnRequest_sign_type_get(arg1);
    
    {
        LassoSignatureType * resultobj = (LassoSignatureType *) emalloc(sizeof(LassoSignatureType));
        memmove(resultobj, &result, sizeof(LassoSignatureType));
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_LassoSignatureType, 0);
    }
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_Extension_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_Extension_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_Extension_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibAuthnRequest_Extension_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_Extension_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_Extension_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (LassoStringList *)LassoLibAuthnRequest_Extension_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibAuthnRequest_RequestAuthnContext_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    LassoLibRequestAuthnContext *arg2 = (LassoLibRequestAuthnContext *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_RequestAuthnContext_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoLibRequestAuthnContext) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_RequestAuthnContext_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoLibRequestAuthnContext->name);
    }
    
    LassoLibAuthnRequest_RequestAuthnContext_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnRequest_RequestAuthnContext_get(zend_property_reference *property_reference) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    LassoLibRequestAuthnContext *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_RequestAuthnContext_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (LassoLibRequestAuthnContext *)LassoLibAuthnRequest_RequestAuthnContext_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibRequestAuthnContext, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibRequestAuthnContext);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLibAuthnRequest) {
    LassoLibAuthnRequest *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoLibAuthnRequest *)new_LassoLibAuthnRequest();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibAuthnRequest, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibAuthnRequest);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLibAuthnRequest(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLibAuthnRequest TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLibAuthnRequest resource already free'd");
    delete_LassoLibAuthnRequest(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLibAuthnRequest) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLibAuthnRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLibAuthnRequest(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibAuthnRequest_dump) {
    LassoLibAuthnRequest *arg1 = (LassoLibAuthnRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnRequest_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (char *)LassoLibAuthnRequest_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoLibAuthnRequest */
static pval _wrap_propget_LassoLibAuthnRequest(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLibAuthnRequest(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLibAuthnRequest(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"IsPassive")==0) {
    *value=_wrap_LassoLibAuthnRequest_IsPassive_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_method")==0) {
    *value=_wrap_LassoLibAuthnRequest_sign_method_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"IssueInstant")==0) {
    *value=_wrap_LassoLibAuthnRequest_IssueInstant_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"consent")==0) {
    *value=_wrap_LassoLibAuthnRequest_consent_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_type")==0) {
    *value=_wrap_LassoLibAuthnRequest_sign_type_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AssertionConsumerServiceID")==0) {
    *value=_wrap_LassoLibAuthnRequest_AssertionConsumerServiceID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RequestAuthnContext")==0) {
    *value=_wrap_LassoLibAuthnRequest_RequestAuthnContext_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ProviderID")==0) {
    *value=_wrap_LassoLibAuthnRequest_ProviderID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"AffiliationID")==0) {
    *value=_wrap_LassoLibAuthnRequest_AffiliationID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RequestID")==0) {
    *value=_wrap_LassoLibAuthnRequest_RequestID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ForceAuthn")==0) {
    *value=_wrap_LassoLibAuthnRequest_ForceAuthn_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"NameIDPolicy")==0) {
    *value=_wrap_LassoLibAuthnRequest_NameIDPolicy_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RespondWith")==0) {
    *value=_wrap_LassoLibAuthnRequest_RespondWith_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MinorVersion")==0) {
    *value=_wrap_LassoLibAuthnRequest_MinorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MajorVersion")==0) {
    *value=_wrap_LassoLibAuthnRequest_MajorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Extension")==0) {
    *value=_wrap_LassoLibAuthnRequest_Extension_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RelayState")==0) {
    *value=_wrap_LassoLibAuthnRequest_RelayState_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"private_key_file")==0) {
    *value=_wrap_LassoLibAuthnRequest_private_key_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"certificate_file")==0) {
    *value=_wrap_LassoLibAuthnRequest_certificate_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ProtocolProfile")==0) {
    *value=_wrap_LassoLibAuthnRequest_ProtocolProfile_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLibAuthnRequest(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLibAuthnRequest(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLibAuthnRequest */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLibAuthnRequest(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"AssertionConsumerServiceID")==0) {
    return _wrap_LassoLibAuthnRequest_AssertionConsumerServiceID_set(property_reference, value);
  } else  if (strcmp(propname,"IssueInstant")==0) {
    return _wrap_LassoLibAuthnRequest_IssueInstant_set(property_reference, value);
  } else  if (strcmp(propname,"consent")==0) {
    return _wrap_LassoLibAuthnRequest_consent_set(property_reference, value);
  } else  if (strcmp(propname,"sign_type")==0) {
    return _wrap_LassoLibAuthnRequest_sign_type_set(property_reference, value);
  } else  if (strcmp(propname,"RequestAuthnContext")==0) {
    return _wrap_LassoLibAuthnRequest_RequestAuthnContext_set(property_reference, value);
  } else  if (strcmp(propname,"ProviderID")==0) {
    return _wrap_LassoLibAuthnRequest_ProviderID_set(property_reference, value);
  } else  if (strcmp(propname,"AffiliationID")==0) {
    return _wrap_LassoLibAuthnRequest_AffiliationID_set(property_reference, value);
  } else  if (strcmp(propname,"RequestID")==0) {
    return _wrap_LassoLibAuthnRequest_RequestID_set(property_reference, value);
  } else  if (strcmp(propname,"NameIDPolicy")==0) {
    return _wrap_LassoLibAuthnRequest_NameIDPolicy_set(property_reference, value);
  } else  if (strcmp(propname,"ForceAuthn")==0) {
    return _wrap_LassoLibAuthnRequest_ForceAuthn_set(property_reference, value);
  } else  if (strcmp(propname,"RespondWith")==0) {
    return _wrap_LassoLibAuthnRequest_RespondWith_set(property_reference, value);
  } else  if (strcmp(propname,"MinorVersion")==0) {
    return _wrap_LassoLibAuthnRequest_MinorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"MajorVersion")==0) {
    return _wrap_LassoLibAuthnRequest_MajorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"Extension")==0) {
    return _wrap_LassoLibAuthnRequest_Extension_set(property_reference, value);
  } else  if (strcmp(propname,"RelayState")==0) {
    return _wrap_LassoLibAuthnRequest_RelayState_set(property_reference, value);
  } else  if (strcmp(propname,"private_key_file")==0) {
    return _wrap_LassoLibAuthnRequest_private_key_file_set(property_reference, value);
  } else  if (strcmp(propname,"certificate_file")==0) {
    return _wrap_LassoLibAuthnRequest_certificate_file_set(property_reference, value);
  } else  if (strcmp(propname,"ProtocolProfile")==0) {
    return _wrap_LassoLibAuthnRequest_ProtocolProfile_set(property_reference, value);
  } else  if (strcmp(propname,"IsPassive")==0) {
    return _wrap_LassoLibAuthnRequest_IsPassive_set(property_reference, value);
  } else  if (strcmp(propname,"sign_method")==0) {
    return _wrap_LassoLibAuthnRequest_sign_method_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoLibAuthnResponse_consent_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_consent_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->consent) free((char*)arg1->consent);
        if (arg2) {
            arg1->consent = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->consent,arg2);
        } else {
            arg1->consent = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnResponse_consent_get(zend_property_reference *property_reference) {
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_consent_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnResponse->name);
    }
    
    result = (char *) ((arg1)->consent);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnResponse_ProviderID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_ProviderID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->ProviderID) free((char*)arg1->ProviderID);
        if (arg2) {
            arg1->ProviderID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->ProviderID,arg2);
        } else {
            arg1->ProviderID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnResponse_ProviderID_get(zend_property_reference *property_reference) {
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_ProviderID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnResponse->name);
    }
    
    result = (char *) ((arg1)->ProviderID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnResponse_RelayState_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_RelayState_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->RelayState) free((char*)arg1->RelayState);
        if (arg2) {
            arg1->RelayState = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->RelayState,arg2);
        } else {
            arg1->RelayState = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnResponse_RelayState_get(zend_property_reference *property_reference) {
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_RelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnResponse->name);
    }
    
    result = (char *) ((arg1)->RelayState);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibAuthnResponse_Extension_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_Extension_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnResponse->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_Extension_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibAuthnResponse_Extension_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnResponse_Extension_get(zend_property_reference *property_reference) {
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_Extension_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnResponse->name);
    }
    
    result = (LassoStringList *)LassoLibAuthnResponse_Extension_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibAuthnResponse_Status_set(zend_property_reference *property_reference, pval *value) {
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    LassoSamlpStatus *arg2 = (LassoSamlpStatus *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_Status_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnResponse->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlpStatus) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_Status_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlpStatus->name);
    }
    
    LassoLibAuthnResponse_Status_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibAuthnResponse_Status_get(zend_property_reference *property_reference) {
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    LassoSamlpStatus *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_Status_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnResponse->name);
    }
    
    result = (LassoSamlpStatus *)LassoLibAuthnResponse_Status_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlpStatus, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlpStatus);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLibAuthnResponse) {
    char *arg1 = (char *) 0 ;
    LassoLibAuthnRequest *arg2 = (LassoLibAuthnRequest *) 0 ;
    LassoLibAuthnResponse *result;
    zval **args[3];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    
    if (SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_LassoLibAuthnRequest) < 0) {
        if ((*args[1-argbase])->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of new_LassoLibAuthnResponse. Expected %s",
        2-argbase, SWIGTYPE_p_LassoLibAuthnRequest->name);
    }
    
    result = (LassoLibAuthnResponse *)new_LassoLibAuthnResponse(arg1,arg2);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibAuthnResponse, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibAuthnResponse);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLibAuthnResponse(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLibAuthnResponse TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLibAuthnResponse resource already free'd");
    delete_LassoLibAuthnResponse(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLibAuthnResponse) {
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnResponse) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLibAuthnResponse. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnResponse->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLibAuthnResponse(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibAuthnResponse_dump) {
    LassoLibAuthnResponse *arg1 = (LassoLibAuthnResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibAuthnResponse) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibAuthnResponse_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibAuthnResponse->name);
    }
    
    result = (char *)LassoLibAuthnResponse_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoLibAuthnResponse */
static pval _wrap_propget_LassoLibAuthnResponse(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLibAuthnResponse(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLibAuthnResponse(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Status")==0) {
    *value=_wrap_LassoLibAuthnResponse_Status_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Extension")==0) {
    *value=_wrap_LassoLibAuthnResponse_Extension_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"consent")==0) {
    *value=_wrap_LassoLibAuthnResponse_consent_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ProviderID")==0) {
    *value=_wrap_LassoLibAuthnResponse_ProviderID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RelayState")==0) {
    *value=_wrap_LassoLibAuthnResponse_RelayState_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLibAuthnResponse(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLibAuthnResponse(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLibAuthnResponse */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLibAuthnResponse(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"consent")==0) {
    return _wrap_LassoLibAuthnResponse_consent_set(property_reference, value);
  } else  if (strcmp(propname,"ProviderID")==0) {
    return _wrap_LassoLibAuthnResponse_ProviderID_set(property_reference, value);
  } else  if (strcmp(propname,"RelayState")==0) {
    return _wrap_LassoLibAuthnResponse_RelayState_set(property_reference, value);
  } else  if (strcmp(propname,"Status")==0) {
    return _wrap_LassoLibAuthnResponse_Status_set(property_reference, value);
  } else  if (strcmp(propname,"Extension")==0) {
    return _wrap_LassoLibAuthnResponse_Extension_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoLibFederationTerminationNotification_consent_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_consent_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->consent) free((char*)arg1->consent);
        if (arg2) {
            arg1->consent = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->consent,arg2);
        } else {
            arg1->consent = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_consent_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_consent_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (char *) ((arg1)->consent);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_ProviderID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_ProviderID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->ProviderID) free((char*)arg1->ProviderID);
        if (arg2) {
            arg1->ProviderID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->ProviderID,arg2);
        } else {
            arg1->ProviderID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_ProviderID_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_ProviderID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (char *) ((arg1)->ProviderID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_RelayState_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_RelayState_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->RelayState) free((char*)arg1->RelayState);
        if (arg2) {
            arg1->RelayState = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->RelayState,arg2);
        } else {
            arg1->RelayState = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_RelayState_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_RelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (char *) ((arg1)->RelayState);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_certificate_file_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_certificate_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibFederationTerminationNotification_certificate_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_certificate_file_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_certificate_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (char *)LassoLibFederationTerminationNotification_certificate_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_IssueInstant_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_IssueInstant_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibFederationTerminationNotification_IssueInstant_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_IssueInstant_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_IssueInstant_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (char *)LassoLibFederationTerminationNotification_IssueInstant_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_MajorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_MajorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoLibFederationTerminationNotification_MajorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_MajorVersion_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_MajorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (int)LassoLibFederationTerminationNotification_MajorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_MinorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_MinorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoLibFederationTerminationNotification_MinorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_MinorVersion_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_MinorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (int)LassoLibFederationTerminationNotification_MinorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_private_key_file_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_private_key_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibFederationTerminationNotification_private_key_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_private_key_file_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_private_key_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (char *)LassoLibFederationTerminationNotification_private_key_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_RequestID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_RequestID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibFederationTerminationNotification_RequestID_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_RequestID_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_RequestID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (char *)LassoLibFederationTerminationNotification_RequestID_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_RespondWith_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_RespondWith_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_RespondWith_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibFederationTerminationNotification_RespondWith_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_RespondWith_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_RespondWith_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (LassoStringList *)LassoLibFederationTerminationNotification_RespondWith_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_sign_method_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    LassoSignatureMethod arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_sign_method_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (LassoSignatureMethod) Z_LVAL_PP(&value);
    
    LassoLibFederationTerminationNotification_sign_method_set(arg1,(LassoSignatureMethod )arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_sign_method_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    LassoSignatureMethod result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_sign_method_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (LassoSignatureMethod)LassoLibFederationTerminationNotification_sign_method_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_sign_type_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    LassoSignatureType arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_sign_type_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_sign_type_set. Expected %s", 2-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg2 = *argp;
    }
    LassoLibFederationTerminationNotification_sign_type_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_sign_type_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    LassoSignatureType result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_sign_type_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = LassoLibFederationTerminationNotification_sign_type_get(arg1);
    
    {
        LassoSignatureType * resultobj = (LassoSignatureType *) emalloc(sizeof(LassoSignatureType));
        memmove(resultobj, &result, sizeof(LassoSignatureType));
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_LassoSignatureType, 0);
    }
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_Extension_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_Extension_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_Extension_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibFederationTerminationNotification_Extension_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_Extension_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_Extension_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (LassoStringList *)LassoLibFederationTerminationNotification_Extension_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibFederationTerminationNotification_NameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_NameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_NameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoLibFederationTerminationNotification_NameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibFederationTerminationNotification_NameIdentifier_get(zend_property_reference *property_reference) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_NameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoLibFederationTerminationNotification_NameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLibFederationTerminationNotification) {
    LassoLibFederationTerminationNotification *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoLibFederationTerminationNotification *)new_LassoLibFederationTerminationNotification();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibFederationTerminationNotification, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibFederationTerminationNotification);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLibFederationTerminationNotification(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLibFederationTerminationNotification TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLibFederationTerminationNotification resource already free'd");
    delete_LassoLibFederationTerminationNotification(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLibFederationTerminationNotification) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLibFederationTerminationNotification. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLibFederationTerminationNotification(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibFederationTerminationNotification_newFull) {
    char *arg1 = (char *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    LassoSignatureType arg3 ;
    LassoSignatureMethod arg4 ;
    LassoLibFederationTerminationNotification *result;
    zval **args[5];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 4) || (zend_get_parameters_array_ex(4-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    
    if (SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*args[1-argbase])->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_newFull. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*args[2-argbase], (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_newFull. Expected %s", 3-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg3 = *argp;
    }
    
    convert_to_long_ex(args[3-argbase]);
    arg4 = (LassoSignatureMethod) Z_LVAL_PP(args[3-argbase]);
    
    result = (LassoLibFederationTerminationNotification *)LassoLibFederationTerminationNotification_newFull(arg1,arg2,arg3,(LassoSignatureMethod )arg4);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibFederationTerminationNotification, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibFederationTerminationNotification);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibFederationTerminationNotification_dump) {
    LassoLibFederationTerminationNotification *arg1 = (LassoLibFederationTerminationNotification *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibFederationTerminationNotification) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibFederationTerminationNotification_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibFederationTerminationNotification->name);
    }
    
    result = (char *)LassoLibFederationTerminationNotification_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoLibFederationTerminationNotification */
static pval _wrap_propget_LassoLibFederationTerminationNotification(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLibFederationTerminationNotification(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLibFederationTerminationNotification(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"MajorVersion")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_MajorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"consent")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_consent_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_method")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_sign_method_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"private_key_file")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_private_key_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_type")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_sign_type_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RequestID")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_RequestID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"NameIdentifier")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_NameIdentifier_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"certificate_file")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_certificate_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RelayState")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_RelayState_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ProviderID")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_ProviderID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MinorVersion")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_MinorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RespondWith")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_RespondWith_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Extension")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_Extension_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"IssueInstant")==0) {
    *value=_wrap_LassoLibFederationTerminationNotification_IssueInstant_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLibFederationTerminationNotification(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLibFederationTerminationNotification(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLibFederationTerminationNotification */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLibFederationTerminationNotification(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"MajorVersion")==0) {
    return _wrap_LassoLibFederationTerminationNotification_MajorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"consent")==0) {
    return _wrap_LassoLibFederationTerminationNotification_consent_set(property_reference, value);
  } else  if (strcmp(propname,"sign_method")==0) {
    return _wrap_LassoLibFederationTerminationNotification_sign_method_set(property_reference, value);
  } else  if (strcmp(propname,"private_key_file")==0) {
    return _wrap_LassoLibFederationTerminationNotification_private_key_file_set(property_reference, value);
  } else  if (strcmp(propname,"sign_type")==0) {
    return _wrap_LassoLibFederationTerminationNotification_sign_type_set(property_reference, value);
  } else  if (strcmp(propname,"RequestID")==0) {
    return _wrap_LassoLibFederationTerminationNotification_RequestID_set(property_reference, value);
  } else  if (strcmp(propname,"NameIdentifier")==0) {
    return _wrap_LassoLibFederationTerminationNotification_NameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"certificate_file")==0) {
    return _wrap_LassoLibFederationTerminationNotification_certificate_file_set(property_reference, value);
  } else  if (strcmp(propname,"RelayState")==0) {
    return _wrap_LassoLibFederationTerminationNotification_RelayState_set(property_reference, value);
  } else  if (strcmp(propname,"ProviderID")==0) {
    return _wrap_LassoLibFederationTerminationNotification_ProviderID_set(property_reference, value);
  } else  if (strcmp(propname,"MinorVersion")==0) {
    return _wrap_LassoLibFederationTerminationNotification_MinorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"RespondWith")==0) {
    return _wrap_LassoLibFederationTerminationNotification_RespondWith_set(property_reference, value);
  } else  if (strcmp(propname,"Extension")==0) {
    return _wrap_LassoLibFederationTerminationNotification_Extension_set(property_reference, value);
  } else  if (strcmp(propname,"IssueInstant")==0) {
    return _wrap_LassoLibFederationTerminationNotification_IssueInstant_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoLibLogoutRequest_consent_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_consent_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->consent) free((char*)arg1->consent);
        if (arg2) {
            arg1->consent = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->consent,arg2);
        } else {
            arg1->consent = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_consent_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_consent_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (char *) ((arg1)->consent);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_NotOnOrAfter_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_NotOnOrAfter_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->NotOnOrAfter) free((char*)arg1->NotOnOrAfter);
        if (arg2) {
            arg1->NotOnOrAfter = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->NotOnOrAfter,arg2);
        } else {
            arg1->NotOnOrAfter = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_NotOnOrAfter_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_NotOnOrAfter_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (char *) ((arg1)->NotOnOrAfter);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_ProviderID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_ProviderID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->ProviderID) free((char*)arg1->ProviderID);
        if (arg2) {
            arg1->ProviderID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->ProviderID,arg2);
        } else {
            arg1->ProviderID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_ProviderID_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_ProviderID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (char *) ((arg1)->ProviderID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_RelayState_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_RelayState_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->RelayState) free((char*)arg1->RelayState);
        if (arg2) {
            arg1->RelayState = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->RelayState,arg2);
        } else {
            arg1->RelayState = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_RelayState_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_RelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (char *) ((arg1)->RelayState);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_SessionIndex_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_SessionIndex_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->SessionIndex) free((char*)arg1->SessionIndex);
        if (arg2) {
            arg1->SessionIndex = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->SessionIndex,arg2);
        } else {
            arg1->SessionIndex = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_SessionIndex_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_SessionIndex_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (char *) ((arg1)->SessionIndex);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_certificate_file_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_certificate_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibLogoutRequest_certificate_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_certificate_file_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_certificate_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (char *)LassoLibLogoutRequest_certificate_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_IssueInstant_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_IssueInstant_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibLogoutRequest_IssueInstant_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_IssueInstant_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_IssueInstant_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (char *)LassoLibLogoutRequest_IssueInstant_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_MajorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_MajorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoLibLogoutRequest_MajorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_MajorVersion_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_MajorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (int)LassoLibLogoutRequest_MajorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_MinorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_MinorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoLibLogoutRequest_MinorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_MinorVersion_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_MinorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (int)LassoLibLogoutRequest_MinorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_private_key_file_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_private_key_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibLogoutRequest_private_key_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_private_key_file_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_private_key_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (char *)LassoLibLogoutRequest_private_key_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_RequestID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_RequestID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibLogoutRequest_RequestID_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_RequestID_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_RequestID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (char *)LassoLibLogoutRequest_RequestID_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_RespondWith_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_RespondWith_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_RespondWith_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibLogoutRequest_RespondWith_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_RespondWith_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_RespondWith_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (LassoStringList *)LassoLibLogoutRequest_RespondWith_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_sign_method_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    LassoSignatureMethod arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_sign_method_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (LassoSignatureMethod) Z_LVAL_PP(&value);
    
    LassoLibLogoutRequest_sign_method_set(arg1,(LassoSignatureMethod )arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_sign_method_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    LassoSignatureMethod result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_sign_method_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (LassoSignatureMethod)LassoLibLogoutRequest_sign_method_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_sign_type_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    LassoSignatureType arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_sign_type_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_sign_type_set. Expected %s", 2-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg2 = *argp;
    }
    LassoLibLogoutRequest_sign_type_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_sign_type_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    LassoSignatureType result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_sign_type_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = LassoLibLogoutRequest_sign_type_get(arg1);
    
    {
        LassoSignatureType * resultobj = (LassoSignatureType *) emalloc(sizeof(LassoSignatureType));
        memmove(resultobj, &result, sizeof(LassoSignatureType));
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_LassoSignatureType, 0);
    }
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_Extension_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_Extension_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_Extension_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibLogoutRequest_Extension_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_Extension_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_Extension_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (LassoStringList *)LassoLibLogoutRequest_Extension_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibLogoutRequest_NameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_NameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_NameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoLibLogoutRequest_NameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutRequest_NameIdentifier_get(zend_property_reference *property_reference) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_NameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoLibLogoutRequest_NameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLibLogoutRequest) {
    LassoLibLogoutRequest *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoLibLogoutRequest *)new_LassoLibLogoutRequest();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibLogoutRequest, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibLogoutRequest);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLibLogoutRequest(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLibLogoutRequest TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLibLogoutRequest resource already free'd");
    delete_LassoLibLogoutRequest(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLibLogoutRequest) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLibLogoutRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLibLogoutRequest(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibLogoutRequest_newFull) {
    char *arg1 = (char *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    LassoSignatureType arg3 ;
    LassoSignatureMethod arg4 ;
    LassoLibLogoutRequest *result;
    zval **args[5];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 4) || (zend_get_parameters_array_ex(4-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    
    if (SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*args[1-argbase])->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_newFull. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*args[2-argbase], (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_newFull. Expected %s", 3-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg3 = *argp;
    }
    
    convert_to_long_ex(args[3-argbase]);
    arg4 = (LassoSignatureMethod) Z_LVAL_PP(args[3-argbase]);
    
    result = (LassoLibLogoutRequest *)LassoLibLogoutRequest_newFull(arg1,arg2,arg3,(LassoSignatureMethod )arg4);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibLogoutRequest, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibLogoutRequest);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibLogoutRequest_dump) {
    LassoLibLogoutRequest *arg1 = (LassoLibLogoutRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutRequest_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    result = (char *)LassoLibLogoutRequest_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoLibLogoutRequest */
static pval _wrap_propget_LassoLibLogoutRequest(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLibLogoutRequest(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLibLogoutRequest(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"sign_method")==0) {
    *value=_wrap_LassoLibLogoutRequest_sign_method_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"NotOnOrAfter")==0) {
    *value=_wrap_LassoLibLogoutRequest_NotOnOrAfter_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"IssueInstant")==0) {
    *value=_wrap_LassoLibLogoutRequest_IssueInstant_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"consent")==0) {
    *value=_wrap_LassoLibLogoutRequest_consent_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"NameIdentifier")==0) {
    *value=_wrap_LassoLibLogoutRequest_NameIdentifier_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_type")==0) {
    *value=_wrap_LassoLibLogoutRequest_sign_type_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RequestID")==0) {
    *value=_wrap_LassoLibLogoutRequest_RequestID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ProviderID")==0) {
    *value=_wrap_LassoLibLogoutRequest_ProviderID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RespondWith")==0) {
    *value=_wrap_LassoLibLogoutRequest_RespondWith_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MinorVersion")==0) {
    *value=_wrap_LassoLibLogoutRequest_MinorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MajorVersion")==0) {
    *value=_wrap_LassoLibLogoutRequest_MajorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"SessionIndex")==0) {
    *value=_wrap_LassoLibLogoutRequest_SessionIndex_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Extension")==0) {
    *value=_wrap_LassoLibLogoutRequest_Extension_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RelayState")==0) {
    *value=_wrap_LassoLibLogoutRequest_RelayState_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"private_key_file")==0) {
    *value=_wrap_LassoLibLogoutRequest_private_key_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"certificate_file")==0) {
    *value=_wrap_LassoLibLogoutRequest_certificate_file_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLibLogoutRequest(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLibLogoutRequest(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLibLogoutRequest */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLibLogoutRequest(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"IssueInstant")==0) {
    return _wrap_LassoLibLogoutRequest_IssueInstant_set(property_reference, value);
  } else  if (strcmp(propname,"consent")==0) {
    return _wrap_LassoLibLogoutRequest_consent_set(property_reference, value);
  } else  if (strcmp(propname,"NameIdentifier")==0) {
    return _wrap_LassoLibLogoutRequest_NameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"sign_type")==0) {
    return _wrap_LassoLibLogoutRequest_sign_type_set(property_reference, value);
  } else  if (strcmp(propname,"RequestID")==0) {
    return _wrap_LassoLibLogoutRequest_RequestID_set(property_reference, value);
  } else  if (strcmp(propname,"ProviderID")==0) {
    return _wrap_LassoLibLogoutRequest_ProviderID_set(property_reference, value);
  } else  if (strcmp(propname,"RespondWith")==0) {
    return _wrap_LassoLibLogoutRequest_RespondWith_set(property_reference, value);
  } else  if (strcmp(propname,"MinorVersion")==0) {
    return _wrap_LassoLibLogoutRequest_MinorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"MajorVersion")==0) {
    return _wrap_LassoLibLogoutRequest_MajorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"SessionIndex")==0) {
    return _wrap_LassoLibLogoutRequest_SessionIndex_set(property_reference, value);
  } else  if (strcmp(propname,"Extension")==0) {
    return _wrap_LassoLibLogoutRequest_Extension_set(property_reference, value);
  } else  if (strcmp(propname,"RelayState")==0) {
    return _wrap_LassoLibLogoutRequest_RelayState_set(property_reference, value);
  } else  if (strcmp(propname,"private_key_file")==0) {
    return _wrap_LassoLibLogoutRequest_private_key_file_set(property_reference, value);
  } else  if (strcmp(propname,"certificate_file")==0) {
    return _wrap_LassoLibLogoutRequest_certificate_file_set(property_reference, value);
  } else  if (strcmp(propname,"NotOnOrAfter")==0) {
    return _wrap_LassoLibLogoutRequest_NotOnOrAfter_set(property_reference, value);
  } else  if (strcmp(propname,"sign_method")==0) {
    return _wrap_LassoLibLogoutRequest_sign_method_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoLibLogoutResponse_Extension_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutResponse *arg1 = (LassoLibLogoutResponse *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_Extension_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutResponse->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_Extension_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibLogoutResponse_Extension_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutResponse_Extension_get(zend_property_reference *property_reference) {
    LassoLibLogoutResponse *arg1 = (LassoLibLogoutResponse *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_Extension_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutResponse->name);
    }
    
    result = (LassoStringList *)LassoLibLogoutResponse_Extension_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibLogoutResponse_ProviderID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutResponse *arg1 = (LassoLibLogoutResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_ProviderID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibLogoutResponse_ProviderID_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutResponse_ProviderID_get(zend_property_reference *property_reference) {
    LassoLibLogoutResponse *arg1 = (LassoLibLogoutResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_ProviderID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutResponse->name);
    }
    
    result = (char *)LassoLibLogoutResponse_ProviderID_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibLogoutResponse_RelayState_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutResponse *arg1 = (LassoLibLogoutResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_RelayState_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibLogoutResponse_RelayState_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutResponse_RelayState_get(zend_property_reference *property_reference) {
    LassoLibLogoutResponse *arg1 = (LassoLibLogoutResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_RelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutResponse->name);
    }
    
    result = (char *)LassoLibLogoutResponse_RelayState_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibLogoutResponse_Status_set(zend_property_reference *property_reference, pval *value) {
    LassoLibLogoutResponse *arg1 = (LassoLibLogoutResponse *) 0 ;
    LassoSamlpStatus *arg2 = (LassoSamlpStatus *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_Status_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutResponse->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlpStatus) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_Status_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlpStatus->name);
    }
    
    LassoLibLogoutResponse_Status_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibLogoutResponse_Status_get(zend_property_reference *property_reference) {
    LassoLibLogoutResponse *arg1 = (LassoLibLogoutResponse *) 0 ;
    LassoSamlpStatus *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_Status_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutResponse->name);
    }
    
    result = (LassoSamlpStatus *)LassoLibLogoutResponse_Status_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlpStatus, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlpStatus);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLibLogoutResponse) {
    LassoLibLogoutResponse *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoLibLogoutResponse *)new_LassoLibLogoutResponse();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibLogoutResponse, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibLogoutResponse);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLibLogoutResponse(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLibLogoutResponse *arg1 = (LassoLibLogoutResponse *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLibLogoutResponse TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLibLogoutResponse resource already free'd");
    delete_LassoLibLogoutResponse(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLibLogoutResponse) {
    LassoLibLogoutResponse *arg1 = (LassoLibLogoutResponse *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutResponse) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLibLogoutResponse. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutResponse->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLibLogoutResponse(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibLogoutResponse_newFull) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    LassoLibLogoutRequest *arg3 = (LassoLibLogoutRequest *) 0 ;
    LassoSignatureType arg4 ;
    LassoSignatureMethod arg5 ;
    LassoLibLogoutResponse *result;
    zval **args[6];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 5) || (zend_get_parameters_array_ex(5-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    if (SWIG_ConvertPtr(*args[2-argbase], (void **) &arg3, SWIGTYPE_p_LassoLibLogoutRequest) < 0) {
        if ((*args[2-argbase])->type == IS_NULL)
        arg3 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_newFull. Expected %s",
        3-argbase, SWIGTYPE_p_LassoLibLogoutRequest->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*args[3-argbase], (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_newFull. Expected %s", 4-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg4 = *argp;
    }
    
    convert_to_long_ex(args[4-argbase]);
    arg5 = (LassoSignatureMethod) Z_LVAL_PP(args[4-argbase]);
    
    result = (LassoLibLogoutResponse *)LassoLibLogoutResponse_newFull(arg1,(char const *)arg2,arg3,arg4,(LassoSignatureMethod )arg5);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibLogoutResponse, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibLogoutResponse);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibLogoutResponse_dump) {
    LassoLibLogoutResponse *arg1 = (LassoLibLogoutResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibLogoutResponse) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibLogoutResponse_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibLogoutResponse->name);
    }
    
    result = (char *)LassoLibLogoutResponse_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoLibLogoutResponse */
static pval _wrap_propget_LassoLibLogoutResponse(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLibLogoutResponse(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLibLogoutResponse(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Status")==0) {
    *value=_wrap_LassoLibLogoutResponse_Status_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Extension")==0) {
    *value=_wrap_LassoLibLogoutResponse_Extension_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ProviderID")==0) {
    *value=_wrap_LassoLibLogoutResponse_ProviderID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RelayState")==0) {
    *value=_wrap_LassoLibLogoutResponse_RelayState_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLibLogoutResponse(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLibLogoutResponse(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLibLogoutResponse */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLibLogoutResponse(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"ProviderID")==0) {
    return _wrap_LassoLibLogoutResponse_ProviderID_set(property_reference, value);
  } else  if (strcmp(propname,"RelayState")==0) {
    return _wrap_LassoLibLogoutResponse_RelayState_set(property_reference, value);
  } else  if (strcmp(propname,"Status")==0) {
    return _wrap_LassoLibLogoutResponse_Status_set(property_reference, value);
  } else  if (strcmp(propname,"Extension")==0) {
    return _wrap_LassoLibLogoutResponse_Extension_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoLibRegisterNameIdentifierRequest_ProviderID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_ProviderID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->ProviderID) free((char*)arg1->ProviderID);
        if (arg2) {
            arg1->ProviderID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->ProviderID,arg2);
        } else {
            arg1->ProviderID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_ProviderID_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_ProviderID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (char *) ((arg1)->ProviderID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_RelayState_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_RelayState_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->RelayState) free((char*)arg1->RelayState);
        if (arg2) {
            arg1->RelayState = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->RelayState,arg2);
        } else {
            arg1->RelayState = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_RelayState_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_RelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (char *) ((arg1)->RelayState);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_certificate_file_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_certificate_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibRegisterNameIdentifierRequest_certificate_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_certificate_file_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_certificate_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (char *)LassoLibRegisterNameIdentifierRequest_certificate_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_IssueInstant_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_IssueInstant_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibRegisterNameIdentifierRequest_IssueInstant_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_IssueInstant_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_IssueInstant_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (char *)LassoLibRegisterNameIdentifierRequest_IssueInstant_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_MajorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_MajorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoLibRegisterNameIdentifierRequest_MajorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_MajorVersion_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_MajorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (int)LassoLibRegisterNameIdentifierRequest_MajorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_MinorVersion_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_MinorVersion_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (int) Z_LVAL_PP(&value);
    
    LassoLibRegisterNameIdentifierRequest_MinorVersion_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_MinorVersion_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_MinorVersion_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (int)LassoLibRegisterNameIdentifierRequest_MinorVersion_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_private_key_file_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_private_key_file_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibRegisterNameIdentifierRequest_private_key_file_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_private_key_file_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_private_key_file_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (char *)LassoLibRegisterNameIdentifierRequest_private_key_file_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_RequestID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_RequestID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibRegisterNameIdentifierRequest_RequestID_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_RequestID_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_RequestID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (char *)LassoLibRegisterNameIdentifierRequest_RequestID_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_RespondWith_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_RespondWith_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_RespondWith_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibRegisterNameIdentifierRequest_RespondWith_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_RespondWith_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_RespondWith_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (LassoStringList *)LassoLibRegisterNameIdentifierRequest_RespondWith_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_sign_method_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoSignatureMethod arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_sign_method_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (LassoSignatureMethod) Z_LVAL_PP(&value);
    
    LassoLibRegisterNameIdentifierRequest_sign_method_set(arg1,(LassoSignatureMethod )arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_sign_method_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoSignatureMethod result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_sign_method_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (LassoSignatureMethod)LassoLibRegisterNameIdentifierRequest_sign_method_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_sign_type_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoSignatureType arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_sign_type_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_sign_type_set. Expected %s", 2-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg2 = *argp;
    }
    LassoLibRegisterNameIdentifierRequest_sign_type_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_sign_type_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoSignatureType result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_sign_type_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = LassoLibRegisterNameIdentifierRequest_sign_type_get(arg1);
    
    {
        LassoSignatureType * resultobj = (LassoSignatureType *) emalloc(sizeof(LassoSignatureType));
        memmove(resultobj, &result, sizeof(LassoSignatureType));
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_LassoSignatureType, 0);
    }
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_Extension_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_Extension_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_Extension_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibRegisterNameIdentifierRequest_Extension_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_Extension_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_Extension_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (LassoStringList *)LassoLibRegisterNameIdentifierRequest_Extension_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_IDPProvidedNameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_IDPProvidedNameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_IDPProvidedNameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoLibRegisterNameIdentifierRequest_IDPProvidedNameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_IDPProvidedNameIdentifier_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_IDPProvidedNameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoLibRegisterNameIdentifierRequest_IDPProvidedNameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_OldProvidedNameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_OldProvidedNameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_OldProvidedNameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoLibRegisterNameIdentifierRequest_OldProvidedNameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_OldProvidedNameIdentifier_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_OldProvidedNameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoLibRegisterNameIdentifierRequest_OldProvidedNameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierRequest_SPProvidedNameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_SPProvidedNameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_SPProvidedNameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoLibRegisterNameIdentifierRequest_SPProvidedNameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierRequest_SPProvidedNameIdentifier_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_SPProvidedNameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoLibRegisterNameIdentifierRequest_SPProvidedNameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLibRegisterNameIdentifierRequest) {
    LassoLibRegisterNameIdentifierRequest *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoLibRegisterNameIdentifierRequest *)new_LassoLibRegisterNameIdentifierRequest();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibRegisterNameIdentifierRequest);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLibRegisterNameIdentifierRequest(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLibRegisterNameIdentifierRequest resource already free'd");
    delete_LassoLibRegisterNameIdentifierRequest(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLibRegisterNameIdentifierRequest) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLibRegisterNameIdentifierRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLibRegisterNameIdentifierRequest(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibRegisterNameIdentifierRequest_newFull) {
    char *arg1 = (char *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    LassoSamlNameIdentifier *arg3 = (LassoSamlNameIdentifier *) 0 ;
    LassoSamlNameIdentifier *arg4 = (LassoSamlNameIdentifier *) 0 ;
    LassoSignatureType arg5 ;
    LassoSignatureMethod arg6 ;
    LassoLibRegisterNameIdentifierRequest *result;
    zval **args[7];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 6) || (zend_get_parameters_array_ex(6-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    
    if (SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*args[1-argbase])->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_newFull. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    
    if (SWIG_ConvertPtr(*args[2-argbase], (void **) &arg3, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*args[2-argbase])->type == IS_NULL)
        arg3 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_newFull. Expected %s",
        3-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    
    if (SWIG_ConvertPtr(*args[3-argbase], (void **) &arg4, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*args[3-argbase])->type == IS_NULL)
        arg4 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_newFull. Expected %s",
        4-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*args[4-argbase], (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_newFull. Expected %s", 5-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg5 = *argp;
    }
    
    convert_to_long_ex(args[5-argbase]);
    arg6 = (LassoSignatureMethod) Z_LVAL_PP(args[5-argbase]);
    
    result = (LassoLibRegisterNameIdentifierRequest *)LassoLibRegisterNameIdentifierRequest_newFull(arg1,arg2,arg3,arg4,arg5,(LassoSignatureMethod )arg6);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibRegisterNameIdentifierRequest);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibRegisterNameIdentifierRequest_dump) {
    LassoLibRegisterNameIdentifierRequest *arg1 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierRequest_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    result = (char *)LassoLibRegisterNameIdentifierRequest_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoLibRegisterNameIdentifierRequest */
static pval _wrap_propget_LassoLibRegisterNameIdentifierRequest(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLibRegisterNameIdentifierRequest(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLibRegisterNameIdentifierRequest(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"IssueInstant")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_IssueInstant_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ProviderID")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_ProviderID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RequestID")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_RequestID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"certificate_file")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_certificate_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RespondWith")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_RespondWith_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"SPProvidedNameIdentifier")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_SPProvidedNameIdentifier_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"private_key_file")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_private_key_file_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MinorVersion")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_MinorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"MajorVersion")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_MajorVersion_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RelayState")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_RelayState_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_type")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_sign_type_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sign_method")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_sign_method_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"OldProvidedNameIdentifier")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_OldProvidedNameIdentifier_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"IDPProvidedNameIdentifier")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_IDPProvidedNameIdentifier_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Extension")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierRequest_Extension_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLibRegisterNameIdentifierRequest(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLibRegisterNameIdentifierRequest(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLibRegisterNameIdentifierRequest */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLibRegisterNameIdentifierRequest(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"IssueInstant")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_IssueInstant_set(property_reference, value);
  } else  if (strcmp(propname,"certificate_file")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_certificate_file_set(property_reference, value);
  } else  if (strcmp(propname,"RespondWith")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_RespondWith_set(property_reference, value);
  } else  if (strcmp(propname,"sign_type")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_sign_type_set(property_reference, value);
  } else  if (strcmp(propname,"RelayState")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_RelayState_set(property_reference, value);
  } else  if (strcmp(propname,"SPProvidedNameIdentifier")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_SPProvidedNameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"private_key_file")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_private_key_file_set(property_reference, value);
  } else  if (strcmp(propname,"Extension")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_Extension_set(property_reference, value);
  } else  if (strcmp(propname,"MinorVersion")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_MinorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"MajorVersion")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_MajorVersion_set(property_reference, value);
  } else  if (strcmp(propname,"sign_method")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_sign_method_set(property_reference, value);
  } else  if (strcmp(propname,"RequestID")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_RequestID_set(property_reference, value);
  } else  if (strcmp(propname,"ProviderID")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_ProviderID_set(property_reference, value);
  } else  if (strcmp(propname,"OldProvidedNameIdentifier")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_OldProvidedNameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"IDPProvidedNameIdentifier")==0) {
    return _wrap_LassoLibRegisterNameIdentifierRequest_IDPProvidedNameIdentifier_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoLibRegisterNameIdentifierResponse_Extension_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierResponse *arg1 = (LassoLibRegisterNameIdentifierResponse *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_Extension_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_Extension_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibRegisterNameIdentifierResponse_Extension_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierResponse_Extension_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierResponse *arg1 = (LassoLibRegisterNameIdentifierResponse *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_Extension_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse->name);
    }
    
    result = (LassoStringList *)LassoLibRegisterNameIdentifierResponse_Extension_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierResponse_ProviderID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierResponse *arg1 = (LassoLibRegisterNameIdentifierResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_ProviderID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibRegisterNameIdentifierResponse_ProviderID_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierResponse_ProviderID_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierResponse *arg1 = (LassoLibRegisterNameIdentifierResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_ProviderID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse->name);
    }
    
    result = (char *)LassoLibRegisterNameIdentifierResponse_ProviderID_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierResponse_RelayState_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierResponse *arg1 = (LassoLibRegisterNameIdentifierResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_RelayState_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLibRegisterNameIdentifierResponse_RelayState_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierResponse_RelayState_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierResponse *arg1 = (LassoLibRegisterNameIdentifierResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_RelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse->name);
    }
    
    result = (char *)LassoLibRegisterNameIdentifierResponse_RelayState_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibRegisterNameIdentifierResponse_Status_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRegisterNameIdentifierResponse *arg1 = (LassoLibRegisterNameIdentifierResponse *) 0 ;
    LassoSamlpStatus *arg2 = (LassoSamlpStatus *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_Status_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlpStatus) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_Status_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlpStatus->name);
    }
    
    LassoLibRegisterNameIdentifierResponse_Status_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRegisterNameIdentifierResponse_Status_get(zend_property_reference *property_reference) {
    LassoLibRegisterNameIdentifierResponse *arg1 = (LassoLibRegisterNameIdentifierResponse *) 0 ;
    LassoSamlpStatus *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_Status_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse->name);
    }
    
    result = (LassoSamlpStatus *)LassoLibRegisterNameIdentifierResponse_Status_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlpStatus, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlpStatus);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLibRegisterNameIdentifierResponse) {
    LassoLibRegisterNameIdentifierResponse *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoLibRegisterNameIdentifierResponse *)new_LassoLibRegisterNameIdentifierResponse();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibRegisterNameIdentifierResponse);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLibRegisterNameIdentifierResponse(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLibRegisterNameIdentifierResponse *arg1 = (LassoLibRegisterNameIdentifierResponse *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLibRegisterNameIdentifierResponse resource already free'd");
    delete_LassoLibRegisterNameIdentifierResponse(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLibRegisterNameIdentifierResponse) {
    LassoLibRegisterNameIdentifierResponse *arg1 = (LassoLibRegisterNameIdentifierResponse *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLibRegisterNameIdentifierResponse. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLibRegisterNameIdentifierResponse(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibRegisterNameIdentifierResponse_newFull) {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    LassoLibRegisterNameIdentifierRequest *arg3 = (LassoLibRegisterNameIdentifierRequest *) 0 ;
    LassoSignatureType arg4 ;
    LassoSignatureMethod arg5 ;
    LassoLibRegisterNameIdentifierResponse *result;
    zval **args[6];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 5) || (zend_get_parameters_array_ex(5-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    if (SWIG_ConvertPtr(*args[2-argbase], (void **) &arg3, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest) < 0) {
        if ((*args[2-argbase])->type == IS_NULL)
        arg3 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_newFull. Expected %s",
        3-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name);
    }
    
    {
        LassoSignatureType * argp;
        if(SWIG_ConvertPtr(*args[3-argbase], (void **) &argp, SWIGTYPE_p_LassoSignatureType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_newFull. Expected %s", 4-argbase, SWIGTYPE_p_LassoSignatureType->name);
        }
        arg4 = *argp;
    }
    
    convert_to_long_ex(args[4-argbase]);
    arg5 = (LassoSignatureMethod) Z_LVAL_PP(args[4-argbase]);
    
    result = (LassoLibRegisterNameIdentifierResponse *)LassoLibRegisterNameIdentifierResponse_newFull(arg1,arg2,arg3,arg4,(LassoSignatureMethod )arg5);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibRegisterNameIdentifierResponse);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibRegisterNameIdentifierResponse_dump) {
    LassoLibRegisterNameIdentifierResponse *arg1 = (LassoLibRegisterNameIdentifierResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRegisterNameIdentifierResponse_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse->name);
    }
    
    result = (char *)LassoLibRegisterNameIdentifierResponse_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoLibRegisterNameIdentifierResponse */
static pval _wrap_propget_LassoLibRegisterNameIdentifierResponse(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLibRegisterNameIdentifierResponse(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLibRegisterNameIdentifierResponse(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"RelayState")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierResponse_RelayState_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Status")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierResponse_Status_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ProviderID")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierResponse_ProviderID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Extension")==0) {
    *value=_wrap_LassoLibRegisterNameIdentifierResponse_Extension_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLibRegisterNameIdentifierResponse(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLibRegisterNameIdentifierResponse(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLibRegisterNameIdentifierResponse */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLibRegisterNameIdentifierResponse(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"RelayState")==0) {
    return _wrap_LassoLibRegisterNameIdentifierResponse_RelayState_set(property_reference, value);
  } else  if (strcmp(propname,"ProviderID")==0) {
    return _wrap_LassoLibRegisterNameIdentifierResponse_ProviderID_set(property_reference, value);
  } else  if (strcmp(propname,"Extension")==0) {
    return _wrap_LassoLibRegisterNameIdentifierResponse_Extension_set(property_reference, value);
  } else  if (strcmp(propname,"Status")==0) {
    return _wrap_LassoLibRegisterNameIdentifierResponse_Status_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoLibRequestAuthnContext_AuthnContextComparison_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRequestAuthnContext *arg1 = (LassoLibRequestAuthnContext *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRequestAuthnContext) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRequestAuthnContext_AuthnContextComparison_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRequestAuthnContext->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->AuthnContextComparison) free((char*)arg1->AuthnContextComparison);
        if (arg2) {
            arg1->AuthnContextComparison = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->AuthnContextComparison,arg2);
        } else {
            arg1->AuthnContextComparison = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibRequestAuthnContext_AuthnContextComparison_get(zend_property_reference *property_reference) {
    LassoLibRequestAuthnContext *arg1 = (LassoLibRequestAuthnContext *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRequestAuthnContext) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRequestAuthnContext_AuthnContextComparison_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRequestAuthnContext->name);
    }
    
    result = (char *) ((arg1)->AuthnContextComparison);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibRequestAuthnContext_authnContextClassRef_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRequestAuthnContext *arg1 = (LassoLibRequestAuthnContext *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRequestAuthnContext) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRequestAuthnContext_authnContextClassRef_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRequestAuthnContext->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRequestAuthnContext_authnContextClassRef_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibRequestAuthnContext_authnContextClassRef_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRequestAuthnContext_authnContextClassRef_get(zend_property_reference *property_reference) {
    LassoLibRequestAuthnContext *arg1 = (LassoLibRequestAuthnContext *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRequestAuthnContext) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRequestAuthnContext_authnContextClassRef_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRequestAuthnContext->name);
    }
    
    result = (LassoStringList *)LassoLibRequestAuthnContext_authnContextClassRef_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibRequestAuthnContext_authnContextStatementRef_set(zend_property_reference *property_reference, pval *value) {
    LassoLibRequestAuthnContext *arg1 = (LassoLibRequestAuthnContext *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRequestAuthnContext) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRequestAuthnContext_authnContextStatementRef_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRequestAuthnContext->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRequestAuthnContext_authnContextStatementRef_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibRequestAuthnContext_authnContextStatementRef_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibRequestAuthnContext_authnContextStatementRef_get(zend_property_reference *property_reference) {
    LassoLibRequestAuthnContext *arg1 = (LassoLibRequestAuthnContext *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibRequestAuthnContext) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRequestAuthnContext_authnContextStatementRef_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRequestAuthnContext->name);
    }
    
    result = (LassoStringList *)LassoLibRequestAuthnContext_authnContextStatementRef_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLibRequestAuthnContext) {
    LassoLibRequestAuthnContext *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoLibRequestAuthnContext *)new_LassoLibRequestAuthnContext();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibRequestAuthnContext, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibRequestAuthnContext);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLibRequestAuthnContext(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLibRequestAuthnContext *arg1 = (LassoLibRequestAuthnContext *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLibRequestAuthnContext TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLibRequestAuthnContext resource already free'd");
    delete_LassoLibRequestAuthnContext(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLibRequestAuthnContext) {
    LassoLibRequestAuthnContext *arg1 = (LassoLibRequestAuthnContext *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibRequestAuthnContext) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLibRequestAuthnContext. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRequestAuthnContext->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLibRequestAuthnContext(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibRequestAuthnContext_dump) {
    LassoLibRequestAuthnContext *arg1 = (LassoLibRequestAuthnContext *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibRequestAuthnContext) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibRequestAuthnContext_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibRequestAuthnContext->name);
    }
    
    result = (char *)LassoLibRequestAuthnContext_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoLibRequestAuthnContext */
static pval _wrap_propget_LassoLibRequestAuthnContext(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLibRequestAuthnContext(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLibRequestAuthnContext(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"AuthnContextComparison")==0) {
    *value=_wrap_LassoLibRequestAuthnContext_AuthnContextComparison_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"authnContextStatementRef")==0) {
    *value=_wrap_LassoLibRequestAuthnContext_authnContextStatementRef_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"authnContextClassRef")==0) {
    *value=_wrap_LassoLibRequestAuthnContext_authnContextClassRef_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLibRequestAuthnContext(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLibRequestAuthnContext(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLibRequestAuthnContext */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLibRequestAuthnContext(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"AuthnContextComparison")==0) {
    return _wrap_LassoLibRequestAuthnContext_AuthnContextComparison_set(property_reference, value);
  } else  if (strcmp(propname,"authnContextClassRef")==0) {
    return _wrap_LassoLibRequestAuthnContext_authnContextClassRef_set(property_reference, value);
  } else  if (strcmp(propname,"authnContextStatementRef")==0) {
    return _wrap_LassoLibRequestAuthnContext_authnContextStatementRef_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoLibStatusResponse_ProviderID_set(zend_property_reference *property_reference, pval *value) {
    LassoLibStatusResponse *arg1 = (LassoLibStatusResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibStatusResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibStatusResponse_ProviderID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibStatusResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->ProviderID) free((char*)arg1->ProviderID);
        if (arg2) {
            arg1->ProviderID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->ProviderID,arg2);
        } else {
            arg1->ProviderID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibStatusResponse_ProviderID_get(zend_property_reference *property_reference) {
    LassoLibStatusResponse *arg1 = (LassoLibStatusResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibStatusResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibStatusResponse_ProviderID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibStatusResponse->name);
    }
    
    result = (char *) ((arg1)->ProviderID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibStatusResponse_RelayState_set(zend_property_reference *property_reference, pval *value) {
    LassoLibStatusResponse *arg1 = (LassoLibStatusResponse *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibStatusResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibStatusResponse_RelayState_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibStatusResponse->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->RelayState) free((char*)arg1->RelayState);
        if (arg2) {
            arg1->RelayState = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->RelayState,arg2);
        } else {
            arg1->RelayState = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoLibStatusResponse_RelayState_get(zend_property_reference *property_reference) {
    LassoLibStatusResponse *arg1 = (LassoLibStatusResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibStatusResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibStatusResponse_RelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibStatusResponse->name);
    }
    
    result = (char *) ((arg1)->RelayState);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLibStatusResponse_Extension_set(zend_property_reference *property_reference, pval *value) {
    LassoLibStatusResponse *arg1 = (LassoLibStatusResponse *) 0 ;
    LassoStringList *arg2 = (LassoStringList *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibStatusResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibStatusResponse_Extension_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibStatusResponse->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoStringList) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibStatusResponse_Extension_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoStringList->name);
    }
    
    LassoLibStatusResponse_Extension_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibStatusResponse_Extension_get(zend_property_reference *property_reference) {
    LassoLibStatusResponse *arg1 = (LassoLibStatusResponse *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibStatusResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibStatusResponse_Extension_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibStatusResponse->name);
    }
    
    result = (LassoStringList *)LassoLibStatusResponse_Extension_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLibStatusResponse_Status_set(zend_property_reference *property_reference, pval *value) {
    LassoLibStatusResponse *arg1 = (LassoLibStatusResponse *) 0 ;
    LassoSamlpStatus *arg2 = (LassoSamlpStatus *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibStatusResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibStatusResponse_Status_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibStatusResponse->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlpStatus) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibStatusResponse_Status_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlpStatus->name);
    }
    
    LassoLibStatusResponse_Status_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLibStatusResponse_Status_get(zend_property_reference *property_reference) {
    LassoLibStatusResponse *arg1 = (LassoLibStatusResponse *) 0 ;
    LassoSamlpStatus *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLibStatusResponse) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibStatusResponse_Status_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibStatusResponse->name);
    }
    
    result = (LassoSamlpStatus *)LassoLibStatusResponse_Status_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlpStatus, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlpStatus);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLibStatusResponse) {
    LassoLibStatusResponse *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoLibStatusResponse *)new_LassoLibStatusResponse();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLibStatusResponse, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLibStatusResponse);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLibStatusResponse(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLibStatusResponse *arg1 = (LassoLibStatusResponse *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLibStatusResponse TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLibStatusResponse resource already free'd");
    delete_LassoLibStatusResponse(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLibStatusResponse) {
    LassoLibStatusResponse *arg1 = (LassoLibStatusResponse *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibStatusResponse) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLibStatusResponse. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibStatusResponse->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLibStatusResponse(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLibStatusResponse_dump) {
    LassoLibStatusResponse *arg1 = (LassoLibStatusResponse *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLibStatusResponse) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLibStatusResponse_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLibStatusResponse->name);
    }
    
    result = (char *)LassoLibStatusResponse_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


/* property handler for class LassoLibStatusResponse */
static pval _wrap_propget_LassoLibStatusResponse(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLibStatusResponse(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLibStatusResponse(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Status")==0) {
    *value=_wrap_LassoLibStatusResponse_Status_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Extension")==0) {
    *value=_wrap_LassoLibStatusResponse_Extension_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ProviderID")==0) {
    *value=_wrap_LassoLibStatusResponse_ProviderID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"RelayState")==0) {
    *value=_wrap_LassoLibStatusResponse_RelayState_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLibStatusResponse(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLibStatusResponse(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLibStatusResponse */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLibStatusResponse(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"ProviderID")==0) {
    return _wrap_LassoLibStatusResponse_ProviderID_set(property_reference, value);
  } else  if (strcmp(propname,"RelayState")==0) {
    return _wrap_LassoLibStatusResponse_RelayState_set(property_reference, value);
  } else  if (strcmp(propname,"Status")==0) {
    return _wrap_LassoLibStatusResponse_Status_set(property_reference, value);
  } else  if (strcmp(propname,"Extension")==0) {
    return _wrap_LassoLibStatusResponse_Extension_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoProvider_ca_cert_chain_set(zend_property_reference *property_reference, pval *value) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_ca_cert_chain_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->ca_cert_chain) free((char*)arg1->ca_cert_chain);
        if (arg2) {
            arg1->ca_cert_chain = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->ca_cert_chain,arg2);
        } else {
            arg1->ca_cert_chain = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoProvider_ca_cert_chain_get(zend_property_reference *property_reference) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_ca_cert_chain_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    result = (char *) ((arg1)->ca_cert_chain);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoProvider_metadata_filename_set(zend_property_reference *property_reference, pval *value) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_metadata_filename_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->metadata_filename) free((char*)arg1->metadata_filename);
        if (arg2) {
            arg1->metadata_filename = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->metadata_filename,arg2);
        } else {
            arg1->metadata_filename = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoProvider_metadata_filename_get(zend_property_reference *property_reference) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_metadata_filename_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    result = (char *) ((arg1)->metadata_filename);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoProvider_ProviderID_set(zend_property_reference *property_reference, pval *value) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_ProviderID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->ProviderID) free((char*)arg1->ProviderID);
        if (arg2) {
            arg1->ProviderID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->ProviderID,arg2);
        } else {
            arg1->ProviderID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoProvider_ProviderID_get(zend_property_reference *property_reference) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_ProviderID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    result = (char *) ((arg1)->ProviderID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoProvider_public_key_set(zend_property_reference *property_reference, pval *value) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_public_key_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->public_key) free((char*)arg1->public_key);
        if (arg2) {
            arg1->public_key = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->public_key,arg2);
        } else {
            arg1->public_key = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoProvider_public_key_get(zend_property_reference *property_reference) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_public_key_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    result = (char *) ((arg1)->public_key);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoProvider_role_set(zend_property_reference *property_reference, pval *value) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    LassoProviderRole arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_role_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (LassoProviderRole) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->role = (LassoProviderRole )arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoProvider_role_get(zend_property_reference *property_reference) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    LassoProviderRole result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_role_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    result = (LassoProviderRole) ((arg1)->role);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoProvider) {
    LassoProviderRole arg1 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    LassoProvider *result;
    zval **args[5];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 4) || (zend_get_parameters_array_ex(4-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_long_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (LassoProviderRole) Z_LVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    
    convert_to_string_ex(args[3-argbase]);
    arg4 = (char *) Z_STRVAL_PP(args[3-argbase]);
    
    result = (LassoProvider *)new_LassoProvider((LassoProviderRole )arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoProvider, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoProvider);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoProvider(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoProvider TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoProvider resource already free'd");
    delete_LassoProvider(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoProvider) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoProvider. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoProvider(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoProvider_newFromDump) {
    char *arg1 = (char *) 0 ;
    LassoProvider *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    result = (LassoProvider *)LassoProvider_newFromDump(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoProvider, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoProvider);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoProvider_dump) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    result = (char *)LassoProvider_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoProvider_acceptHttpMethod) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    LassoProvider *arg2 = (LassoProvider *) 0 ;
    LassoMdProtocolType arg3 ;
    LassoHttpMethod arg4 ;
    bool arg5 ;
    bool result;
    zval **args[6];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 5) || (zend_get_parameters_array_ex(5-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_acceptHttpMethod. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    
    if (SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*args[1-argbase])->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_acceptHttpMethod. Expected %s",
        2-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    {
        LassoMdProtocolType * argp;
        if(SWIG_ConvertPtr(*args[2-argbase], (void **) &argp, SWIGTYPE_p_LassoMdProtocolType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoProvider_acceptHttpMethod. Expected %s", 3-argbase, SWIGTYPE_p_LassoMdProtocolType->name);
        }
        arg3 = *argp;
    }
    
    convert_to_long_ex(args[3-argbase]);
    arg4 = (LassoHttpMethod) Z_LVAL_PP(args[3-argbase]);
    
    
    convert_to_boolean_ex(args[4-argbase]);
    arg5 = (bool) Z_LVAL_PP(args[4-argbase]);
    
    result = (bool)LassoProvider_acceptHttpMethod(arg1,arg2,arg3,(LassoHttpMethod )arg4,arg5);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoProvider_getAssertionConsumerServiceUrl) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *arg2 = (char *) 0 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_getAssertionConsumerServiceUrl. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (char *)LassoProvider_getAssertionConsumerServiceUrl(arg1,arg2);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoProvider_getBase64SuccinctId) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_getBase64SuccinctId. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    result = (char *)LassoProvider_getBase64SuccinctId(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoProvider_getOrganization) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_getOrganization. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    result = (char *)LassoProvider_getOrganization(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoProvider_getFirstHttpMethod) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    LassoProvider *arg2 = (LassoProvider *) 0 ;
    LassoMdProtocolType arg3 ;
    LassoHttpMethod result;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_getFirstHttpMethod. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    
    if (SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*args[1-argbase])->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_getFirstHttpMethod. Expected %s",
        2-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    {
        LassoMdProtocolType * argp;
        if(SWIG_ConvertPtr(*args[2-argbase], (void **) &argp, SWIGTYPE_p_LassoMdProtocolType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoProvider_getFirstHttpMethod. Expected %s", 3-argbase, SWIGTYPE_p_LassoMdProtocolType->name);
        }
        arg3 = *argp;
    }
    result = (LassoHttpMethod)LassoProvider_getFirstHttpMethod(arg1,arg2,arg3);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoProvider_getMetadataOne) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    char *arg2 = (char *) 0 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_getMetadataOne. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (char *)LassoProvider_getMetadataOne(arg1,arg2);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoProvider_hasProtocolProfile) {
    LassoProvider *arg1 = (LassoProvider *) 0 ;
    LassoMdProtocolType arg2 ;
    char *arg3 = (char *) 0 ;
    bool result;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoProvider_hasProtocolProfile. Expected %s",
        1-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    {
        LassoMdProtocolType * argp;
        if(SWIG_ConvertPtr(*args[1-argbase], (void **) &argp, SWIGTYPE_p_LassoMdProtocolType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoProvider_hasProtocolProfile. Expected %s", 2-argbase, SWIGTYPE_p_LassoMdProtocolType->name);
        }
        arg2 = *argp;
    }
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    result = (bool)LassoProvider_hasProtocolProfile(arg1,arg2,arg3);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
}


/* property handler for class LassoProvider */
static pval _wrap_propget_LassoProvider(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoProvider(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoProvider(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"role")==0) {
    *value=_wrap_LassoProvider_role_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ca_cert_chain")==0) {
    *value=_wrap_LassoProvider_ca_cert_chain_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"metadata_filename")==0) {
    *value=_wrap_LassoProvider_metadata_filename_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ProviderID")==0) {
    *value=_wrap_LassoProvider_ProviderID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"public_key")==0) {
    *value=_wrap_LassoProvider_public_key_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoProvider(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoProvider(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoProvider */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoProvider(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"ca_cert_chain")==0) {
    return _wrap_LassoProvider_ca_cert_chain_set(property_reference, value);
  } else  if (strcmp(propname,"metadata_filename")==0) {
    return _wrap_LassoProvider_metadata_filename_set(property_reference, value);
  } else  if (strcmp(propname,"ProviderID")==0) {
    return _wrap_LassoProvider_ProviderID_set(property_reference, value);
  } else  if (strcmp(propname,"public_key")==0) {
    return _wrap_LassoProvider_public_key_set(property_reference, value);
  } else  if (strcmp(propname,"role")==0) {
    return _wrap_LassoProvider_role_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoServer_certificate_set(zend_property_reference *property_reference, pval *value) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_certificate_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->certificate) free((char*)arg1->certificate);
        if (arg2) {
            arg1->certificate = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->certificate,arg2);
        } else {
            arg1->certificate = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoServer_certificate_get(zend_property_reference *property_reference) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_certificate_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (char *) ((arg1)->certificate);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoServer_private_key_set(zend_property_reference *property_reference, pval *value) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_private_key_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->private_key) free((char*)arg1->private_key);
        if (arg2) {
            arg1->private_key = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->private_key,arg2);
        } else {
            arg1->private_key = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoServer_private_key_get(zend_property_reference *property_reference) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_private_key_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (char *) ((arg1)->private_key);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoServer_private_key_password_set(zend_property_reference *property_reference, pval *value) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_private_key_password_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->private_key_password) free((char*)arg1->private_key_password);
        if (arg2) {
            arg1->private_key_password = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->private_key_password,arg2);
        } else {
            arg1->private_key_password = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoServer_private_key_password_get(zend_property_reference *property_reference) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_private_key_password_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (char *) ((arg1)->private_key_password);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoServer_signature_method_set(zend_property_reference *property_reference, pval *value) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoSignatureMethod arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_signature_method_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (LassoSignatureMethod) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->signature_method = (LassoSignatureMethod )arg2;
    
    
    return SUCCESS;
}


static pval _wrap_LassoServer_signature_method_get(zend_property_reference *property_reference) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoSignatureMethod result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_signature_method_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (LassoSignatureMethod) ((arg1)->signature_method);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoServer_ca_cert_chain_set(zend_property_reference *property_reference, pval *value) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_ca_cert_chain_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoServer_ca_cert_chain_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoServer_ca_cert_chain_get(zend_property_reference *property_reference) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_ca_cert_chain_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (char *)LassoServer_ca_cert_chain_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoServer_metadata_filename_set(zend_property_reference *property_reference, pval *value) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_metadata_filename_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoServer_metadata_filename_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoServer_metadata_filename_get(zend_property_reference *property_reference) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_metadata_filename_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (char *)LassoServer_metadata_filename_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoServer_ProviderID_set(zend_property_reference *property_reference, pval *value) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_ProviderID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoServer_ProviderID_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoServer_ProviderID_get(zend_property_reference *property_reference) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_ProviderID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (char *)LassoServer_ProviderID_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoServer_public_key_set(zend_property_reference *property_reference, pval *value) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_public_key_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoServer_public_key_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoServer_public_key_get(zend_property_reference *property_reference) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_public_key_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (char *)LassoServer_public_key_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoServer_role_set(zend_property_reference *property_reference, pval *value) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoProviderRole arg2 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_role_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (LassoProviderRole) Z_LVAL_PP(&value);
    
    LassoServer_role_set(arg1,(LassoProviderRole )arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoServer_role_get(zend_property_reference *property_reference) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoProviderRole result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_role_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (LassoProviderRole)LassoServer_role_get(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static pval _wrap_LassoServer_providerIds_get(zend_property_reference *property_reference) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_providerIds_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (LassoStringList *)LassoServer_providerIds_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoServer) {
    char *arg1 = (char *) NULL ;
    char *arg2 = (char *) NULL ;
    char *arg3 = (char *) NULL ;
    char *arg4 = (char *) NULL ;
    LassoServer *result;
    zval **args[5];
    int argbase=0 ;
    int arg_count;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(0-argbase) || arg_count>(4-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    if(arg_count > 0 - argbase) {
        convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
        arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
        
    }
    if(arg_count > 1 - argbase) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2 - argbase) {
        convert_to_string_ex(args[2-argbase]);
        arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
        
    }
    if(arg_count > 3 - argbase) {
        convert_to_string_ex(args[3-argbase]);
        arg4 = (char *) Z_STRVAL_PP(args[3-argbase]);
        
    }
    result = (LassoServer *)new_LassoServer(arg1,arg2,arg3,arg4);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoServer, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoServer);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoServer(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoServer *arg1 = (LassoServer *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoServer TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoServer resource already free'd");
    delete_LassoServer(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoServer) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoServer. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoServer(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoServer_newFromDump) {
    char *arg1 = (char *) 0 ;
    LassoServer *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    result = (LassoServer *)LassoServer_newFromDump(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoServer, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoServer);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoServer_acceptHttpMethod) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoProvider *arg2 = (LassoProvider *) 0 ;
    LassoMdProtocolType arg3 ;
    LassoHttpMethod arg4 ;
    bool arg5 ;
    bool result;
    zval **args[6];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 5) || (zend_get_parameters_array_ex(5-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_acceptHttpMethod. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    if (SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*args[1-argbase])->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_acceptHttpMethod. Expected %s",
        2-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    {
        LassoMdProtocolType * argp;
        if(SWIG_ConvertPtr(*args[2-argbase], (void **) &argp, SWIGTYPE_p_LassoMdProtocolType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoServer_acceptHttpMethod. Expected %s", 3-argbase, SWIGTYPE_p_LassoMdProtocolType->name);
        }
        arg3 = *argp;
    }
    
    convert_to_long_ex(args[3-argbase]);
    arg4 = (LassoHttpMethod) Z_LVAL_PP(args[3-argbase]);
    
    
    convert_to_boolean_ex(args[4-argbase]);
    arg5 = (bool) Z_LVAL_PP(args[4-argbase]);
    
    result = (bool)LassoServer_acceptHttpMethod(arg1,arg2,arg3,(LassoHttpMethod )arg4,arg5);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoServer_getAssertionConsumerServiceUrl) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_getAssertionConsumerServiceUrl. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (char *)LassoServer_getAssertionConsumerServiceUrl(arg1,arg2);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoServer_getBase64SuccinctId) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_getBase64SuccinctId. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (char *)LassoServer_getBase64SuccinctId(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoServer_getOrganization) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_getOrganization. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (char *)LassoServer_getOrganization(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoServer_getFirstHttpMethod) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoProvider *arg2 = (LassoProvider *) 0 ;
    LassoMdProtocolType arg3 ;
    LassoHttpMethod result;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_getFirstHttpMethod. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    if (SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_LassoProvider) < 0) {
        if ((*args[1-argbase])->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_getFirstHttpMethod. Expected %s",
        2-argbase, SWIGTYPE_p_LassoProvider->name);
    }
    
    {
        LassoMdProtocolType * argp;
        if(SWIG_ConvertPtr(*args[2-argbase], (void **) &argp, SWIGTYPE_p_LassoMdProtocolType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoServer_getFirstHttpMethod. Expected %s", 3-argbase, SWIGTYPE_p_LassoMdProtocolType->name);
        }
        arg3 = *argp;
    }
    result = (LassoHttpMethod)LassoServer_getFirstHttpMethod(arg1,arg2,arg3);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoServer_getMetadataOne) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_getMetadataOne. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (char *)LassoServer_getMetadataOne(arg1,arg2);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoServer_hasProtocolProfile) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoMdProtocolType arg2 ;
    char *arg3 = (char *) 0 ;
    bool result;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_hasProtocolProfile. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    {
        LassoMdProtocolType * argp;
        if(SWIG_ConvertPtr(*args[1-argbase], (void **) &argp, SWIGTYPE_p_LassoMdProtocolType) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of LassoServer_hasProtocolProfile. Expected %s", 2-argbase, SWIGTYPE_p_LassoMdProtocolType->name);
        }
        arg2 = *argp;
    }
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    result = (bool)LassoServer_hasProtocolProfile(arg1,arg2,arg3);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoServer_addProvider) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoProviderRole arg2 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) NULL ;
    char *arg5 = (char *) NULL ;
    int result;
    zval **args[6];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(3-argbase) || arg_count>(5-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_addProvider. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (LassoProviderRole) Z_LVAL_PP(args[1-argbase]);
    
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    if(arg_count > 3 - argbase) {
        convert_to_string_ex(args[3-argbase]);
        arg4 = (char *) Z_STRVAL_PP(args[3-argbase]);
        
    }
    if(arg_count > 4 - argbase) {
        convert_to_string_ex(args[4-argbase]);
        arg5 = (char *) Z_STRVAL_PP(args[4-argbase]);
        
    }
    {
        int errorCode;
        errorCode = result = (int)LassoServer_addProvider(arg1,(LassoProviderRole )arg2,arg3,arg4,arg5);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoServer_dump) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (char *)LassoServer_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoServer_getProvider) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    LassoProvider *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoServer_getProvider. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (LassoProvider *)LassoServer_getProvider(arg1,arg2);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoProvider, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoProvider);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* property handler for class LassoServer */
static pval _wrap_propget_LassoServer(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoServer(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoServer(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"providerIds")==0) {
    *value=_wrap_LassoServer_providerIds_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"role")==0) {
    *value=_wrap_LassoServer_role_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"private_key_password")==0) {
    *value=_wrap_LassoServer_private_key_password_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"certificate")==0) {
    *value=_wrap_LassoServer_certificate_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ca_cert_chain")==0) {
    *value=_wrap_LassoServer_ca_cert_chain_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"metadata_filename")==0) {
    *value=_wrap_LassoServer_metadata_filename_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"ProviderID")==0) {
    *value=_wrap_LassoServer_ProviderID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"private_key")==0) {
    *value=_wrap_LassoServer_private_key_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"signature_method")==0) {
    *value=_wrap_LassoServer_signature_method_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"public_key")==0) {
    *value=_wrap_LassoServer_public_key_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoServer(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoServer(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoServer */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoServer(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"private_key_password")==0) {
    return _wrap_LassoServer_private_key_password_set(property_reference, value);
  } else  if (strcmp(propname,"certificate")==0) {
    return _wrap_LassoServer_certificate_set(property_reference, value);
  } else  if (strcmp(propname,"ca_cert_chain")==0) {
    return _wrap_LassoServer_ca_cert_chain_set(property_reference, value);
  } else  if (strcmp(propname,"metadata_filename")==0) {
    return _wrap_LassoServer_metadata_filename_set(property_reference, value);
  } else  if (strcmp(propname,"ProviderID")==0) {
    return _wrap_LassoServer_ProviderID_set(property_reference, value);
  } else  if (strcmp(propname,"private_key")==0) {
    return _wrap_LassoServer_private_key_set(property_reference, value);
  } else  if (strcmp(propname,"signature_method")==0) {
    return _wrap_LassoServer_signature_method_set(property_reference, value);
  } else  if (strcmp(propname,"public_key")==0) {
    return _wrap_LassoServer_public_key_set(property_reference, value);
  } else  if (strcmp(propname,"role")==0) {
    return _wrap_LassoServer_role_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoFederation_remote_providerID_set(zend_property_reference *property_reference, pval *value) {
    LassoFederation *arg1 = (LassoFederation *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoFederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoFederation_remote_providerID_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoFederation->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->remote_providerID) free((char*)arg1->remote_providerID);
        if (arg2) {
            arg1->remote_providerID = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->remote_providerID,arg2);
        } else {
            arg1->remote_providerID = 0;
        }
    }
    
    return SUCCESS;
}


static pval _wrap_LassoFederation_remote_providerID_get(zend_property_reference *property_reference) {
    LassoFederation *arg1 = (LassoFederation *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoFederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoFederation_remote_providerID_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoFederation->name);
    }
    
    result = (char *) ((arg1)->remote_providerID);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoFederation_local_nameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoFederation *arg1 = (LassoFederation *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoFederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoFederation_local_nameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoFederation->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoFederation_local_nameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoFederation_local_nameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoFederation_local_nameIdentifier_get(zend_property_reference *property_reference) {
    LassoFederation *arg1 = (LassoFederation *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoFederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoFederation_local_nameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoFederation->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoFederation_local_nameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoFederation_remote_nameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoFederation *arg1 = (LassoFederation *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoFederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoFederation_remote_nameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoFederation->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoFederation_remote_nameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoFederation_remote_nameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoFederation_remote_nameIdentifier_get(zend_property_reference *property_reference) {
    LassoFederation *arg1 = (LassoFederation *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoFederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoFederation_remote_nameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoFederation->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoFederation_remote_nameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoFederation) {
    char *arg1 = (char *) 0 ;
    LassoFederation *result;
    zval **args[2];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    result = (LassoFederation *)new_LassoFederation(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoFederation, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoFederation);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoFederation(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoFederation *arg1 = (LassoFederation *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoFederation TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoFederation resource already free'd");
    delete_LassoFederation(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoFederation) {
    LassoFederation *arg1 = (LassoFederation *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoFederation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoFederation. Expected %s",
        1-argbase, SWIGTYPE_p_LassoFederation->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoFederation(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoFederation_dump) {
    LassoFederation *arg1 = (LassoFederation *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoFederation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoFederation_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoFederation->name);
    }
    
    result = (char *)LassoFederation_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoFederation_buildLocalNameIdentifier) {
    LassoFederation *arg1 = (LassoFederation *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    zval **args[5];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 4) || (zend_get_parameters_array_ex(4-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoFederation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoFederation_buildLocalNameIdentifier. Expected %s",
        1-argbase, SWIGTYPE_p_LassoFederation->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    
    convert_to_string_ex(args[3-argbase]);
    arg4 = (char *) Z_STRVAL_PP(args[3-argbase]);
    
    LassoFederation_buildLocalNameIdentifier(arg1,arg2,arg3,arg4);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoFederation_verifyNameIdentifier) {
    LassoFederation *arg1 = (LassoFederation *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    bool result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoFederation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoFederation_verifyNameIdentifier. Expected %s",
        1-argbase, SWIGTYPE_p_LassoFederation->name);
    }
    
    
    if (SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*args[1-argbase])->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoFederation_verifyNameIdentifier. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    result = (bool)LassoFederation_verifyNameIdentifier(arg1,arg2);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
}


/* property handler for class LassoFederation */
static pval _wrap_propget_LassoFederation(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoFederation(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoFederation(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"remote_providerID")==0) {
    *value=_wrap_LassoFederation_remote_providerID_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"local_nameIdentifier")==0) {
    *value=_wrap_LassoFederation_local_nameIdentifier_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"remote_nameIdentifier")==0) {
    *value=_wrap_LassoFederation_remote_nameIdentifier_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoFederation(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoFederation(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoFederation */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoFederation(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"remote_providerID")==0) {
    return _wrap_LassoFederation_remote_providerID_set(property_reference, value);
  } else  if (strcmp(propname,"local_nameIdentifier")==0) {
    return _wrap_LassoFederation_local_nameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"remote_nameIdentifier")==0) {
    return _wrap_LassoFederation_remote_nameIdentifier_set(property_reference, value);
  } else  return FAILURE;
}

static pval _wrap_LassoIdentity_is_dirty_get(zend_property_reference *property_reference) {
    LassoIdentity *arg1 = (LassoIdentity *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoIdentity) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoIdentity_is_dirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoIdentity->name);
    }
    
    result = (bool) ((arg1)->is_dirty);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoIdentity_providerIds_get(zend_property_reference *property_reference) {
    LassoIdentity *arg1 = (LassoIdentity *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoIdentity) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoIdentity_providerIds_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoIdentity->name);
    }
    
    result = (LassoStringList *)LassoIdentity_providerIds_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoIdentity) {
    LassoIdentity *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoIdentity *)new_LassoIdentity();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoIdentity, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoIdentity);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoIdentity(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoIdentity *arg1 = (LassoIdentity *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoIdentity TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoIdentity resource already free'd");
    delete_LassoIdentity(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoIdentity) {
    LassoIdentity *arg1 = (LassoIdentity *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoIdentity) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoIdentity. Expected %s",
        1-argbase, SWIGTYPE_p_LassoIdentity->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoIdentity(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoIdentity_newFromDump) {
    char *arg1 = (char *) 0 ;
    LassoIdentity *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    result = (LassoIdentity *)LassoIdentity_newFromDump(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoIdentity, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoIdentity);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoIdentity_dump) {
    LassoIdentity *arg1 = (LassoIdentity *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoIdentity) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoIdentity_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoIdentity->name);
    }
    
    result = (char *)LassoIdentity_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoIdentity_getFederation) {
    LassoIdentity *arg1 = (LassoIdentity *) 0 ;
    char *arg2 = (char *) 0 ;
    LassoFederation *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoIdentity) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoIdentity_getFederation. Expected %s",
        1-argbase, SWIGTYPE_p_LassoIdentity->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (LassoFederation *)LassoIdentity_getFederation(arg1,arg2);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoFederation, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoFederation);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* property handler for class LassoIdentity */
static pval _wrap_propget_LassoIdentity(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoIdentity(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoIdentity(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"providerIds")==0) {
    *value=_wrap_LassoIdentity_providerIds_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"is_dirty")==0) {
    *value=_wrap_LassoIdentity_is_dirty_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoIdentity(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoIdentity(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoIdentity */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoIdentity(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static pval _wrap_LassoSession_is_dirty_get(zend_property_reference *property_reference) {
    LassoSession *arg1 = (LassoSession *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSession) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSession_is_dirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSession->name);
    }
    
    result = (bool) ((arg1)->is_dirty);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoSession_providerIds_get(zend_property_reference *property_reference) {
    LassoSession *arg1 = (LassoSession *) 0 ;
    LassoStringList *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoSession) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSession_providerIds_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSession->name);
    }
    
    result = (LassoStringList *)LassoSession_providerIds_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoStringList, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoStringList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoSession) {
    LassoSession *result;
    zval **args[1];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LassoSession *)new_LassoSession();
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSession, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSession);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoSession(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoSession *arg1 = (LassoSession *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoSession TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoSession resource already free'd");
    delete_LassoSession(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoSession) {
    LassoSession *arg1 = (LassoSession *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSession) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoSession. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSession->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoSession(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSession_newFromDump) {
    char *arg1 = (char *) 0 ;
    LassoSession *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    result = (LassoSession *)LassoSession_newFromDump(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSession, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSession);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoSession_dump) {
    LassoSession *arg1 = (LassoSession *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSession) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSession_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSession->name);
    }
    
    result = (char *)LassoSession_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoSession_getAssertions) {
    LassoSession *arg1 = (LassoSession *) 0 ;
    char *arg2 = (char *) 0 ;
    LassoNodeList *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoSession) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoSession_getAssertions. Expected %s",
        1-argbase, SWIGTYPE_p_LassoSession->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (LassoNodeList *)LassoSession_getAssertions(arg1,arg2);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNodeList, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNodeList);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* property handler for class LassoSession */
static pval _wrap_propget_LassoSession(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoSession(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoSession(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"providerIds")==0) {
    *value=_wrap_LassoSession_providerIds_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"is_dirty")==0) {
    *value=_wrap_LassoSession_is_dirty_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoSession(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoSession(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoSession */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoSession(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_lasso_getRequestTypeFromSoapMsg) {
    char *arg1 = (char *) 0 ;
    LassoRequestType result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    result = (LassoRequestType)lasso_profile_get_request_type_from_soap_msg(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_lasso_isLibertyQuery) {
    char *arg1 = (char *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    result = (bool)lasso_profile_is_liberty_query(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
}


static int _wrap_LassoDefederation_identity_set(zend_property_reference *property_reference, pval *value) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    LassoIdentity *arg2 = (LassoIdentity *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_identity_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoIdentity) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_identity_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoIdentity->name);
    }
    
    LassoDefederation_identity_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoDefederation_identity_get(zend_property_reference *property_reference) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    LassoIdentity *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_identity_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    result = (LassoIdentity *)LassoDefederation_identity_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoIdentity, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoIdentity);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static pval _wrap_LassoDefederation_isIdentityDirty_get(zend_property_reference *property_reference) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_isIdentityDirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    result = (bool)LassoDefederation_isIdentityDirty_get(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoDefederation_isSessionDirty_get(zend_property_reference *property_reference) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_isSessionDirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    result = (bool)LassoDefederation_isSessionDirty_get(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoDefederation_msgBody_get(zend_property_reference *property_reference) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_msgBody_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    result = (char *)LassoDefederation_msgBody_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static pval _wrap_LassoDefederation_msgRelayState_get(zend_property_reference *property_reference) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_msgRelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    result = (char *)LassoDefederation_msgRelayState_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static pval _wrap_LassoDefederation_msgUrl_get(zend_property_reference *property_reference) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_msgUrl_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    result = (char *)LassoDefederation_msgUrl_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoDefederation_nameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_nameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_nameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoDefederation_nameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoDefederation_nameIdentifier_get(zend_property_reference *property_reference) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_nameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoDefederation_nameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoDefederation_remoteProviderId_set(zend_property_reference *property_reference, pval *value) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_remoteProviderId_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoDefederation_remoteProviderId_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoDefederation_remoteProviderId_get(zend_property_reference *property_reference) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_remoteProviderId_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    result = (char *)LassoDefederation_remoteProviderId_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoDefederation_request_set(zend_property_reference *property_reference, pval *value) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    LassoSamlpRequestAbstract *arg2 = (LassoSamlpRequestAbstract *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_request_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&value)->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&value, (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_request_set. Expected %s",
            2-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoDefederation_request_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoDefederation_request_get(zend_property_reference *property_reference) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    LassoSamlpRequestAbstract *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_request_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    result = (LassoSamlpRequestAbstract *)LassoDefederation_request_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoSamlpRequestAbstract, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoDefederation_response_set(zend_property_reference *property_reference, pval *value) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    LassoSamlpResponseAbstract *arg2 = (LassoSamlpResponseAbstract *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_response_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&value)->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&value, (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_response_set. Expected %s",
            2-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoDefederation_response_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoDefederation_response_get(zend_property_reference *property_reference) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    LassoSamlpResponseAbstract *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_response_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    result = (LassoSamlpResponseAbstract *)LassoDefederation_response_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoSamlpResponseAbstract, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoDefederation_server_set(zend_property_reference *property_reference, pval *value) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    LassoServer *arg2 = (LassoServer *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_server_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_server_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    LassoDefederation_server_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoDefederation_server_get(zend_property_reference *property_reference) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    LassoServer *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_server_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    result = (LassoServer *)LassoDefederation_server_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoServer, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoServer);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoDefederation_session_set(zend_property_reference *property_reference, pval *value) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    LassoSession *arg2 = (LassoSession *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_session_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSession) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_session_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSession->name);
    }
    
    LassoDefederation_session_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoDefederation_session_get(zend_property_reference *property_reference) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    LassoSession *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_session_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    result = (LassoSession *)LassoDefederation_session_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSession, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSession);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoDefederation) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoDefederation *result;
    zval **args[2];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of new_LassoDefederation. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (LassoDefederation *)new_LassoDefederation(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoDefederation, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoDefederation);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoDefederation(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoDefederation TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoDefederation resource already free'd");
    delete_LassoDefederation(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoDefederation) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoDefederation. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoDefederation(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoDefederation_setIdentityFromDump) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_setIdentityFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoDefederation_setIdentityFromDump(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoDefederation_setSessionFromDump) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_setSessionFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoDefederation_setSessionFromDump(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoDefederation_buildNotificationMsg) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_buildNotificationMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoDefederation_buildNotificationMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoDefederation_initNotification) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    char *arg2 = (char *) NULL ;
    LassoHttpMethod arg3 = (LassoHttpMethod) LASSO_HTTP_METHOD_ANY ;
    int result;
    zval **args[4];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(3-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_initNotification. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    if(arg_count > 1 - argbase) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2 - argbase) {
        convert_to_long_ex(args[2-argbase]);
        arg3 = (LassoHttpMethod) Z_LVAL_PP(args[2-argbase]);
        
    }
    {
        int errorCode;
        errorCode = result = (int)LassoDefederation_initNotification(arg1,arg2,(LassoHttpMethod )arg3);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoDefederation_processNotificationMsg) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_processNotificationMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoDefederation_processNotificationMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoDefederation_validateNotification) {
    LassoDefederation *arg1 = (LassoDefederation *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoDefederation) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoDefederation_validateNotification. Expected %s",
        1-argbase, SWIGTYPE_p_LassoDefederation->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoDefederation_validateNotification(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


/* property handler for class LassoDefederation */
static pval _wrap_propget_LassoDefederation(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoDefederation(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoDefederation(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"remoteProviderId")==0) {
    *value=_wrap_LassoDefederation_remoteProviderId_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"request")==0) {
    *value=_wrap_LassoDefederation_request_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"server")==0) {
    *value=_wrap_LassoDefederation_server_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"identity")==0) {
    *value=_wrap_LassoDefederation_identity_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgUrl")==0) {
    *value=_wrap_LassoDefederation_msgUrl_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"isIdentityDirty")==0) {
    *value=_wrap_LassoDefederation_isIdentityDirty_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"isSessionDirty")==0) {
    *value=_wrap_LassoDefederation_isSessionDirty_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"session")==0) {
    *value=_wrap_LassoDefederation_session_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgBody")==0) {
    *value=_wrap_LassoDefederation_msgBody_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"response")==0) {
    *value=_wrap_LassoDefederation_response_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgRelayState")==0) {
    *value=_wrap_LassoDefederation_msgRelayState_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"nameIdentifier")==0) {
    *value=_wrap_LassoDefederation_nameIdentifier_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoDefederation(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoDefederation(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoDefederation */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoDefederation(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"response")==0) {
    return _wrap_LassoDefederation_response_set(property_reference, value);
  } else  if (strcmp(propname,"nameIdentifier")==0) {
    return _wrap_LassoDefederation_nameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"remoteProviderId")==0) {
    return _wrap_LassoDefederation_remoteProviderId_set(property_reference, value);
  } else  if (strcmp(propname,"request")==0) {
    return _wrap_LassoDefederation_request_set(property_reference, value);
  } else  if (strcmp(propname,"server")==0) {
    return _wrap_LassoDefederation_server_set(property_reference, value);
  } else  if (strcmp(propname,"identity")==0) {
    return _wrap_LassoDefederation_identity_set(property_reference, value);
  } else  if (strcmp(propname,"session")==0) {
    return _wrap_LassoDefederation_session_set(property_reference, value);
  } else  return FAILURE;
}

static pval _wrap_LassoLogin_assertionArtifact_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_assertionArtifact_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (char *) ((arg1)->assertionArtifact);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static pval _wrap_LassoLogin_protocolProfile_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoLoginProtocolProfile result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_protocolProfile_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (LassoLoginProtocolProfile) ((arg1)->protocolProfile);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


static int _wrap_LassoLogin_identity_set(zend_property_reference *property_reference, pval *value) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoIdentity *arg2 = (LassoIdentity *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_identity_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoIdentity) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_identity_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoIdentity->name);
    }
    
    LassoLogin_identity_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogin_identity_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoIdentity *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_identity_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (LassoIdentity *)LassoLogin_identity_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoIdentity, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoIdentity);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static pval _wrap_LassoLogin_isIdentityDirty_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_isIdentityDirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (bool)LassoLogin_isIdentityDirty_get(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoLogin_isSessionDirty_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_isSessionDirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (bool)LassoLogin_isSessionDirty_get(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoLogin_msgBody_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_msgBody_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (char *)LassoLogin_msgBody_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static pval _wrap_LassoLogin_msgRelayState_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_msgRelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (char *)LassoLogin_msgRelayState_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static pval _wrap_LassoLogin_msgUrl_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_msgUrl_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (char *)LassoLogin_msgUrl_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLogin_nameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_nameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_nameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoLogin_nameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogin_nameIdentifier_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_nameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoLogin_nameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLogin_remoteProviderId_set(zend_property_reference *property_reference, pval *value) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_remoteProviderId_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLogin_remoteProviderId_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogin_remoteProviderId_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_remoteProviderId_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (char *)LassoLogin_remoteProviderId_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLogin_request_set(zend_property_reference *property_reference, pval *value) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoSamlpRequestAbstract *arg2 = (LassoSamlpRequestAbstract *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_request_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&value)->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&value, (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoLogin_request_set. Expected %s",
            2-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoLogin_request_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogin_request_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoSamlpRequestAbstract *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_request_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (LassoSamlpRequestAbstract *)LassoLogin_request_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoSamlpRequestAbstract, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLogin_response_set(zend_property_reference *property_reference, pval *value) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoSamlpResponseAbstract *arg2 = (LassoSamlpResponseAbstract *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_response_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&value)->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&value, (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoLogin_response_set. Expected %s",
            2-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoLogin_response_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogin_response_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoSamlpResponseAbstract *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_response_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (LassoSamlpResponseAbstract *)LassoLogin_response_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoSamlpResponseAbstract, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLogin_server_set(zend_property_reference *property_reference, pval *value) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoServer *arg2 = (LassoServer *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_server_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_server_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    LassoLogin_server_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogin_server_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoServer *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_server_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (LassoServer *)LassoLogin_server_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoServer, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoServer);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLogin_session_set(zend_property_reference *property_reference, pval *value) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoSession *arg2 = (LassoSession *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_session_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSession) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_session_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSession->name);
    }
    
    LassoLogin_session_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogin_session_get(zend_property_reference *property_reference) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoSession *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_session_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (LassoSession *)LassoLogin_session_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSession, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSession);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLogin) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoLogin *result;
    zval **args[2];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of new_LassoLogin. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (LassoLogin *)new_LassoLogin(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLogin, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLogin);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLogin(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLogin TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLogin resource already free'd");
    delete_LassoLogin(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLogin) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLogin. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLogin(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_newFromDump) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    LassoLogin *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_newFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (LassoLogin *)LassoLogin_newFromDump(arg1,arg2);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLogin, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLogin);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_setIdentityFromDump) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_setIdentityFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_setIdentityFromDump(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_setSessionFromDump) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_setSessionFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_setSessionFromDump(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_acceptSso) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_acceptSso. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_acceptSso(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_buildArtifactMsg) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    LassoHttpMethod arg2 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_buildArtifactMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (LassoHttpMethod) Z_LVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_buildArtifactMsg(arg1,(LassoHttpMethod )arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_buildAssertion) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    int result;
    zval **args[7];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 6) || (zend_get_parameters_array_ex(6-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_buildAssertion. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    
    convert_to_string_ex(args[3-argbase]);
    arg4 = (char *) Z_STRVAL_PP(args[3-argbase]);
    
    
    convert_to_string_ex(args[4-argbase]);
    arg5 = (char *) Z_STRVAL_PP(args[4-argbase]);
    
    
    convert_to_string_ex(args[5-argbase]);
    arg6 = (char *) Z_STRVAL_PP(args[5-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_buildAssertion(arg1,arg2,arg3,arg4,arg5,arg6);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_buildAuthnRequestMsg) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_buildAuthnRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_buildAuthnRequestMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_buildAuthnResponseMsg) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_buildAuthnResponseMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_buildAuthnResponseMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_buildRequestMsg) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_buildRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_buildRequestMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_buildResponseMsg) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_buildResponseMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_buildResponseMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_dump) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (char *)LassoLogin_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_initAuthnRequest) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) NULL ;
    LassoHttpMethod arg3 = (LassoHttpMethod) LASSO_HTTP_METHOD_REDIRECT ;
    int result;
    zval **args[4];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(3-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_initAuthnRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    if(arg_count > 1 - argbase) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2 - argbase) {
        convert_to_long_ex(args[2-argbase]);
        arg3 = (LassoHttpMethod) Z_LVAL_PP(args[2-argbase]);
        
    }
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_initAuthnRequest(arg1,arg2,(LassoHttpMethod )arg3);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_initRequest) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) 0 ;
    LassoHttpMethod arg3 = (LassoHttpMethod) LASSO_HTTP_METHOD_REDIRECT ;
    int result;
    zval **args[4];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(2-argbase) || arg_count>(3-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_initRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    if(arg_count > 2 - argbase) {
        convert_to_long_ex(args[2-argbase]);
        arg3 = (LassoHttpMethod) Z_LVAL_PP(args[2-argbase]);
        
    }
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_initRequest(arg1,arg2,(LassoHttpMethod )arg3);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_initIdpInitiatedAuthnRequest) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) NULL ;
    int result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_initIdpInitiatedAuthnRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    if(arg_count > 1 - argbase) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_initIdpInitiatedAuthnRequest(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_mustAskForConsent) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_mustAskForConsent. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (bool)LassoLogin_mustAskForConsent(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_mustAuthenticate) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_mustAuthenticate. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    result = (bool)LassoLogin_mustAuthenticate(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_processAuthnRequestMsg) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_processAuthnRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_processAuthnRequestMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_processAuthnResponseMsg) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_processAuthnResponseMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_processAuthnResponseMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_processRequestMsg) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_processRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_processRequestMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_processResponseMsg) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_processResponseMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_processResponseMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_setResourceId) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_setResourceId. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_setResourceId(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogin_validateRequestMsg) {
    LassoLogin *arg1 = (LassoLogin *) 0 ;
    bool arg2 ;
    bool arg3 ;
    int result;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogin) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogin_validateRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogin->name);
    }
    
    
    convert_to_boolean_ex(args[1-argbase]);
    arg2 = (bool) Z_LVAL_PP(args[1-argbase]);
    
    
    convert_to_boolean_ex(args[2-argbase]);
    arg3 = (bool) Z_LVAL_PP(args[2-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogin_validateRequestMsg(arg1,arg2,arg3);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


/* property handler for class LassoLogin */
static pval _wrap_propget_LassoLogin(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLogin(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLogin(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"assertionArtifact")==0) {
    *value=_wrap_LassoLogin_assertionArtifact_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"server")==0) {
    *value=_wrap_LassoLogin_server_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgUrl")==0) {
    *value=_wrap_LassoLogin_msgUrl_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"nameIdentifier")==0) {
    *value=_wrap_LassoLogin_nameIdentifier_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"isSessionDirty")==0) {
    *value=_wrap_LassoLogin_isSessionDirty_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"isIdentityDirty")==0) {
    *value=_wrap_LassoLogin_isIdentityDirty_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"response")==0) {
    *value=_wrap_LassoLogin_response_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"remoteProviderId")==0) {
    *value=_wrap_LassoLogin_remoteProviderId_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"identity")==0) {
    *value=_wrap_LassoLogin_identity_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"session")==0) {
    *value=_wrap_LassoLogin_session_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgBody")==0) {
    *value=_wrap_LassoLogin_msgBody_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgRelayState")==0) {
    *value=_wrap_LassoLogin_msgRelayState_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"request")==0) {
    *value=_wrap_LassoLogin_request_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"protocolProfile")==0) {
    *value=_wrap_LassoLogin_protocolProfile_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLogin(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLogin(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLogin */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLogin(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"response")==0) {
    return _wrap_LassoLogin_response_set(property_reference, value);
  } else  if (strcmp(propname,"nameIdentifier")==0) {
    return _wrap_LassoLogin_nameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"remoteProviderId")==0) {
    return _wrap_LassoLogin_remoteProviderId_set(property_reference, value);
  } else  if (strcmp(propname,"request")==0) {
    return _wrap_LassoLogin_request_set(property_reference, value);
  } else  if (strcmp(propname,"server")==0) {
    return _wrap_LassoLogin_server_set(property_reference, value);
  } else  if (strcmp(propname,"identity")==0) {
    return _wrap_LassoLogin_identity_set(property_reference, value);
  } else  if (strcmp(propname,"session")==0) {
    return _wrap_LassoLogin_session_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoLogout_identity_set(zend_property_reference *property_reference, pval *value) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    LassoIdentity *arg2 = (LassoIdentity *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_identity_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoIdentity) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_identity_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoIdentity->name);
    }
    
    LassoLogout_identity_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogout_identity_get(zend_property_reference *property_reference) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    LassoIdentity *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_identity_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (LassoIdentity *)LassoLogout_identity_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoIdentity, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoIdentity);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static pval _wrap_LassoLogout_isIdentityDirty_get(zend_property_reference *property_reference) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_isIdentityDirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (bool)LassoLogout_isIdentityDirty_get(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoLogout_isSessionDirty_get(zend_property_reference *property_reference) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_isSessionDirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (bool)LassoLogout_isSessionDirty_get(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoLogout_msgBody_get(zend_property_reference *property_reference) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_msgBody_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (char *)LassoLogout_msgBody_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static pval _wrap_LassoLogout_msgRelayState_get(zend_property_reference *property_reference) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_msgRelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (char *)LassoLogout_msgRelayState_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static pval _wrap_LassoLogout_msgUrl_get(zend_property_reference *property_reference) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_msgUrl_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (char *)LassoLogout_msgUrl_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLogout_nameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_nameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_nameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoLogout_nameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogout_nameIdentifier_get(zend_property_reference *property_reference) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_nameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoLogout_nameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLogout_remoteProviderId_set(zend_property_reference *property_reference, pval *value) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_remoteProviderId_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLogout_remoteProviderId_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogout_remoteProviderId_get(zend_property_reference *property_reference) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_remoteProviderId_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (char *)LassoLogout_remoteProviderId_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLogout_request_set(zend_property_reference *property_reference, pval *value) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    LassoSamlpRequestAbstract *arg2 = (LassoSamlpRequestAbstract *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_request_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&value)->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&value, (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoLogout_request_set. Expected %s",
            2-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoLogout_request_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogout_request_get(zend_property_reference *property_reference) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    LassoSamlpRequestAbstract *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_request_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (LassoSamlpRequestAbstract *)LassoLogout_request_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoSamlpRequestAbstract, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLogout_response_set(zend_property_reference *property_reference, pval *value) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    LassoSamlpResponseAbstract *arg2 = (LassoSamlpResponseAbstract *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_response_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&value)->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&value, (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoLogout_response_set. Expected %s",
            2-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoLogout_response_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogout_response_get(zend_property_reference *property_reference) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    LassoSamlpResponseAbstract *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_response_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (LassoSamlpResponseAbstract *)LassoLogout_response_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoSamlpResponseAbstract, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLogout_server_set(zend_property_reference *property_reference, pval *value) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    LassoServer *arg2 = (LassoServer *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_server_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_server_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    LassoLogout_server_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogout_server_get(zend_property_reference *property_reference) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    LassoServer *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_server_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (LassoServer *)LassoLogout_server_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoServer, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoServer);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLogout_session_set(zend_property_reference *property_reference, pval *value) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    LassoSession *arg2 = (LassoSession *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_session_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSession) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_session_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSession->name);
    }
    
    LassoLogout_session_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLogout_session_get(zend_property_reference *property_reference) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    LassoSession *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_session_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (LassoSession *)LassoLogout_session_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSession, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSession);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLogout) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoLogout *result;
    zval **args[2];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of new_LassoLogout. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (LassoLogout *)new_LassoLogout(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLogout, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLogout);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLogout(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLogout TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLogout resource already free'd");
    delete_LassoLogout(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLogout) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLogout. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLogout(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogout_newFromDump) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    LassoLogout *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_newFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (LassoLogout *)LassoLogout_newFromDump(arg1,arg2);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLogout, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLogout);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogout_setIdentityFromDump) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_setIdentityFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogout_setIdentityFromDump(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogout_setSessionFromDump) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_setSessionFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogout_setSessionFromDump(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogout_buildRequestMsg) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_buildRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogout_buildRequestMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogout_buildResponseMsg) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_buildResponseMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogout_buildResponseMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogout_dump) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (char *)LassoLogout_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogout_getNextProviderId) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_getNextProviderId. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    result = (char *)LassoLogout_getNextProviderId(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogout_initRequest) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    char *arg2 = (char *) NULL ;
    LassoHttpMethod arg3 = (LassoHttpMethod) LASSO_HTTP_METHOD_ANY ;
    int result;
    zval **args[4];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(3-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_initRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    if(arg_count > 1 - argbase) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2 - argbase) {
        convert_to_long_ex(args[2-argbase]);
        arg3 = (LassoHttpMethod) Z_LVAL_PP(args[2-argbase]);
        
    }
    {
        int errorCode;
        errorCode = result = (int)LassoLogout_initRequest(arg1,arg2,(LassoHttpMethod )arg3);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogout_processRequestMsg) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_processRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogout_processRequestMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogout_processResponseMsg) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_processResponseMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogout_processResponseMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogout_resetProviderIdIndex) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_resetProviderIdIndex. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogout_resetProviderIdIndex(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLogout_validateRequest) {
    LassoLogout *arg1 = (LassoLogout *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLogout) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLogout_validateRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLogout->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoLogout_validateRequest(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


/* property handler for class LassoLogout */
static pval _wrap_propget_LassoLogout(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLogout(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLogout(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"remoteProviderId")==0) {
    *value=_wrap_LassoLogout_remoteProviderId_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"request")==0) {
    *value=_wrap_LassoLogout_request_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"server")==0) {
    *value=_wrap_LassoLogout_server_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"identity")==0) {
    *value=_wrap_LassoLogout_identity_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgUrl")==0) {
    *value=_wrap_LassoLogout_msgUrl_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"isIdentityDirty")==0) {
    *value=_wrap_LassoLogout_isIdentityDirty_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"isSessionDirty")==0) {
    *value=_wrap_LassoLogout_isSessionDirty_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"session")==0) {
    *value=_wrap_LassoLogout_session_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgBody")==0) {
    *value=_wrap_LassoLogout_msgBody_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"response")==0) {
    *value=_wrap_LassoLogout_response_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgRelayState")==0) {
    *value=_wrap_LassoLogout_msgRelayState_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"nameIdentifier")==0) {
    *value=_wrap_LassoLogout_nameIdentifier_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLogout(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLogout(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLogout */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLogout(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"response")==0) {
    return _wrap_LassoLogout_response_set(property_reference, value);
  } else  if (strcmp(propname,"nameIdentifier")==0) {
    return _wrap_LassoLogout_nameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"remoteProviderId")==0) {
    return _wrap_LassoLogout_remoteProviderId_set(property_reference, value);
  } else  if (strcmp(propname,"request")==0) {
    return _wrap_LassoLogout_request_set(property_reference, value);
  } else  if (strcmp(propname,"server")==0) {
    return _wrap_LassoLogout_server_set(property_reference, value);
  } else  if (strcmp(propname,"identity")==0) {
    return _wrap_LassoLogout_identity_set(property_reference, value);
  } else  if (strcmp(propname,"session")==0) {
    return _wrap_LassoLogout_session_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoLecp_identity_set(zend_property_reference *property_reference, pval *value) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    LassoIdentity *arg2 = (LassoIdentity *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_identity_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoIdentity) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_identity_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoIdentity->name);
    }
    
    LassoLecp_identity_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLecp_identity_get(zend_property_reference *property_reference) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    LassoIdentity *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_identity_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    result = (LassoIdentity *)LassoLecp_identity_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoIdentity, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoIdentity);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static pval _wrap_LassoLecp_isIdentityDirty_get(zend_property_reference *property_reference) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_isIdentityDirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    result = (bool)LassoLecp_isIdentityDirty_get(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoLecp_isSessionDirty_get(zend_property_reference *property_reference) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_isSessionDirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    result = (bool)LassoLecp_isSessionDirty_get(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoLecp_msgBody_get(zend_property_reference *property_reference) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_msgBody_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    result = (char *)LassoLecp_msgBody_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static pval _wrap_LassoLecp_msgRelayState_get(zend_property_reference *property_reference) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_msgRelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    result = (char *)LassoLecp_msgRelayState_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static pval _wrap_LassoLecp_msgUrl_get(zend_property_reference *property_reference) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_msgUrl_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    result = (char *)LassoLecp_msgUrl_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLecp_nameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_nameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_nameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoLecp_nameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLecp_nameIdentifier_get(zend_property_reference *property_reference) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_nameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoLecp_nameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLecp_remoteProviderId_set(zend_property_reference *property_reference, pval *value) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_remoteProviderId_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoLecp_remoteProviderId_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLecp_remoteProviderId_get(zend_property_reference *property_reference) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_remoteProviderId_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    result = (char *)LassoLecp_remoteProviderId_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoLecp_request_set(zend_property_reference *property_reference, pval *value) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    LassoSamlpRequestAbstract *arg2 = (LassoSamlpRequestAbstract *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_request_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&value)->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&value, (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoLecp_request_set. Expected %s",
            2-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoLecp_request_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLecp_request_get(zend_property_reference *property_reference) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    LassoSamlpRequestAbstract *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_request_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    result = (LassoSamlpRequestAbstract *)LassoLecp_request_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoSamlpRequestAbstract, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLecp_response_set(zend_property_reference *property_reference, pval *value) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    LassoSamlpResponseAbstract *arg2 = (LassoSamlpResponseAbstract *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_response_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&value)->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&value, (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoLecp_response_set. Expected %s",
            2-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoLecp_response_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLecp_response_get(zend_property_reference *property_reference) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    LassoSamlpResponseAbstract *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_response_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    result = (LassoSamlpResponseAbstract *)LassoLecp_response_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoSamlpResponseAbstract, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLecp_server_set(zend_property_reference *property_reference, pval *value) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    LassoServer *arg2 = (LassoServer *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_server_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_server_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    LassoLecp_server_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLecp_server_get(zend_property_reference *property_reference) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    LassoServer *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_server_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    result = (LassoServer *)LassoLecp_server_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoServer, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoServer);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoLecp_session_set(zend_property_reference *property_reference, pval *value) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    LassoSession *arg2 = (LassoSession *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_session_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSession) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_session_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSession->name);
    }
    
    LassoLecp_session_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoLecp_session_get(zend_property_reference *property_reference) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    LassoSession *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_session_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    result = (LassoSession *)LassoLecp_session_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSession, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSession);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoLecp) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoLecp *result;
    zval **args[2];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of new_LassoLecp. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (LassoLecp *)new_LassoLecp(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoLecp, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoLecp);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoLecp(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoLecp TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoLecp resource already free'd");
    delete_LassoLecp(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoLecp) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoLecp. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoLecp(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_setIdentityFromDump) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_setIdentityFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_setIdentityFromDump(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_setSessionFromDump) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_setSessionFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_setSessionFromDump(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_buildAssertion) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    int result;
    zval **args[7];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 6) || (zend_get_parameters_array_ex(6-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_buildAssertion. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    
    convert_to_string_ex(args[3-argbase]);
    arg4 = (char *) Z_STRVAL_PP(args[3-argbase]);
    
    
    convert_to_string_ex(args[4-argbase]);
    arg5 = (char *) Z_STRVAL_PP(args[4-argbase]);
    
    
    convert_to_string_ex(args[5-argbase]);
    arg6 = (char *) Z_STRVAL_PP(args[5-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_buildAssertion(arg1,arg2,arg3,arg4,arg5,arg6);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_setResourceId) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_setResourceId. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_setResourceId(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_validateRequestMsg) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    bool arg2 ;
    bool arg3 ;
    int result;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_validateRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    convert_to_boolean_ex(args[1-argbase]);
    arg2 = (bool) Z_LVAL_PP(args[1-argbase]);
    
    
    convert_to_boolean_ex(args[2-argbase]);
    arg3 = (bool) Z_LVAL_PP(args[2-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_validateRequestMsg(arg1,arg2,arg3);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_buildAuthnRequestEnvelopeMsg) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_buildAuthnRequestEnvelopeMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_buildAuthnRequestEnvelopeMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_buildAuthnRequestMsg) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_buildAuthnRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_buildAuthnRequestMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_buildAuthnResponseEnvelopeMsg) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_buildAuthnResponseEnvelopeMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_buildAuthnResponseEnvelopeMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_buildAuthnResponseMsg) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_buildAuthnResponseMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_buildAuthnResponseMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_initAuthnRequest) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *arg2 = (char *) NULL ;
    int result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_initAuthnRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    if(arg_count > 1 - argbase) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_initAuthnRequest(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_processAuthnRequestEnvelopeMsg) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_processAuthnRequestEnvelopeMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_processAuthnRequestEnvelopeMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_processAuthnRequestMsg) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_processAuthnRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_processAuthnRequestMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoLecp_processAuthnResponseEnvelopeMsg) {
    LassoLecp *arg1 = (LassoLecp *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoLecp) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoLecp_processAuthnResponseEnvelopeMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoLecp->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoLecp_processAuthnResponseEnvelopeMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


/* property handler for class LassoLecp */
static pval _wrap_propget_LassoLecp(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoLecp(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoLecp(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"remoteProviderId")==0) {
    *value=_wrap_LassoLecp_remoteProviderId_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"request")==0) {
    *value=_wrap_LassoLecp_request_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"server")==0) {
    *value=_wrap_LassoLecp_server_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"identity")==0) {
    *value=_wrap_LassoLecp_identity_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgUrl")==0) {
    *value=_wrap_LassoLecp_msgUrl_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"isIdentityDirty")==0) {
    *value=_wrap_LassoLecp_isIdentityDirty_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"isSessionDirty")==0) {
    *value=_wrap_LassoLecp_isSessionDirty_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"session")==0) {
    *value=_wrap_LassoLecp_session_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgBody")==0) {
    *value=_wrap_LassoLecp_msgBody_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"response")==0) {
    *value=_wrap_LassoLecp_response_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgRelayState")==0) {
    *value=_wrap_LassoLecp_msgRelayState_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"nameIdentifier")==0) {
    *value=_wrap_LassoLecp_nameIdentifier_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoLecp(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoLecp(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoLecp */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoLecp(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"response")==0) {
    return _wrap_LassoLecp_response_set(property_reference, value);
  } else  if (strcmp(propname,"nameIdentifier")==0) {
    return _wrap_LassoLecp_nameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"remoteProviderId")==0) {
    return _wrap_LassoLecp_remoteProviderId_set(property_reference, value);
  } else  if (strcmp(propname,"request")==0) {
    return _wrap_LassoLecp_request_set(property_reference, value);
  } else  if (strcmp(propname,"server")==0) {
    return _wrap_LassoLecp_server_set(property_reference, value);
  } else  if (strcmp(propname,"identity")==0) {
    return _wrap_LassoLecp_identity_set(property_reference, value);
  } else  if (strcmp(propname,"session")==0) {
    return _wrap_LassoLecp_session_set(property_reference, value);
  } else  return FAILURE;
}

static pval _wrap_LassoNameIdentifierMapping_targetNameIdentifier_get(zend_property_reference *property_reference) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_targetNameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    result = (char *) ((arg1)->targetNameIdentifier);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoNameIdentifierMapping_identity_set(zend_property_reference *property_reference, pval *value) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    LassoIdentity *arg2 = (LassoIdentity *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_identity_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoIdentity) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_identity_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoIdentity->name);
    }
    
    LassoNameIdentifierMapping_identity_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameIdentifierMapping_identity_get(zend_property_reference *property_reference) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    LassoIdentity *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_identity_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    result = (LassoIdentity *)LassoNameIdentifierMapping_identity_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoIdentity, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoIdentity);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static pval _wrap_LassoNameIdentifierMapping_isIdentityDirty_get(zend_property_reference *property_reference) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_isIdentityDirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    result = (bool)LassoNameIdentifierMapping_isIdentityDirty_get(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoNameIdentifierMapping_isSessionDirty_get(zend_property_reference *property_reference) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_isSessionDirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    result = (bool)LassoNameIdentifierMapping_isSessionDirty_get(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoNameIdentifierMapping_msgBody_get(zend_property_reference *property_reference) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_msgBody_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    result = (char *)LassoNameIdentifierMapping_msgBody_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static pval _wrap_LassoNameIdentifierMapping_msgUrl_get(zend_property_reference *property_reference) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_msgUrl_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    result = (char *)LassoNameIdentifierMapping_msgUrl_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoNameIdentifierMapping_nameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_nameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_nameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoNameIdentifierMapping_nameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameIdentifierMapping_nameIdentifier_get(zend_property_reference *property_reference) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_nameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoNameIdentifierMapping_nameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoNameIdentifierMapping_remoteProviderId_set(zend_property_reference *property_reference, pval *value) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_remoteProviderId_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoNameIdentifierMapping_remoteProviderId_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameIdentifierMapping_remoteProviderId_get(zend_property_reference *property_reference) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_remoteProviderId_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    result = (char *)LassoNameIdentifierMapping_remoteProviderId_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoNameIdentifierMapping_request_set(zend_property_reference *property_reference, pval *value) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    LassoSamlpRequestAbstract *arg2 = (LassoSamlpRequestAbstract *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_request_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&value)->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&value, (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_request_set. Expected %s",
            2-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoNameIdentifierMapping_request_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameIdentifierMapping_request_get(zend_property_reference *property_reference) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    LassoSamlpRequestAbstract *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_request_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    result = (LassoSamlpRequestAbstract *)LassoNameIdentifierMapping_request_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoSamlpRequestAbstract, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoNameIdentifierMapping_response_set(zend_property_reference *property_reference, pval *value) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    LassoSamlpResponseAbstract *arg2 = (LassoSamlpResponseAbstract *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_response_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&value)->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&value, (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_response_set. Expected %s",
            2-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoNameIdentifierMapping_response_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameIdentifierMapping_response_get(zend_property_reference *property_reference) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    LassoSamlpResponseAbstract *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_response_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    result = (LassoSamlpResponseAbstract *)LassoNameIdentifierMapping_response_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoSamlpResponseAbstract, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoNameIdentifierMapping_server_set(zend_property_reference *property_reference, pval *value) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    LassoServer *arg2 = (LassoServer *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_server_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_server_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    LassoNameIdentifierMapping_server_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameIdentifierMapping_server_get(zend_property_reference *property_reference) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    LassoServer *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_server_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    result = (LassoServer *)LassoNameIdentifierMapping_server_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoServer, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoServer);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoNameIdentifierMapping_session_set(zend_property_reference *property_reference, pval *value) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    LassoSession *arg2 = (LassoSession *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_session_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSession) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_session_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSession->name);
    }
    
    LassoNameIdentifierMapping_session_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameIdentifierMapping_session_get(zend_property_reference *property_reference) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    LassoSession *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_session_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    result = (LassoSession *)LassoNameIdentifierMapping_session_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSession, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSession);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoNameIdentifierMapping) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoNameIdentifierMapping *result;
    zval **args[2];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of new_LassoNameIdentifierMapping. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (LassoNameIdentifierMapping *)new_LassoNameIdentifierMapping(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNameIdentifierMapping, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNameIdentifierMapping);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoNameIdentifierMapping(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoNameIdentifierMapping TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoNameIdentifierMapping resource already free'd");
    delete_LassoNameIdentifierMapping(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoNameIdentifierMapping) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoNameIdentifierMapping. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoNameIdentifierMapping(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameIdentifierMapping_setIdentityFromDump) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_setIdentityFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameIdentifierMapping_setIdentityFromDump(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameIdentifierMapping_setSessionFromDump) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_setSessionFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameIdentifierMapping_setSessionFromDump(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameIdentifierMapping_buildRequestMsg) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_buildRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameIdentifierMapping_buildRequestMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameIdentifierMapping_buildResponseMsg) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_buildResponseMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameIdentifierMapping_buildResponseMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameIdentifierMapping_initRequest) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) NULL ;
    int result;
    zval **args[4];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(2-argbase) || arg_count>(3-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_initRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    if(arg_count > 2 - argbase) {
        convert_to_string_ex(args[2-argbase]);
        arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
        
    }
    {
        int errorCode;
        errorCode = result = (int)LassoNameIdentifierMapping_initRequest(arg1,arg2,arg3);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameIdentifierMapping_processRequestMsg) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_processRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameIdentifierMapping_processRequestMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameIdentifierMapping_processResponseMsg) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_processResponseMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameIdentifierMapping_processResponseMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameIdentifierMapping_validateRequest) {
    LassoNameIdentifierMapping *arg1 = (LassoNameIdentifierMapping *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameIdentifierMapping) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameIdentifierMapping_validateRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameIdentifierMapping->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameIdentifierMapping_validateRequest(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


/* property handler for class LassoNameIdentifierMapping */
static pval _wrap_propget_LassoNameIdentifierMapping(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoNameIdentifierMapping(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoNameIdentifierMapping(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"remoteProviderId")==0) {
    *value=_wrap_LassoNameIdentifierMapping_remoteProviderId_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"request")==0) {
    *value=_wrap_LassoNameIdentifierMapping_request_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"server")==0) {
    *value=_wrap_LassoNameIdentifierMapping_server_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"targetNameIdentifier")==0) {
    *value=_wrap_LassoNameIdentifierMapping_targetNameIdentifier_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"identity")==0) {
    *value=_wrap_LassoNameIdentifierMapping_identity_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgUrl")==0) {
    *value=_wrap_LassoNameIdentifierMapping_msgUrl_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"isIdentityDirty")==0) {
    *value=_wrap_LassoNameIdentifierMapping_isIdentityDirty_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"isSessionDirty")==0) {
    *value=_wrap_LassoNameIdentifierMapping_isSessionDirty_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"session")==0) {
    *value=_wrap_LassoNameIdentifierMapping_session_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgBody")==0) {
    *value=_wrap_LassoNameIdentifierMapping_msgBody_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"response")==0) {
    *value=_wrap_LassoNameIdentifierMapping_response_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"nameIdentifier")==0) {
    *value=_wrap_LassoNameIdentifierMapping_nameIdentifier_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoNameIdentifierMapping(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoNameIdentifierMapping(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoNameIdentifierMapping */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoNameIdentifierMapping(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"response")==0) {
    return _wrap_LassoNameIdentifierMapping_response_set(property_reference, value);
  } else  if (strcmp(propname,"nameIdentifier")==0) {
    return _wrap_LassoNameIdentifierMapping_nameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"remoteProviderId")==0) {
    return _wrap_LassoNameIdentifierMapping_remoteProviderId_set(property_reference, value);
  } else  if (strcmp(propname,"request")==0) {
    return _wrap_LassoNameIdentifierMapping_request_set(property_reference, value);
  } else  if (strcmp(propname,"server")==0) {
    return _wrap_LassoNameIdentifierMapping_server_set(property_reference, value);
  } else  if (strcmp(propname,"identity")==0) {
    return _wrap_LassoNameIdentifierMapping_identity_set(property_reference, value);
  } else  if (strcmp(propname,"session")==0) {
    return _wrap_LassoNameIdentifierMapping_session_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_LassoNameRegistration_identity_set(zend_property_reference *property_reference, pval *value) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoIdentity *arg2 = (LassoIdentity *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_identity_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoIdentity) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_identity_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoIdentity->name);
    }
    
    LassoNameRegistration_identity_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameRegistration_identity_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoIdentity *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_identity_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (LassoIdentity *)LassoNameRegistration_identity_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoIdentity, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoIdentity);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static pval _wrap_LassoNameRegistration_isIdentityDirty_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_isIdentityDirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (bool)LassoNameRegistration_isIdentityDirty_get(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoNameRegistration_isSessionDirty_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_isSessionDirty_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (bool)LassoNameRegistration_isSessionDirty_get(arg1);
    
    
    ZVAL_BOOL(return_value,(result)?1:0);
    
    return _return_value;
}


static pval _wrap_LassoNameRegistration_msgBody_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_msgBody_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (char *)LassoNameRegistration_msgBody_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static pval _wrap_LassoNameRegistration_msgRelayState_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_msgRelayState_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (char *)LassoNameRegistration_msgRelayState_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static pval _wrap_LassoNameRegistration_msgUrl_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_msgUrl_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (char *)LassoNameRegistration_msgUrl_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoNameRegistration_nameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_nameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_nameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoNameRegistration_nameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameRegistration_nameIdentifier_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_nameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoNameRegistration_nameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoNameRegistration_remoteProviderId_set(zend_property_reference *property_reference, pval *value) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    char *arg2 = (char *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_remoteProviderId_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    LassoNameRegistration_remoteProviderId_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameRegistration_remoteProviderId_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_remoteProviderId_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (char *)LassoNameRegistration_remoteProviderId_get(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
    return _return_value;
}


static int _wrap_LassoNameRegistration_request_set(zend_property_reference *property_reference, pval *value) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoSamlpRequestAbstract *arg2 = (LassoSamlpRequestAbstract *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_request_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&value)->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpRequestAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&value, (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_request_set. Expected %s",
            2-argbase, SWIGTYPE_p_LassoSamlpRequestAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoNameRegistration_request_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameRegistration_request_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoSamlpRequestAbstract *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_request_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (LassoSamlpRequestAbstract *)LassoNameRegistration_request_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoSamlpRequestAbstract, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoNameRegistration_response_set(zend_property_reference *property_reference, pval *value) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoSamlpResponseAbstract *arg2 = (LassoSamlpResponseAbstract *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_response_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    {
        node_info *info, *super;
        
        
        
        
        
        
        
        
        
        
        
        
        if ((*&value)->type == IS_NULL)
        arg2=0;
        else {
            for (info = node_infos; info->swig; info++) {
                for (super = info; super; super = super->super)
                if (super->swig == SWIGTYPE_p_LassoSamlpResponseAbstract)
                break;
                if (super && SWIG_ConvertPtr(*&value, (void **) &arg2, info->swig) >= 0)
                break;
            }
            if (! info->swig)
            zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_response_set. Expected %s",
            2-argbase, SWIGTYPE_p_LassoSamlpResponseAbstract->name);
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
    LassoNameRegistration_response_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameRegistration_response_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoSamlpResponseAbstract *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_response_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (LassoSamlpResponseAbstract *)LassoNameRegistration_response_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_LassoSamlpResponseAbstract, (void **) &result);
        SWIG_SetPointerZval(return_value, (void *)result, ty, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,get_node_info_with_swig(ty)->php);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoNameRegistration_server_set(zend_property_reference *property_reference, pval *value) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoServer *arg2 = (LassoServer *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_server_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoServer) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_server_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    LassoNameRegistration_server_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameRegistration_server_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoServer *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_server_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (LassoServer *)LassoNameRegistration_server_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoServer, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoServer);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoNameRegistration_session_set(zend_property_reference *property_reference, pval *value) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoSession *arg2 = (LassoSession *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_session_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSession) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_session_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSession->name);
    }
    
    LassoNameRegistration_session_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameRegistration_session_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoSession *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_session_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (LassoSession *)LassoNameRegistration_session_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSession, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSession);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


static int _wrap_LassoNameRegistration_oldNameIdentifier_set(zend_property_reference *property_reference, pval *value) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoSamlNameIdentifier *arg2 = (LassoSamlNameIdentifier *) 0 ;
    zval **args[3];
    int argbase=0 ;
    TSRMLS_FETCH();

    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_oldNameIdentifier_set. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    
    if (SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_LassoSamlNameIdentifier) < 0) {
        if ((*&value)->type == IS_NULL)
        arg2 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_oldNameIdentifier_set. Expected %s",
        2-argbase, SWIGTYPE_p_LassoSamlNameIdentifier->name);
    }
    
    LassoNameRegistration_oldNameIdentifier_set(arg1,arg2);
    
    
    return SUCCESS;
}


static pval _wrap_LassoNameRegistration_oldNameIdentifier_get(zend_property_reference *property_reference) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    LassoSamlNameIdentifier *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    TSRMLS_FETCH();

    
    
    if (SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*&(property_reference->object))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_oldNameIdentifier_get. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (LassoSamlNameIdentifier *)LassoNameRegistration_oldNameIdentifier_get(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoSamlNameIdentifier, 0);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoSamlNameIdentifier);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_LassoNameRegistration) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    LassoNameRegistration *result;
    zval **args[2];
    int argbase=0 ;
    
    /* NATIVE Constructor */
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of new_LassoNameRegistration. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    result = (LassoNameRegistration *)new_LassoNameRegistration(arg1);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNameRegistration, 1);
    /* Wrap this return value */
    if (this_ptr) {
        /* NATIVE Constructor, use this_ptr */
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    } else if (! this_ptr) {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNameRegistration);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


/* This function is designed to be called by the zend list destructors to typecast and do the actual destruction */
void __wrap_delete_LassoNameRegistration(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    
    efree(value);
    if (! newobject) return; /* can't delete it! */
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LassoNameRegistration TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LassoNameRegistration resource already free'd");
    delete_LassoNameRegistration(arg1);
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LassoNameRegistration) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of delete_LassoNameRegistration. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    /*if ((*args[0])->type==IS_RESOURCE) { */
    /*  Get zend list destructor to free it */
    /*  zend_list_delete(Z_LVAL_PP(args[0])); */
    /* } else {*/ 
    delete_LassoNameRegistration(arg1);
    
    /*}*/
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameRegistration_newFromDump) {
    LassoServer *arg1 = (LassoServer *) 0 ;
    char *arg2 = (char *) 0 ;
    LassoNameRegistration *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoServer) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_newFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoServer->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (LassoNameRegistration *)LassoNameRegistration_newFromDump(arg1,arg2);
    
    
    if (!result) {
        ZVAL_NULL(return_value);
    } else {
        SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LassoNameRegistration, 1);
    /* Wrap this return value */
    {
        /* ALTERNATIVE Constructor, make an object wrapper */
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LassoNameRegistration);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }}
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameRegistration_setIdentityFromDump) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_setIdentityFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameRegistration_setIdentityFromDump(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameRegistration_setSessionFromDump) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_setSessionFromDump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameRegistration_setSessionFromDump(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameRegistration_buildRequestMsg) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_buildRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameRegistration_buildRequestMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameRegistration_buildResponseMsg) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_buildResponseMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameRegistration_buildResponseMsg(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameRegistration_dump) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_dump. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    result = (char *)LassoNameRegistration_dump(arg1);
    
    
    if(!result) {
        ZVAL_NULL(return_value);
    } else {
        ZVAL_STRING(return_value,result, 1);
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameRegistration_initRequest) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    char *arg2 = (char *) 0 ;
    LassoHttpMethod arg3 = (LassoHttpMethod) LASSO_HTTP_METHOD_ANY ;
    int result;
    zval **args[4];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(2-argbase) || arg_count>(3-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_initRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    if(arg_count > 2 - argbase) {
        convert_to_long_ex(args[2-argbase]);
        arg3 = (LassoHttpMethod) Z_LVAL_PP(args[2-argbase]);
        
    }
    {
        int errorCode;
        errorCode = result = (int)LassoNameRegistration_initRequest(arg1,arg2,(LassoHttpMethod )arg3);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameRegistration_processRequestMsg) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_processRequestMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameRegistration_processRequestMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameRegistration_processResponseMsg) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    char *arg2 = (char *) 0 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_processResponseMsg. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameRegistration_processResponseMsg(arg1,arg2);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_LassoNameRegistration_validateRequest) {
    LassoNameRegistration *arg1 = (LassoNameRegistration *) 0 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        /* fake this_ptr as first arg (till we can work out how to do it better */
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if (SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LassoNameRegistration) < 0) {
        if ((*((0<argbase)?(&this_ptr):(args[0-argbase])))->type == IS_NULL)
        arg1 = 0;
        else
        zend_error(E_ERROR, "Type error in argument %d of LassoNameRegistration_validateRequest. Expected %s",
        1-argbase, SWIGTYPE_p_LassoNameRegistration->name);
    }
    
    {
        int errorCode;
        errorCode = result = (int)LassoNameRegistration_validateRequest(arg1);
        
        if (errorCode) {
            throw_exception_msg(errorCode);
        }
    }
    
    ZVAL_LONG(return_value,result);
    
}


/* property handler for class LassoNameRegistration */
static pval _wrap_propget_LassoNameRegistration(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LassoNameRegistration(property_reference, &result)==SUCCESS) return result;
  /* return it ourselves */
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) {
  zval *_value;
  MAKE_STD_ZVAL(_value);  *_value=**_result;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return *_value;
  }
  result.type = IS_NULL;
  return result;
}
static int _propget_LassoNameRegistration(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"remoteProviderId")==0) {
    *value=_wrap_LassoNameRegistration_remoteProviderId_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"request")==0) {
    *value=_wrap_LassoNameRegistration_request_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"server")==0) {
    *value=_wrap_LassoNameRegistration_server_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"identity")==0) {
    *value=_wrap_LassoNameRegistration_identity_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgUrl")==0) {
    *value=_wrap_LassoNameRegistration_msgUrl_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"isIdentityDirty")==0) {
    *value=_wrap_LassoNameRegistration_isIdentityDirty_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"isSessionDirty")==0) {
    *value=_wrap_LassoNameRegistration_isSessionDirty_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"session")==0) {
    *value=_wrap_LassoNameRegistration_session_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgBody")==0) {
    *value=_wrap_LassoNameRegistration_msgBody_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"response")==0) {
    *value=_wrap_LassoNameRegistration_response_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"msgRelayState")==0) {
    *value=_wrap_LassoNameRegistration_msgRelayState_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"nameIdentifier")==0) {
    *value=_wrap_LassoNameRegistration_nameIdentifier_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"oldNameIdentifier")==0) {
    *value=_wrap_LassoNameRegistration_oldNameIdentifier_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_LassoNameRegistration(zend_property_reference *property_reference, pval *value) { 
  zval * _value;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LassoNameRegistration(property_reference, value)==SUCCESS) return SUCCESS;
  /* set it ourselves as it is LassoNameRegistration */
  MAKE_STD_ZVAL(_value);
  *_value=*value;
  INIT_PZVAL(_value);
  zval_copy_ctor(_value);
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),1+Z_STRLEN_P(&(property->element)),_value);
}
static int _propset_LassoNameRegistration(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"response")==0) {
    return _wrap_LassoNameRegistration_response_set(property_reference, value);
  } else  if (strcmp(propname,"nameIdentifier")==0) {
    return _wrap_LassoNameRegistration_nameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"oldNameIdentifier")==0) {
    return _wrap_LassoNameRegistration_oldNameIdentifier_set(property_reference, value);
  } else  if (strcmp(propname,"remoteProviderId")==0) {
    return _wrap_LassoNameRegistration_remoteProviderId_set(property_reference, value);
  } else  if (strcmp(propname,"request")==0) {
    return _wrap_LassoNameRegistration_request_set(property_reference, value);
  } else  if (strcmp(propname,"server")==0) {
    return _wrap_LassoNameRegistration_server_set(property_reference, value);
  } else  if (strcmp(propname,"identity")==0) {
    return _wrap_LassoNameRegistration_identity_set(property_reference, value);
  } else  if (strcmp(propname,"session")==0) {
    return _wrap_LassoNameRegistration_session_set(property_reference, value);
  } else  return FAILURE;
}

/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoMdProtocolType) {
/* bah! No destructor for this simple type!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoNodeList) {
/* has destructor: __wrap_delete_LassoNodeList */
__wrap_delete_LassoNodeList(rsrc, SWIGTYPE_p_LassoNodeList->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlpStatusCode) {
/* has destructor: __wrap_delete_LassoSamlpStatusCode */
__wrap_delete_LassoSamlpStatusCode(rsrc, SWIGTYPE_p_LassoSamlpStatusCode->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlAudienceRestrictionCondition) {
/* has destructor: __wrap_delete_LassoSamlAudienceRestrictionCondition */
__wrap_delete_LassoSamlAudienceRestrictionCondition(rsrc, SWIGTYPE_p_LassoSamlAudienceRestrictionCondition->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlConditions) {
/* has destructor: __wrap_delete_LassoSamlConditions */
__wrap_delete_LassoSamlConditions(rsrc, SWIGTYPE_p_LassoSamlConditions->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLogout) {
/* has destructor: __wrap_delete_LassoLogout */
__wrap_delete_LassoLogout(rsrc, SWIGTYPE_p_LassoLogout->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlSubjectStatement) {
/* has destructor: __wrap_delete_LassoSamlSubjectStatement */
__wrap_delete_LassoSamlSubjectStatement(rsrc, SWIGTYPE_p_LassoSamlSubjectStatement->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlAuthenticationStatement) {
/* has destructor: __wrap_delete_LassoSamlAuthenticationStatement */
__wrap_delete_LassoSamlAuthenticationStatement(rsrc, SWIGTYPE_p_LassoSamlAuthenticationStatement->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlAttributeStatement) {
/* has destructor: __wrap_delete_LassoSamlAttributeStatement */
__wrap_delete_LassoSamlAttributeStatement(rsrc, SWIGTYPE_p_LassoSamlAttributeStatement->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_char) {
/* bah! No destructor for this simple type!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLibFederationTerminationNotification) {
/* has destructor: __wrap_delete_LassoLibFederationTerminationNotification */
__wrap_delete_LassoLibFederationTerminationNotification(rsrc, SWIGTYPE_p_LassoLibFederationTerminationNotification->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlpRequestAbstract) {
/* bah! No destructor for this wrapped class!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlSubjectStatementAbstract) {
/* bah! No destructor for this wrapped class!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlStatementAbstract) {
/* bah! No destructor for this wrapped class!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlConditionAbstract) {
/* bah! No destructor for this wrapped class!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoHttpMethod) {
/* bah! No destructor for this simple type!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlpResponseAbstract) {
/* bah! No destructor for this wrapped class!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoStringList) {
/* has destructor: __wrap_delete_LassoStringList */
__wrap_delete_LassoStringList(rsrc, SWIGTYPE_p_LassoStringList->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_void) {
/* bah! No destructor for this simple type!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_int) {
/* bah! No destructor for this simple type!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoFederation) {
/* has destructor: __wrap_delete_LassoFederation */
__wrap_delete_LassoFederation(rsrc, SWIGTYPE_p_LassoFederation->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoDefederation) {
/* has destructor: __wrap_delete_LassoDefederation */
__wrap_delete_LassoDefederation(rsrc, SWIGTYPE_p_LassoDefederation->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLogin) {
/* has destructor: __wrap_delete_LassoLogin */
__wrap_delete_LassoLogin(rsrc, SWIGTYPE_p_LassoLogin->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoCheckVersionMode) {
/* bah! No destructor for this simple type!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlAuthorityBinding) {
/* has destructor: __wrap_delete_LassoSamlAuthorityBinding */
__wrap_delete_LassoSamlAuthorityBinding(rsrc, SWIGTYPE_p_LassoSamlAuthorityBinding->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoRequestType) {
/* bah! No destructor for this simple type!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlpRequest) {
/* has destructor: __wrap_delete_LassoSamlpRequest */
__wrap_delete_LassoSamlpRequest(rsrc, SWIGTYPE_p_LassoSamlpRequest->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLibAuthnRequest) {
/* has destructor: __wrap_delete_LassoLibAuthnRequest */
__wrap_delete_LassoLibAuthnRequest(rsrc, SWIGTYPE_p_LassoLibAuthnRequest->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLibLogoutRequest) {
/* has destructor: __wrap_delete_LassoLibLogoutRequest */
__wrap_delete_LassoLibLogoutRequest(rsrc, SWIGTYPE_p_LassoLibLogoutRequest->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLibRegisterNameIdentifierRequest) {
/* has destructor: __wrap_delete_LassoLibRegisterNameIdentifierRequest */
__wrap_delete_LassoLibRegisterNameIdentifierRequest(rsrc, SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSignatureType) {
/* bah! No destructor for this simple type!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlAdvice) {
/* has destructor: __wrap_delete_LassoSamlAdvice */
__wrap_delete_LassoSamlAdvice(rsrc, SWIGTYPE_p_LassoSamlAdvice->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlAssertion) {
/* has destructor: __wrap_delete_LassoSamlAssertion */
__wrap_delete_LassoSamlAssertion(rsrc, SWIGTYPE_p_LassoSamlAssertion->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLibAssertion) {
/* has destructor: __wrap_delete_LassoLibAssertion */
__wrap_delete_LassoLibAssertion(rsrc, SWIGTYPE_p_LassoLibAssertion->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLecp) {
/* has destructor: __wrap_delete_LassoLecp */
__wrap_delete_LassoLecp(rsrc, SWIGTYPE_p_LassoLecp->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSignatureMethod) {
/* bah! No destructor for this simple type!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLibRequestAuthnContext) {
/* has destructor: __wrap_delete_LassoLibRequestAuthnContext */
__wrap_delete_LassoLibRequestAuthnContext(rsrc, SWIGTYPE_p_LassoLibRequestAuthnContext->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLoginProtocolProfile) {
/* bah! No destructor for this simple type!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlNameIdentifier) {
/* has destructor: __wrap_delete_LassoSamlNameIdentifier */
__wrap_delete_LassoSamlNameIdentifier(rsrc, SWIGTYPE_p_LassoSamlNameIdentifier->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoNameRegistration) {
/* has destructor: __wrap_delete_LassoNameRegistration */
__wrap_delete_LassoNameRegistration(rsrc, SWIGTYPE_p_LassoNameRegistration->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlSubject) {
/* has destructor: __wrap_delete_LassoSamlSubject */
__wrap_delete_LassoSamlSubject(rsrc, SWIGTYPE_p_LassoSamlSubject->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlAttributeDesignator) {
/* has destructor: __wrap_delete_LassoSamlAttributeDesignator */
__wrap_delete_LassoSamlAttributeDesignator(rsrc, SWIGTYPE_p_LassoSamlAttributeDesignator->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlpResponse) {
/* has destructor: __wrap_delete_LassoSamlpResponse */
__wrap_delete_LassoSamlpResponse(rsrc, SWIGTYPE_p_LassoSamlpResponse->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLibAuthnResponse) {
/* has destructor: __wrap_delete_LassoLibAuthnResponse */
__wrap_delete_LassoLibAuthnResponse(rsrc, SWIGTYPE_p_LassoLibAuthnResponse->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLibLogoutResponse) {
/* has destructor: __wrap_delete_LassoLibLogoutResponse */
__wrap_delete_LassoLibLogoutResponse(rsrc, SWIGTYPE_p_LassoLibLogoutResponse->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLibRegisterNameIdentifierResponse) {
/* has destructor: __wrap_delete_LassoLibRegisterNameIdentifierResponse */
__wrap_delete_LassoLibRegisterNameIdentifierResponse(rsrc, SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoLibStatusResponse) {
/* has destructor: __wrap_delete_LassoLibStatusResponse */
__wrap_delete_LassoLibStatusResponse(rsrc, SWIGTYPE_p_LassoLibStatusResponse->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoServer) {
/* has destructor: __wrap_delete_LassoServer */
__wrap_delete_LassoServer(rsrc, SWIGTYPE_p_LassoServer->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSession) {
/* has destructor: __wrap_delete_LassoSession */
__wrap_delete_LassoSession(rsrc, SWIGTYPE_p_LassoSession->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlAttribute) {
/* has destructor: __wrap_delete_LassoSamlAttribute */
__wrap_delete_LassoSamlAttribute(rsrc, SWIGTYPE_p_LassoSamlAttribute->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlpStatus) {
/* has destructor: __wrap_delete_LassoSamlpStatus */
__wrap_delete_LassoSamlpStatus(rsrc, SWIGTYPE_p_LassoSamlpStatus->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoIdentity) {
/* has destructor: __wrap_delete_LassoIdentity */
__wrap_delete_LassoIdentity(rsrc, SWIGTYPE_p_LassoIdentity->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoProviderRole) {
/* bah! No destructor for this simple type!! */
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlSubjectLocality) {
/* has destructor: __wrap_delete_LassoSamlSubjectLocality */
__wrap_delete_LassoSamlSubjectLocality(rsrc, SWIGTYPE_p_LassoSamlSubjectLocality->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlSubjectConfirmation) {
/* has destructor: __wrap_delete_LassoSamlSubjectConfirmation */
__wrap_delete_LassoSamlSubjectConfirmation(rsrc, SWIGTYPE_p_LassoSamlSubjectConfirmation->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoSamlAttributeValue) {
/* has destructor: __wrap_delete_LassoSamlAttributeValue */
__wrap_delete_LassoSamlAttributeValue(rsrc, SWIGTYPE_p_LassoSamlAttributeValue->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoProvider) {
/* has destructor: __wrap_delete_LassoProvider */
__wrap_delete_LassoProvider(rsrc, SWIGTYPE_p_LassoProvider->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoNameIdentifierMapping) {
/* has destructor: __wrap_delete_LassoNameIdentifierMapping */
__wrap_delete_LassoNameIdentifierMapping(rsrc, SWIGTYPE_p_LassoNameIdentifierMapping->name TSRMLS_CC);
}
/* NEW Destructor style */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LassoNode) {
/* has destructor: __wrap_delete_LassoNode */
__wrap_delete_LassoNode(rsrc, SWIGTYPE_p_LassoNode->name TSRMLS_CC);
}




/* end wrapper section */
/* init section */
#ifdef __cplusplus
extern "C" {
#endif
ZEND_GET_MODULE(lasso)
#ifdef __cplusplus
}
#endif

PHP_MSHUTDOWN_FUNCTION(lasso)
{
    return SUCCESS;
}
PHP_MINIT_FUNCTION(lasso)
{
    int i;
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }

   SWIGTYPE_p_LassoNode->dcast = (swig_dycast_func) dynamic_cast_node;


   SWIGTYPE_p_LassoSamlpRequestAbstract->dcast = (swig_dycast_func) dynamic_cast_node;


   SWIGTYPE_p_LassoSamlpResponseAbstract->dcast = (swig_dycast_func) dynamic_cast_node;


{ /* Brace needed for pre-C99 compilers */
	node_info *info;

	info = node_infos;
#ifdef PHP_VERSION
	set_node_info(info++, "LassoNode", NULL, SWIGTYPE_p_LassoNode, &ce_swig_LassoNode);
#define SET_NODE_INFO(className, superClassName)\
	set_node_info(info++, "Lasso"#className, "Lasso"#superClassName,\
			SWIGTYPE_p_Lasso##className, &ce_swig_Lasso##className);
#else
	set_node_info(info++, "LassoNode", NULL, SWIGTYPE_p_LassoNode);
#define SET_NODE_INFO(className, superClassName)\
	set_node_info(info++, "Lasso"#className, "Lasso"#superClassName,\
			SWIGTYPE_p_Lasso##className);
#endif

#include <swig/inheritance.h>

	info->name = NULL;
	info->swig = NULL;
}

/* oinit subsection */
/* Define class LassoNode */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoNode,"lassonode",LassoNode_functions,NULL,_wrap_propget_LassoNode,_wrap_propset_LassoNode);
if (! (ptr_ce_swig_LassoNode=zend_register_internal_class_ex(&ce_swig_LassoNode,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoNode");

/* Define class LassoNodeList */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoNodeList,"lassonodelist",LassoNodeList_functions,NULL,_wrap_propget_LassoNodeList,_wrap_propset_LassoNodeList);
if (! (ptr_ce_swig_LassoNodeList=zend_register_internal_class_ex(&ce_swig_LassoNodeList,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoNodeList");

/* Define class LassoStringList */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoStringList,"lassostringlist",LassoStringList_functions,NULL,_wrap_propget_LassoStringList,_wrap_propset_LassoStringList);
if (! (ptr_ce_swig_LassoStringList=zend_register_internal_class_ex(&ce_swig_LassoStringList,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoStringList");

/* Define class LassoSamlAdvice */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlAdvice,"lassosamladvice",LassoSamlAdvice_functions,NULL,_wrap_propget_LassoSamlAdvice,_wrap_propset_LassoSamlAdvice);
if (! (ptr_ce_swig_LassoSamlAdvice=zend_register_internal_class_ex(&ce_swig_LassoSamlAdvice,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlAdvice");

/* Define class LassoSamlAssertion */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlAssertion,"lassosamlassertion",LassoSamlAssertion_functions,NULL,_wrap_propget_LassoSamlAssertion,_wrap_propset_LassoSamlAssertion);
if (! (ptr_ce_swig_LassoSamlAssertion=zend_register_internal_class_ex(&ce_swig_LassoSamlAssertion,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlAssertion");

/* Define class LassoSamlAttribute */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlAttribute,"lassosamlattribute",LassoSamlAttribute_functions,NULL,_wrap_propget_LassoSamlAttribute,_wrap_propset_LassoSamlAttribute);
if (! (ptr_ce_swig_LassoSamlAttribute=zend_register_internal_class_ex(&ce_swig_LassoSamlAttribute,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlAttribute");

/* Define class LassoSamlAttributeDesignator */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlAttributeDesignator,"lassosamlattributedesignator",LassoSamlAttributeDesignator_functions,NULL,_wrap_propget_LassoSamlAttributeDesignator,_wrap_propset_LassoSamlAttributeDesignator);
if (! (ptr_ce_swig_LassoSamlAttributeDesignator=zend_register_internal_class_ex(&ce_swig_LassoSamlAttributeDesignator,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlAttributeDesignator");

/* Define class LassoSamlAttributeStatement */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlAttributeStatement,"lassosamlattributestatement",LassoSamlAttributeStatement_functions,NULL,_wrap_propget_LassoSamlAttributeStatement,_wrap_propset_LassoSamlAttributeStatement);
if (! (ptr_ce_swig_LassoSamlAttributeStatement=zend_register_internal_class_ex(&ce_swig_LassoSamlAttributeStatement,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlAttributeStatement");

/* Define class LassoSamlAttributeValue */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlAttributeValue,"lassosamlattributevalue",LassoSamlAttributeValue_functions,NULL,_wrap_propget_LassoSamlAttributeValue,_wrap_propset_LassoSamlAttributeValue);
if (! (ptr_ce_swig_LassoSamlAttributeValue=zend_register_internal_class_ex(&ce_swig_LassoSamlAttributeValue,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlAttributeValue");

/* Define class LassoSamlAudienceRestrictionCondition */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlAudienceRestrictionCondition,"lassosamlaudiencerestrictioncondition",LassoSamlAudienceRestrictionCondition_functions,NULL,_wrap_propget_LassoSamlAudienceRestrictionCondition,_wrap_propset_LassoSamlAudienceRestrictionCondition);
if (! (ptr_ce_swig_LassoSamlAudienceRestrictionCondition=zend_register_internal_class_ex(&ce_swig_LassoSamlAudienceRestrictionCondition,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlAudienceRestrictionCondition");

/* Define class LassoSamlAuthenticationStatement */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlAuthenticationStatement,"lassosamlauthenticationstatement",LassoSamlAuthenticationStatement_functions,NULL,_wrap_propget_LassoSamlAuthenticationStatement,_wrap_propset_LassoSamlAuthenticationStatement);
if (! (ptr_ce_swig_LassoSamlAuthenticationStatement=zend_register_internal_class_ex(&ce_swig_LassoSamlAuthenticationStatement,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlAuthenticationStatement");

/* Define class LassoSamlAuthorityBinding */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlAuthorityBinding,"lassosamlauthoritybinding",LassoSamlAuthorityBinding_functions,NULL,_wrap_propget_LassoSamlAuthorityBinding,_wrap_propset_LassoSamlAuthorityBinding);
if (! (ptr_ce_swig_LassoSamlAuthorityBinding=zend_register_internal_class_ex(&ce_swig_LassoSamlAuthorityBinding,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlAuthorityBinding");

/* Define class LassoSamlConditionAbstract */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlConditionAbstract,"lassosamlconditionabstract",LassoSamlConditionAbstract_functions,NULL,_wrap_propget_LassoSamlConditionAbstract,_wrap_propset_LassoSamlConditionAbstract);
if (! (ptr_ce_swig_LassoSamlConditionAbstract=zend_register_internal_class_ex(&ce_swig_LassoSamlConditionAbstract,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlConditionAbstract");

/* Define class LassoSamlConditions */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlConditions,"lassosamlconditions",LassoSamlConditions_functions,NULL,_wrap_propget_LassoSamlConditions,_wrap_propset_LassoSamlConditions);
if (! (ptr_ce_swig_LassoSamlConditions=zend_register_internal_class_ex(&ce_swig_LassoSamlConditions,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlConditions");

/* Define class LassoSamlNameIdentifier */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlNameIdentifier,"lassosamlnameidentifier",LassoSamlNameIdentifier_functions,NULL,_wrap_propget_LassoSamlNameIdentifier,_wrap_propset_LassoSamlNameIdentifier);
if (! (ptr_ce_swig_LassoSamlNameIdentifier=zend_register_internal_class_ex(&ce_swig_LassoSamlNameIdentifier,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlNameIdentifier");

/* Define class LassoSamlStatementAbstract */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlStatementAbstract,"lassosamlstatementabstract",LassoSamlStatementAbstract_functions,NULL,_wrap_propget_LassoSamlStatementAbstract,_wrap_propset_LassoSamlStatementAbstract);
if (! (ptr_ce_swig_LassoSamlStatementAbstract=zend_register_internal_class_ex(&ce_swig_LassoSamlStatementAbstract,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlStatementAbstract");

/* Define class LassoSamlSubject */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlSubject,"lassosamlsubject",LassoSamlSubject_functions,NULL,_wrap_propget_LassoSamlSubject,_wrap_propset_LassoSamlSubject);
if (! (ptr_ce_swig_LassoSamlSubject=zend_register_internal_class_ex(&ce_swig_LassoSamlSubject,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlSubject");

/* Define class LassoSamlSubjectConfirmation */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlSubjectConfirmation,"lassosamlsubjectconfirmation",LassoSamlSubjectConfirmation_functions,NULL,_wrap_propget_LassoSamlSubjectConfirmation,_wrap_propset_LassoSamlSubjectConfirmation);
if (! (ptr_ce_swig_LassoSamlSubjectConfirmation=zend_register_internal_class_ex(&ce_swig_LassoSamlSubjectConfirmation,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlSubjectConfirmation");

/* Define class LassoSamlSubjectLocality */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlSubjectLocality,"lassosamlsubjectlocality",LassoSamlSubjectLocality_functions,NULL,_wrap_propget_LassoSamlSubjectLocality,_wrap_propset_LassoSamlSubjectLocality);
if (! (ptr_ce_swig_LassoSamlSubjectLocality=zend_register_internal_class_ex(&ce_swig_LassoSamlSubjectLocality,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlSubjectLocality");

/* Define class LassoSamlSubjectStatement */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlSubjectStatement,"lassosamlsubjectstatement",LassoSamlSubjectStatement_functions,NULL,_wrap_propget_LassoSamlSubjectStatement,_wrap_propset_LassoSamlSubjectStatement);
if (! (ptr_ce_swig_LassoSamlSubjectStatement=zend_register_internal_class_ex(&ce_swig_LassoSamlSubjectStatement,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlSubjectStatement");

/* Define class LassoSamlSubjectStatementAbstract */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlSubjectStatementAbstract,"lassosamlsubjectstatementabstract",LassoSamlSubjectStatementAbstract_functions,NULL,_wrap_propget_LassoSamlSubjectStatementAbstract,_wrap_propset_LassoSamlSubjectStatementAbstract);
if (! (ptr_ce_swig_LassoSamlSubjectStatementAbstract=zend_register_internal_class_ex(&ce_swig_LassoSamlSubjectStatementAbstract,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlSubjectStatementAbstract");

/* Define class LassoSamlpRequest */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlpRequest,"lassosamlprequest",LassoSamlpRequest_functions,NULL,_wrap_propget_LassoSamlpRequest,_wrap_propset_LassoSamlpRequest);
if (! (ptr_ce_swig_LassoSamlpRequest=zend_register_internal_class_ex(&ce_swig_LassoSamlpRequest,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlpRequest");

/* Define class LassoSamlpRequestAbstract */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlpRequestAbstract,"lassosamlprequestabstract",LassoSamlpRequestAbstract_functions,NULL,_wrap_propget_LassoSamlpRequestAbstract,_wrap_propset_LassoSamlpRequestAbstract);
if (! (ptr_ce_swig_LassoSamlpRequestAbstract=zend_register_internal_class_ex(&ce_swig_LassoSamlpRequestAbstract,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlpRequestAbstract");

/* Define class LassoSamlpResponse */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlpResponse,"lassosamlpresponse",LassoSamlpResponse_functions,NULL,_wrap_propget_LassoSamlpResponse,_wrap_propset_LassoSamlpResponse);
if (! (ptr_ce_swig_LassoSamlpResponse=zend_register_internal_class_ex(&ce_swig_LassoSamlpResponse,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlpResponse");

/* Define class LassoSamlpResponseAbstract */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlpResponseAbstract,"lassosamlpresponseabstract",LassoSamlpResponseAbstract_functions,NULL,_wrap_propget_LassoSamlpResponseAbstract,_wrap_propset_LassoSamlpResponseAbstract);
if (! (ptr_ce_swig_LassoSamlpResponseAbstract=zend_register_internal_class_ex(&ce_swig_LassoSamlpResponseAbstract,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlpResponseAbstract");

/* Define class LassoSamlpStatus */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlpStatus,"lassosamlpstatus",LassoSamlpStatus_functions,NULL,_wrap_propget_LassoSamlpStatus,_wrap_propset_LassoSamlpStatus);
if (! (ptr_ce_swig_LassoSamlpStatus=zend_register_internal_class_ex(&ce_swig_LassoSamlpStatus,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlpStatus");

/* Define class LassoSamlpStatusCode */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSamlpStatusCode,"lassosamlpstatuscode",LassoSamlpStatusCode_functions,NULL,_wrap_propget_LassoSamlpStatusCode,_wrap_propset_LassoSamlpStatusCode);
if (! (ptr_ce_swig_LassoSamlpStatusCode=zend_register_internal_class_ex(&ce_swig_LassoSamlpStatusCode,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSamlpStatusCode");

/* Define class LassoLibAssertion */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLibAssertion,"lassolibassertion",LassoLibAssertion_functions,NULL,_wrap_propget_LassoLibAssertion,_wrap_propset_LassoLibAssertion);
if (! (ptr_ce_swig_LassoLibAssertion=zend_register_internal_class_ex(&ce_swig_LassoLibAssertion,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLibAssertion");

/* Define class LassoLibAuthnRequest */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLibAuthnRequest,"lassolibauthnrequest",LassoLibAuthnRequest_functions,NULL,_wrap_propget_LassoLibAuthnRequest,_wrap_propset_LassoLibAuthnRequest);
if (! (ptr_ce_swig_LassoLibAuthnRequest=zend_register_internal_class_ex(&ce_swig_LassoLibAuthnRequest,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLibAuthnRequest");

/* Define class LassoLibAuthnResponse */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLibAuthnResponse,"lassolibauthnresponse",LassoLibAuthnResponse_functions,NULL,_wrap_propget_LassoLibAuthnResponse,_wrap_propset_LassoLibAuthnResponse);
if (! (ptr_ce_swig_LassoLibAuthnResponse=zend_register_internal_class_ex(&ce_swig_LassoLibAuthnResponse,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLibAuthnResponse");

/* Define class LassoLibFederationTerminationNotification */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLibFederationTerminationNotification,"lassolibfederationterminationnotification",LassoLibFederationTerminationNotification_functions,NULL,_wrap_propget_LassoLibFederationTerminationNotification,_wrap_propset_LassoLibFederationTerminationNotification);
if (! (ptr_ce_swig_LassoLibFederationTerminationNotification=zend_register_internal_class_ex(&ce_swig_LassoLibFederationTerminationNotification,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLibFederationTerminationNotification");

/* Define class LassoLibLogoutRequest */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLibLogoutRequest,"lassoliblogoutrequest",LassoLibLogoutRequest_functions,NULL,_wrap_propget_LassoLibLogoutRequest,_wrap_propset_LassoLibLogoutRequest);
if (! (ptr_ce_swig_LassoLibLogoutRequest=zend_register_internal_class_ex(&ce_swig_LassoLibLogoutRequest,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLibLogoutRequest");

/* Define class LassoLibLogoutResponse */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLibLogoutResponse,"lassoliblogoutresponse",LassoLibLogoutResponse_functions,NULL,_wrap_propget_LassoLibLogoutResponse,_wrap_propset_LassoLibLogoutResponse);
if (! (ptr_ce_swig_LassoLibLogoutResponse=zend_register_internal_class_ex(&ce_swig_LassoLibLogoutResponse,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLibLogoutResponse");

/* Define class LassoLibRegisterNameIdentifierRequest */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLibRegisterNameIdentifierRequest,"lassolibregisternameidentifierrequest",LassoLibRegisterNameIdentifierRequest_functions,NULL,_wrap_propget_LassoLibRegisterNameIdentifierRequest,_wrap_propset_LassoLibRegisterNameIdentifierRequest);
if (! (ptr_ce_swig_LassoLibRegisterNameIdentifierRequest=zend_register_internal_class_ex(&ce_swig_LassoLibRegisterNameIdentifierRequest,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLibRegisterNameIdentifierRequest");

/* Define class LassoLibRegisterNameIdentifierResponse */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLibRegisterNameIdentifierResponse,"lassolibregisternameidentifierresponse",LassoLibRegisterNameIdentifierResponse_functions,NULL,_wrap_propget_LassoLibRegisterNameIdentifierResponse,_wrap_propset_LassoLibRegisterNameIdentifierResponse);
if (! (ptr_ce_swig_LassoLibRegisterNameIdentifierResponse=zend_register_internal_class_ex(&ce_swig_LassoLibRegisterNameIdentifierResponse,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLibRegisterNameIdentifierResponse");

/* Define class LassoLibRequestAuthnContext */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLibRequestAuthnContext,"lassolibrequestauthncontext",LassoLibRequestAuthnContext_functions,NULL,_wrap_propget_LassoLibRequestAuthnContext,_wrap_propset_LassoLibRequestAuthnContext);
if (! (ptr_ce_swig_LassoLibRequestAuthnContext=zend_register_internal_class_ex(&ce_swig_LassoLibRequestAuthnContext,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLibRequestAuthnContext");

/* Define class LassoLibStatusResponse */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLibStatusResponse,"lassolibstatusresponse",LassoLibStatusResponse_functions,NULL,_wrap_propget_LassoLibStatusResponse,_wrap_propset_LassoLibStatusResponse);
if (! (ptr_ce_swig_LassoLibStatusResponse=zend_register_internal_class_ex(&ce_swig_LassoLibStatusResponse,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLibStatusResponse");

/* Define class LassoProvider */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoProvider,"lassoprovider",LassoProvider_functions,NULL,_wrap_propget_LassoProvider,_wrap_propset_LassoProvider);
if (! (ptr_ce_swig_LassoProvider=zend_register_internal_class_ex(&ce_swig_LassoProvider,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoProvider");

/* Define class LassoServer */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoServer,"lassoserver",LassoServer_functions,NULL,_wrap_propget_LassoServer,_wrap_propset_LassoServer);
if (! (ptr_ce_swig_LassoServer=zend_register_internal_class_ex(&ce_swig_LassoServer,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoServer");

/* Define class LassoFederation */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoFederation,"lassofederation",LassoFederation_functions,NULL,_wrap_propget_LassoFederation,_wrap_propset_LassoFederation);
if (! (ptr_ce_swig_LassoFederation=zend_register_internal_class_ex(&ce_swig_LassoFederation,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoFederation");

/* Define class LassoIdentity */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoIdentity,"lassoidentity",LassoIdentity_functions,NULL,_wrap_propget_LassoIdentity,_wrap_propset_LassoIdentity);
if (! (ptr_ce_swig_LassoIdentity=zend_register_internal_class_ex(&ce_swig_LassoIdentity,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoIdentity");

/* Define class LassoSession */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoSession,"lassosession",LassoSession_functions,NULL,_wrap_propget_LassoSession,_wrap_propset_LassoSession);
if (! (ptr_ce_swig_LassoSession=zend_register_internal_class_ex(&ce_swig_LassoSession,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoSession");

/* Define class LassoDefederation */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoDefederation,"lassodefederation",LassoDefederation_functions,NULL,_wrap_propget_LassoDefederation,_wrap_propset_LassoDefederation);
if (! (ptr_ce_swig_LassoDefederation=zend_register_internal_class_ex(&ce_swig_LassoDefederation,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoDefederation");

/* Define class LassoLogin */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLogin,"lassologin",LassoLogin_functions,NULL,_wrap_propget_LassoLogin,_wrap_propset_LassoLogin);
if (! (ptr_ce_swig_LassoLogin=zend_register_internal_class_ex(&ce_swig_LassoLogin,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLogin");

/* Define class LassoLogout */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLogout,"lassologout",LassoLogout_functions,NULL,_wrap_propget_LassoLogout,_wrap_propset_LassoLogout);
if (! (ptr_ce_swig_LassoLogout=zend_register_internal_class_ex(&ce_swig_LassoLogout,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLogout");

/* Define class LassoLecp */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoLecp,"lassolecp",LassoLecp_functions,NULL,_wrap_propget_LassoLecp,_wrap_propset_LassoLecp);
if (! (ptr_ce_swig_LassoLecp=zend_register_internal_class_ex(&ce_swig_LassoLecp,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoLecp");

/* Define class LassoNameIdentifierMapping */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoNameIdentifierMapping,"lassonameidentifiermapping",LassoNameIdentifierMapping_functions,NULL,_wrap_propget_LassoNameIdentifierMapping,_wrap_propset_LassoNameIdentifierMapping);
if (! (ptr_ce_swig_LassoNameIdentifierMapping=zend_register_internal_class_ex(&ce_swig_LassoNameIdentifierMapping,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoNameIdentifierMapping");

/* Define class LassoNameRegistration */
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LassoNameRegistration,"lassonameregistration",LassoNameRegistration_functions,NULL,_wrap_propget_LassoNameRegistration,_wrap_propset_LassoNameRegistration);
if (! (ptr_ce_swig_LassoNameRegistration=zend_register_internal_class_ex(&ce_swig_LassoNameRegistration,NULL,NULL TSRMLS_CC))) zend_error(E_ERROR,"Error registering wrapper for class LassoNameRegistration");


/* Register resource destructors for pointer types */
le_swig__p_LassoMdProtocolType=zend_register_list_destructors_ex(_wrap_destroy_p_LassoMdProtocolType,NULL,(char *)(SWIGTYPE_p_LassoMdProtocolType->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoMdProtocolType,&le_swig__p_LassoMdProtocolType);
le_swig__p_LassoNodeList=zend_register_list_destructors_ex(_wrap_destroy_p_LassoNodeList,NULL,(char *)(SWIGTYPE_p_LassoNodeList->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoNodeList,&le_swig__p_LassoNodeList);
le_swig__p_LassoSamlpStatusCode=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlpStatusCode,NULL,(char *)(SWIGTYPE_p_LassoSamlpStatusCode->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlpStatusCode,&le_swig__p_LassoSamlpStatusCode);
le_swig__p_LassoSamlAudienceRestrictionCondition=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlAudienceRestrictionCondition,NULL,(char *)(SWIGTYPE_p_LassoSamlAudienceRestrictionCondition->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlAudienceRestrictionCondition,&le_swig__p_LassoSamlAudienceRestrictionCondition);
le_swig__p_LassoSamlConditions=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlConditions,NULL,(char *)(SWIGTYPE_p_LassoSamlConditions->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlConditions,&le_swig__p_LassoSamlConditions);
le_swig__p_LassoLogout=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLogout,NULL,(char *)(SWIGTYPE_p_LassoLogout->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLogout,&le_swig__p_LassoLogout);
le_swig__p_LassoSamlSubjectStatement=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlSubjectStatement,NULL,(char *)(SWIGTYPE_p_LassoSamlSubjectStatement->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlSubjectStatement,&le_swig__p_LassoSamlSubjectStatement);
le_swig__p_LassoSamlAuthenticationStatement=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlAuthenticationStatement,NULL,(char *)(SWIGTYPE_p_LassoSamlAuthenticationStatement->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlAuthenticationStatement,&le_swig__p_LassoSamlAuthenticationStatement);
le_swig__p_LassoSamlAttributeStatement=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlAttributeStatement,NULL,(char *)(SWIGTYPE_p_LassoSamlAttributeStatement->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlAttributeStatement,&le_swig__p_LassoSamlAttributeStatement);
le_swig__p_char=zend_register_list_destructors_ex(_wrap_destroy_p_char,NULL,(char *)(SWIGTYPE_p_char->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_char,&le_swig__p_char);
le_swig__p_LassoLibFederationTerminationNotification=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLibFederationTerminationNotification,NULL,(char *)(SWIGTYPE_p_LassoLibFederationTerminationNotification->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLibFederationTerminationNotification,&le_swig__p_LassoLibFederationTerminationNotification);
le_swig__p_LassoSamlpRequestAbstract=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlpRequestAbstract,NULL,(char *)(SWIGTYPE_p_LassoSamlpRequestAbstract->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlpRequestAbstract,&le_swig__p_LassoSamlpRequestAbstract);
le_swig__p_LassoSamlSubjectStatementAbstract=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlSubjectStatementAbstract,NULL,(char *)(SWIGTYPE_p_LassoSamlSubjectStatementAbstract->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlSubjectStatementAbstract,&le_swig__p_LassoSamlSubjectStatementAbstract);
le_swig__p_LassoSamlStatementAbstract=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlStatementAbstract,NULL,(char *)(SWIGTYPE_p_LassoSamlStatementAbstract->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlStatementAbstract,&le_swig__p_LassoSamlStatementAbstract);
le_swig__p_LassoSamlConditionAbstract=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlConditionAbstract,NULL,(char *)(SWIGTYPE_p_LassoSamlConditionAbstract->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlConditionAbstract,&le_swig__p_LassoSamlConditionAbstract);
le_swig__p_LassoHttpMethod=zend_register_list_destructors_ex(_wrap_destroy_p_LassoHttpMethod,NULL,(char *)(SWIGTYPE_p_LassoHttpMethod->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoHttpMethod,&le_swig__p_LassoHttpMethod);
le_swig__p_LassoSamlpResponseAbstract=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlpResponseAbstract,NULL,(char *)(SWIGTYPE_p_LassoSamlpResponseAbstract->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlpResponseAbstract,&le_swig__p_LassoSamlpResponseAbstract);
le_swig__p_LassoStringList=zend_register_list_destructors_ex(_wrap_destroy_p_LassoStringList,NULL,(char *)(SWIGTYPE_p_LassoStringList->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoStringList,&le_swig__p_LassoStringList);
le_swig__p_void=zend_register_list_destructors_ex(_wrap_destroy_p_void,NULL,(char *)(SWIGTYPE_p_void->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_void,&le_swig__p_void);
le_swig__int=zend_register_list_destructors_ex(_wrap_destroy_int,NULL,(char *)(SWIGTYPE_int->name),module_number);
SWIG_TypeClientData(SWIGTYPE_int,&le_swig__int);
le_swig__p_LassoFederation=zend_register_list_destructors_ex(_wrap_destroy_p_LassoFederation,NULL,(char *)(SWIGTYPE_p_LassoFederation->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoFederation,&le_swig__p_LassoFederation);
le_swig__p_LassoDefederation=zend_register_list_destructors_ex(_wrap_destroy_p_LassoDefederation,NULL,(char *)(SWIGTYPE_p_LassoDefederation->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoDefederation,&le_swig__p_LassoDefederation);
le_swig__p_LassoLogin=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLogin,NULL,(char *)(SWIGTYPE_p_LassoLogin->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLogin,&le_swig__p_LassoLogin);
le_swig__p_LassoCheckVersionMode=zend_register_list_destructors_ex(_wrap_destroy_p_LassoCheckVersionMode,NULL,(char *)(SWIGTYPE_p_LassoCheckVersionMode->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoCheckVersionMode,&le_swig__p_LassoCheckVersionMode);
le_swig__p_LassoSamlAuthorityBinding=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlAuthorityBinding,NULL,(char *)(SWIGTYPE_p_LassoSamlAuthorityBinding->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlAuthorityBinding,&le_swig__p_LassoSamlAuthorityBinding);
le_swig__p_LassoRequestType=zend_register_list_destructors_ex(_wrap_destroy_p_LassoRequestType,NULL,(char *)(SWIGTYPE_p_LassoRequestType->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoRequestType,&le_swig__p_LassoRequestType);
le_swig__p_LassoSamlpRequest=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlpRequest,NULL,(char *)(SWIGTYPE_p_LassoSamlpRequest->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlpRequest,&le_swig__p_LassoSamlpRequest);
le_swig__p_LassoLibAuthnRequest=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLibAuthnRequest,NULL,(char *)(SWIGTYPE_p_LassoLibAuthnRequest->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLibAuthnRequest,&le_swig__p_LassoLibAuthnRequest);
le_swig__p_LassoLibLogoutRequest=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLibLogoutRequest,NULL,(char *)(SWIGTYPE_p_LassoLibLogoutRequest->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLibLogoutRequest,&le_swig__p_LassoLibLogoutRequest);
le_swig__p_LassoLibRegisterNameIdentifierRequest=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLibRegisterNameIdentifierRequest,NULL,(char *)(SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLibRegisterNameIdentifierRequest,&le_swig__p_LassoLibRegisterNameIdentifierRequest);
le_swig__p_LassoSignatureType=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSignatureType,NULL,(char *)(SWIGTYPE_p_LassoSignatureType->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSignatureType,&le_swig__p_LassoSignatureType);
le_swig__p_LassoSamlAdvice=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlAdvice,NULL,(char *)(SWIGTYPE_p_LassoSamlAdvice->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlAdvice,&le_swig__p_LassoSamlAdvice);
le_swig__p_LassoSamlAssertion=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlAssertion,NULL,(char *)(SWIGTYPE_p_LassoSamlAssertion->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlAssertion,&le_swig__p_LassoSamlAssertion);
le_swig__p_LassoLibAssertion=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLibAssertion,NULL,(char *)(SWIGTYPE_p_LassoLibAssertion->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLibAssertion,&le_swig__p_LassoLibAssertion);
le_swig__p_LassoLecp=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLecp,NULL,(char *)(SWIGTYPE_p_LassoLecp->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLecp,&le_swig__p_LassoLecp);
le_swig__p_LassoSignatureMethod=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSignatureMethod,NULL,(char *)(SWIGTYPE_p_LassoSignatureMethod->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSignatureMethod,&le_swig__p_LassoSignatureMethod);
le_swig__p_LassoLibRequestAuthnContext=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLibRequestAuthnContext,NULL,(char *)(SWIGTYPE_p_LassoLibRequestAuthnContext->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLibRequestAuthnContext,&le_swig__p_LassoLibRequestAuthnContext);
le_swig__p_LassoLoginProtocolProfile=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLoginProtocolProfile,NULL,(char *)(SWIGTYPE_p_LassoLoginProtocolProfile->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLoginProtocolProfile,&le_swig__p_LassoLoginProtocolProfile);
le_swig__p_LassoSamlNameIdentifier=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlNameIdentifier,NULL,(char *)(SWIGTYPE_p_LassoSamlNameIdentifier->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlNameIdentifier,&le_swig__p_LassoSamlNameIdentifier);
le_swig__p_LassoNameRegistration=zend_register_list_destructors_ex(_wrap_destroy_p_LassoNameRegistration,NULL,(char *)(SWIGTYPE_p_LassoNameRegistration->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoNameRegistration,&le_swig__p_LassoNameRegistration);
le_swig__p_LassoSamlSubject=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlSubject,NULL,(char *)(SWIGTYPE_p_LassoSamlSubject->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlSubject,&le_swig__p_LassoSamlSubject);
le_swig__p_LassoSamlAttributeDesignator=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlAttributeDesignator,NULL,(char *)(SWIGTYPE_p_LassoSamlAttributeDesignator->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlAttributeDesignator,&le_swig__p_LassoSamlAttributeDesignator);
le_swig__p_LassoSamlpResponse=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlpResponse,NULL,(char *)(SWIGTYPE_p_LassoSamlpResponse->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlpResponse,&le_swig__p_LassoSamlpResponse);
le_swig__p_LassoLibAuthnResponse=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLibAuthnResponse,NULL,(char *)(SWIGTYPE_p_LassoLibAuthnResponse->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLibAuthnResponse,&le_swig__p_LassoLibAuthnResponse);
le_swig__p_LassoLibLogoutResponse=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLibLogoutResponse,NULL,(char *)(SWIGTYPE_p_LassoLibLogoutResponse->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLibLogoutResponse,&le_swig__p_LassoLibLogoutResponse);
le_swig__p_LassoLibRegisterNameIdentifierResponse=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLibRegisterNameIdentifierResponse,NULL,(char *)(SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLibRegisterNameIdentifierResponse,&le_swig__p_LassoLibRegisterNameIdentifierResponse);
le_swig__p_LassoLibStatusResponse=zend_register_list_destructors_ex(_wrap_destroy_p_LassoLibStatusResponse,NULL,(char *)(SWIGTYPE_p_LassoLibStatusResponse->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoLibStatusResponse,&le_swig__p_LassoLibStatusResponse);
le_swig__p_LassoServer=zend_register_list_destructors_ex(_wrap_destroy_p_LassoServer,NULL,(char *)(SWIGTYPE_p_LassoServer->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoServer,&le_swig__p_LassoServer);
le_swig__p_LassoSession=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSession,NULL,(char *)(SWIGTYPE_p_LassoSession->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSession,&le_swig__p_LassoSession);
le_swig__p_LassoSamlAttribute=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlAttribute,NULL,(char *)(SWIGTYPE_p_LassoSamlAttribute->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlAttribute,&le_swig__p_LassoSamlAttribute);
le_swig__p_LassoSamlpStatus=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlpStatus,NULL,(char *)(SWIGTYPE_p_LassoSamlpStatus->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlpStatus,&le_swig__p_LassoSamlpStatus);
le_swig__p_LassoIdentity=zend_register_list_destructors_ex(_wrap_destroy_p_LassoIdentity,NULL,(char *)(SWIGTYPE_p_LassoIdentity->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoIdentity,&le_swig__p_LassoIdentity);
le_swig__p_LassoProviderRole=zend_register_list_destructors_ex(_wrap_destroy_p_LassoProviderRole,NULL,(char *)(SWIGTYPE_p_LassoProviderRole->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoProviderRole,&le_swig__p_LassoProviderRole);
le_swig__p_LassoSamlSubjectLocality=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlSubjectLocality,NULL,(char *)(SWIGTYPE_p_LassoSamlSubjectLocality->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlSubjectLocality,&le_swig__p_LassoSamlSubjectLocality);
le_swig__p_LassoSamlSubjectConfirmation=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlSubjectConfirmation,NULL,(char *)(SWIGTYPE_p_LassoSamlSubjectConfirmation->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlSubjectConfirmation,&le_swig__p_LassoSamlSubjectConfirmation);
le_swig__p_LassoSamlAttributeValue=zend_register_list_destructors_ex(_wrap_destroy_p_LassoSamlAttributeValue,NULL,(char *)(SWIGTYPE_p_LassoSamlAttributeValue->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoSamlAttributeValue,&le_swig__p_LassoSamlAttributeValue);
le_swig__p_LassoProvider=zend_register_list_destructors_ex(_wrap_destroy_p_LassoProvider,NULL,(char *)(SWIGTYPE_p_LassoProvider->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoProvider,&le_swig__p_LassoProvider);
le_swig__p_LassoNameIdentifierMapping=zend_register_list_destructors_ex(_wrap_destroy_p_LassoNameIdentifierMapping,NULL,(char *)(SWIGTYPE_p_LassoNameIdentifierMapping->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoNameIdentifierMapping,&le_swig__p_LassoNameIdentifierMapping);
le_swig__p_LassoNode=zend_register_list_destructors_ex(_wrap_destroy_p_LassoNode,NULL,(char *)(SWIGTYPE_p_LassoNode->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LassoNode,&le_swig__p_LassoNode);
CG(active_class_entry) = NULL;
/* end oinit subsection */

    return SUCCESS;
}
PHP_RINIT_FUNCTION(lasso)
{
/* cinit subsection */
REGISTER_LONG_CONSTANT( "LASSO_WSF_SUPPORT", 0, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_HTTP_METHOD_NONE", LASSO_HTTP_METHOD_NONE, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_HTTP_METHOD_ANY", LASSO_HTTP_METHOD_ANY, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_HTTP_METHOD_IDP_INITIATED", LASSO_HTTP_METHOD_IDP_INITIATED, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_HTTP_METHOD_GET", LASSO_HTTP_METHOD_GET, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_HTTP_METHOD_POST", LASSO_HTTP_METHOD_POST, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_HTTP_METHOD_REDIRECT", LASSO_HTTP_METHOD_REDIRECT, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_HTTP_METHOD_SOAP", LASSO_HTTP_METHOD_SOAP, CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_CONSENT_OBTAINED", "urn:liberty:consent:obtained", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_CONSENT_OBTAINED_PRIOR", "urn:liberty:consent:obtained:prior", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_CONSENT_OBTAINED_CURRENT_IMPLICIT", "urn:liberty:consent:obtained:current:implicit", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_CONSENT_OBTAINED_CURRENT_EXPLICIT", "urn:liberty:consent:obtained:current:explicit", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_CONSENT_UNAVAILABLE", "urn:liberty:consent:unavailable", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_CONSENT_INAPPLICABLE", "urn:liberty:consent:inapplicable", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_NAMEID_POLICY_TYPE_NONE", "none", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_NAMEID_POLICY_TYPE_ONE_TIME", "onetime", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_NAMEID_POLICY_TYPE_FEDERATED", "federated", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_NAMEID_POLICY_TYPE_ANY", "any", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_BRWS_ART", "http://projectliberty.org/profiles/brws-art", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_BRWS_POST", "http://projectliberty.org/profiles/brws-post", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_BRWS_LECP", "http://projectliberty.org/profiles/lecp", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_FED_TERM_IDP_HTTP", "http://projectliberty.org/profiles/fedterm-idp-http", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_FED_TERM_IDP_SOAP", "http://projectliberty.org/profiles/fedterm-idp-soap", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_FED_TERM_SP_HTTP", "http://projectliberty.org/profiles/fedterm-sp-http", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_FED_TERM_SP_SOAP", "http://projectliberty.org/profiles/fedterm-sp-soap", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_RNI_IDP_HTTP", "http://projectliberty.org/profiles/rni-idp-http", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_RNI_IDP_SOAP", "http://projectliberty.org/profiles/rni-idp-soap", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_RNI_SP_HTTP", "http://projectliberty.org/profiles/rni-sp-http", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_RNI_SP_SOAP", "http://projectliberty.org/profiles/rni-sp-soap", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_SLO_IDP_HTTP", "http://projectliberty.org/profiles/slo-idp-http", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_SLO_IDP_SOAP", "http://projectliberty.org/profiles/slo-idp-soap", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_SLO_SP_HTTP", "http://projectliberty.org/profiles/slo-sp-http", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_PROTOCOL_PROFILE_SLO_SP_SOAP", "http://projectliberty.org/profiles/slo-sp-soap", CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_LOGIN_PROTOCOL_PROFILE_BRWS_ART", LASSO_LOGIN_PROTOCOL_PROFILE_BRWS_ART, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_LOGIN_PROTOCOL_PROFILE_BRWS_POST", LASSO_LOGIN_PROTOCOL_PROFILE_BRWS_POST, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_LOGIN_PROTOCOL_PROFILE_BRWS_LECP", LASSO_LOGIN_PROTOCOL_PROFILE_BRWS_LECP, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROVIDER_ROLE_NONE", LASSO_PROVIDER_ROLE_NONE, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROVIDER_ROLE_SP", LASSO_PROVIDER_ROLE_SP, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROVIDER_ROLE_IDP", LASSO_PROVIDER_ROLE_IDP, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_REQUEST_TYPE_INVALID", LASSO_REQUEST_TYPE_INVALID, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_REQUEST_TYPE_LOGIN", LASSO_REQUEST_TYPE_LOGIN, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_REQUEST_TYPE_LOGOUT", LASSO_REQUEST_TYPE_LOGOUT, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_REQUEST_TYPE_DEFEDERATION", LASSO_REQUEST_TYPE_DEFEDERATION, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_REQUEST_TYPE_NAME_REGISTRATION", LASSO_REQUEST_TYPE_NAME_REGISTRATION, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_REQUEST_TYPE_NAME_IDENTIFIER_MAPPING", LASSO_REQUEST_TYPE_NAME_IDENTIFIER_MAPPING, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_REQUEST_TYPE_LECP", LASSO_REQUEST_TYPE_LECP, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_REQUEST_TYPE_DISCO_QUERY", LASSO_REQUEST_TYPE_DISCO_QUERY, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_REQUEST_TYPE_DISCO_MODIFY", LASSO_REQUEST_TYPE_DISCO_MODIFY, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_REQUEST_TYPE_DST_QUERY", LASSO_REQUEST_TYPE_DST_QUERY, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_REQUEST_TYPE_DST_MODIFY", LASSO_REQUEST_TYPE_DST_MODIFY, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_REQUEST_TYPE_SASL_REQUEST", LASSO_REQUEST_TYPE_SASL_REQUEST, CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_INTERNET_PROTOCOL", "http://www.projectliberty.org/schemas/authctx/classes/InternetProtocol", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_INTERNET_PROTOCOL_PASSWORD", "http://www.projectliberty.org/schemas/authctx/classes/InternetProtocolPassword", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_MOBILE_ONE_FACTOR_UNREGISTERED", "http://www.projectliberty.org/schemas/authctx/classes/MobileOneFactorUnregistered", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_MOBILE_TWO_FACTOR_UNREGISTERED", "http://www.projectliberty.org/schemas/authctx/classes/MobileTwoFactorUnregistered", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_MOBILE_ONE_FACTOR_CONTRACT", "http://www.projectliberty.org/schemas/authctx/classes/MobileOneFactorContract", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_MOBILE_TWO_FACTOR_CONTRACT", "http://www.projectliberty.org/schemas/authctx/classes/MobileTwoFactorContract", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_PASSWORD", "http://www.projectliberty.org/schemas/authctx/classes/Password", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_PASSWORD_PROTECTED_TRANSPORT", "http://www.projectliberty.org/schemas/authctx/classes/PasswordProtectedTransport", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_PREVIOUS_SESSION", "http://www.projectliberty.org/schemas/authctx/classes/PreviousSession", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_SMARTCARD", "http://www.projectliberty.org/schemas/authctx/classes/Smartcard", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_SMARTCARD_PKI", "http://www.projectliberty.org/schemas/authctx/classes/SmartcardPKI", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_SOFTWARE_PKI", "http://www.projectliberty.org/schemas/authctx/classes/SoftwarePKI", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_CLASS_REF_TIME_SYNC_TOKEN", "http://www.projectliberty.org/schemas/authctx/classes/TimeSyncToken", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_COMPARISON_EXACT", "exact", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_COMPARISON_MINIMUM", "minimum", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_COMPARISON_MAXIMUM", "maximum", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_LIB_AUTHN_CONTEXT_COMPARISON_BETTER", "better", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_SAML_AUTHENTICATION_METHOD_PASSWORD", "urn:oasis:names:tc:SAML:1.0:am:password", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_SAML_AUTHENTICATION_METHOD_KERBEROS", "urn:ietf:rfc:1510", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_SAML_AUTHENTICATION_METHOD_SECURE_REMOTE_PASSWORD", "urn:ietf:rfc:2945", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_SAML_AUTHENTICATION_METHOD_HARDWARE_TOKEN", "urn:oasis:names:tc:SAML:1.0:am:HardwareToken", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_SAML_AUTHENTICATION_METHOD_SMARTCARD_PKI", "urn:ietf:rfc:2246", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_SAML_AUTHENTICATION_METHOD_SOFTWARE_PKI", "urn:oasis:names:tc:SAML:1.0:am:X509-PKI", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_SAML_AUTHENTICATION_METHOD_PGP", "urn:oasis:names:tc:SAML:1.0:am:PGP", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_SAML_AUTHENTICATION_METHODS_PKI", "urn:oasis:names:tc:SAML:1.0:am:SPKI", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_SAML_AUTHENTICATION_METHOD_XKMS", "urn:oasis:names:tc:SAML:1.0:am:XKMS", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_SAML_AUTHENTICATION_METHOD_XMLD_SIG", "urn:ietf:rfc:3075", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_SAML_AUTHENTICATION_METHOD_UNSPECIFIED", "urn:oasis:names:tc:SAML:1.0:am:unspecified", CONST_CS | CONST_PERSISTENT);
REGISTER_STRING_CONSTANT("LASSO_SAML_AUTHENTICATION_METHOD_LIBERTY", "urn:liberty:ac:2003-08", CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_SIGNATURE_METHOD_RSA_SHA1", LASSO_SIGNATURE_METHOD_RSA_SHA1, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_SIGNATURE_METHOD_DSA_SHA1", LASSO_SIGNATURE_METHOD_DSA_SHA1, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_ERROR_UNDEFINED", -1, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_ERROR_UNIMPLEMENTED", -2, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_XML_ERROR_NODE_NOT_FOUND", -10, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_XML_ERROR_NODE_CONTENT_NOT_FOUND", -11, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_XML_ERROR_ATTR_NOT_FOUND", -12, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_XML_ERROR_ATTR_VALUE_NOT_FOUND", -13, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_SIGNATURE_NOT_FOUND", 101, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_INVALID_SIGNATURE", 102, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_SIGNATURE_TMPL_CREATION_FAILED", -103, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_CONTEXT_CREATION_FAILED", -104, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_PUBLIC_KEY_LOAD_FAILED", -105, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_PRIVATE_KEY_LOAD_FAILED", -106, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_CERTIFICATE_LOAD_FAILED", -107, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_SIGNATURE_FAILED", -108, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_KEYS_MNGR_CREATION_FAILED", -109, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_KEYS_MNGR_INIT_FAILED", -110, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_SIGNATURE_VERIFICATION_FAILED", -111, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_CA_CERT_CHAIN_LOAD_FAILED", -112, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_INVALID_SIGALG", -113, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_DIGEST_COMPUTE_FAILED", -114, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DS_ERROR_SIGNATURE_TEMPLATE_NOT_FOUND", -115, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_SERVER_ERROR_PROVIDER_NOT_FOUND", -201, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_SERVER_ERROR_ADD_PROVIDER_FAILED", -202, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_LOGOUT_ERROR_UNSUPPORTED_PROFILE", -301, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_INVALID_QUERY", -401, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_INVALID_POST_MSG", -402, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_INVALID_SOAP_MSG", -403, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_MISSING_REQUEST", -404, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_INVALID_HTTP_METHOD", -405, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_INVALID_PROTOCOLPROFILE", -406, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_INVALID_MSG", -407, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_MISSING_REMOTE_PROVIDERID", -408, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_UNSUPPORTED_PROFILE", -409, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_UNKNOWN_PROFILE_URL", -410, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_IDENTITY_NOT_FOUND", -411, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_FEDERATION_NOT_FOUND", -412, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_NAME_IDENTIFIER_NOT_FOUND", -413, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_BUILDING_QUERY_FAILED", -414, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_BUILDING_REQUEST_FAILED", -415, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_BUILDING_MESSAGE_FAILED", -416, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_BUILDING_RESPONSE_FAILED", -417, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_SESSION_NOT_FOUND", -418, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_BAD_IDENTITY_DUMP", -419, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PROFILE_ERROR_BAD_SESSION_DUMP", -420, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PARAM_ERROR_BAD_TYPE_OR_NULL_OBJ", -501, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PARAM_ERROR_INVALID_VALUE", -502, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_PARAM_ERROR_CHECK_FAILED", -503, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_LOGIN_ERROR_FEDERATION_NOT_FOUND", 601, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_LOGIN_ERROR_CONSENT_NOT_OBTAINED", 602, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_LOGIN_ERROR_INVALID_NAMEIDPOLICY", -603, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_LOGIN_ERROR_REQUEST_DENIED", 604, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_LOGIN_ERROR_INVALID_SIGNATURE", 605, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_LOGIN_ERROR_UNSIGNED_AUTHN_REQUEST", 606, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_LOGIN_ERROR_STATUS_NOT_SUCCESS", 607, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_LOGIN_ERROR_UNKNOWN_PRINCIPAL", 608, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_DEFEDERATION_ERROR_MISSING_NAME_IDENTIFIER", -700, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_CHECK_VERSION_EXACT", LASSO_CHECK_VERSION_EXACT, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_CHECK_VERSIONABI_COMPATIBLE", LASSO_CHECK_VERSIONABI_COMPATIBLE, CONST_CS | CONST_PERSISTENT);
REGISTER_LONG_CONSTANT( "LASSO_CHECK_VERSION_NUMERIC", LASSO_CHECK_VERSION_NUMERIC, CONST_CS | CONST_PERSISTENT);
/* end cinit subsection */

/* vinit subsection */
/* end vinit subsection */

    return SUCCESS;
}
PHP_RSHUTDOWN_FUNCTION(lasso)
{
    return SUCCESS;
}
PHP_MINFO_FUNCTION(lasso)
{
}
/* end init section */

