# This file was automatically generated by SWIG
package lasso;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package lassoc;
bootstrap lasso;
package lasso;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package lasso;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package lasso;

*init = *lassoc::init;
*shutdown = *lassoc::shutdown;
*checkVersion = *lassoc::checkVersion;
*registerDstService = *lassoc::registerDstService;
*getRequestTypeFromSoapMsg = *lassoc::getRequestTypeFromSoapMsg;
*isLibertyQuery = *lassoc::isLibertyQuery;

############# Class : lasso::Node ##############

package lasso::Node;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = lassoc::new_Node(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_Node($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::Node_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::NodeList ##############

package lasso::NodeList;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = lassoc::new_NodeList(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_NodeList($self);
        delete $OWNER{$self};
    }
}

*append = *lassoc::NodeList_append;
*cast = *lassoc::NodeList_cast;
*frompointer = *lassoc::NodeList_frompointer;
*getItem = *lassoc::NodeList_getItem;
*length = *lassoc::NodeList_length;
*setItem = *lassoc::NodeList_setItem;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::StringList ##############

package lasso::StringList;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = lassoc::new_StringList(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_StringList($self);
        delete $OWNER{$self};
    }
}

*append = *lassoc::StringList_append;
*cast = *lassoc::StringList_cast;
*frompointer = *lassoc::StringList_frompointer;
*getItem = *lassoc::StringList_getItem;
*length = *lassoc::StringList_length;
*setItem = *lassoc::StringList_setItem;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlAdvice ##############

package lasso::SamlAdvice;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_assertion_get = *lassoc::SamlAdvice_assertion_get;
*swig_assertion_set = *lassoc::SamlAdvice_assertion_set;
*swig_assertionIdReference_get = *lassoc::SamlAdvice_assertionIdReference_get;
*swig_assertionIdReference_set = *lassoc::SamlAdvice_assertionIdReference_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlAdvice(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlAdvice($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlAdvice_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlAssertion ##############

package lasso::SamlAssertion;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_assertionId_get = *lassoc::SamlAssertion_assertionId_get;
*swig_assertionId_set = *lassoc::SamlAssertion_assertionId_set;
*swig_certificateFile_get = *lassoc::SamlAssertion_certificateFile_get;
*swig_certificateFile_set = *lassoc::SamlAssertion_certificateFile_set;
*swig_issueInstant_get = *lassoc::SamlAssertion_issueInstant_get;
*swig_issueInstant_set = *lassoc::SamlAssertion_issueInstant_set;
*swig_issuer_get = *lassoc::SamlAssertion_issuer_get;
*swig_issuer_set = *lassoc::SamlAssertion_issuer_set;
*swig_majorVersion_get = *lassoc::SamlAssertion_majorVersion_get;
*swig_majorVersion_set = *lassoc::SamlAssertion_majorVersion_set;
*swig_minorVersion_get = *lassoc::SamlAssertion_minorVersion_get;
*swig_minorVersion_set = *lassoc::SamlAssertion_minorVersion_set;
*swig_privateKeyFile_get = *lassoc::SamlAssertion_privateKeyFile_get;
*swig_privateKeyFile_set = *lassoc::SamlAssertion_privateKeyFile_set;
*swig_signMethod_get = *lassoc::SamlAssertion_signMethod_get;
*swig_signMethod_set = *lassoc::SamlAssertion_signMethod_set;
*swig_signType_get = *lassoc::SamlAssertion_signType_get;
*swig_signType_set = *lassoc::SamlAssertion_signType_set;
*swig_advice_get = *lassoc::SamlAssertion_advice_get;
*swig_advice_set = *lassoc::SamlAssertion_advice_set;
*swig_attributeStatement_get = *lassoc::SamlAssertion_attributeStatement_get;
*swig_attributeStatement_set = *lassoc::SamlAssertion_attributeStatement_set;
*swig_authenticationStatement_get = *lassoc::SamlAssertion_authenticationStatement_get;
*swig_authenticationStatement_set = *lassoc::SamlAssertion_authenticationStatement_set;
*swig_conditions_get = *lassoc::SamlAssertion_conditions_get;
*swig_conditions_set = *lassoc::SamlAssertion_conditions_set;
*swig_subjectStatement_get = *lassoc::SamlAssertion_subjectStatement_get;
*swig_subjectStatement_set = *lassoc::SamlAssertion_subjectStatement_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlAssertion(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlAssertion($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlAssertion_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlAttribute ##############

package lasso::SamlAttribute;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_attributeName_get = *lassoc::SamlAttribute_attributeName_get;
*swig_attributeName_set = *lassoc::SamlAttribute_attributeName_set;
*swig_attributeNamespace_get = *lassoc::SamlAttribute_attributeNamespace_get;
*swig_attributeNamespace_set = *lassoc::SamlAttribute_attributeNamespace_set;
*swig_attributeValue_get = *lassoc::SamlAttribute_attributeValue_get;
*swig_attributeValue_set = *lassoc::SamlAttribute_attributeValue_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlAttribute(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlAttribute($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlAttribute_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlAttributeDesignator ##############

package lasso::SamlAttributeDesignator;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_attributeName_get = *lassoc::SamlAttributeDesignator_attributeName_get;
*swig_attributeName_set = *lassoc::SamlAttributeDesignator_attributeName_set;
*swig_attributeNamespace_get = *lassoc::SamlAttributeDesignator_attributeNamespace_get;
*swig_attributeNamespace_set = *lassoc::SamlAttributeDesignator_attributeNamespace_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlAttributeDesignator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlAttributeDesignator($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlAttributeDesignator_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlAttributeStatement ##############

package lasso::SamlAttributeStatement;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_subject_get = *lassoc::SamlAttributeStatement_subject_get;
*swig_subject_set = *lassoc::SamlAttributeStatement_subject_set;
*swig_attribute_get = *lassoc::SamlAttributeStatement_attribute_get;
*swig_attribute_set = *lassoc::SamlAttributeStatement_attribute_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlAttributeStatement(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlAttributeStatement($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlAttributeStatement_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlAttributeValue ##############

package lasso::SamlAttributeValue;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_any_get = *lassoc::SamlAttributeValue_any_get;
*swig_any_set = *lassoc::SamlAttributeValue_any_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlAttributeValue(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlAttributeValue($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlAttributeValue_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlAudienceRestrictionCondition ##############

package lasso::SamlAudienceRestrictionCondition;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_audience_get = *lassoc::SamlAudienceRestrictionCondition_audience_get;
*swig_audience_set = *lassoc::SamlAudienceRestrictionCondition_audience_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlAudienceRestrictionCondition(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlAudienceRestrictionCondition($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlAudienceRestrictionCondition_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlAuthenticationStatement ##############

package lasso::SamlAuthenticationStatement;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_authenticationInstant_get = *lassoc::SamlAuthenticationStatement_authenticationInstant_get;
*swig_authenticationInstant_set = *lassoc::SamlAuthenticationStatement_authenticationInstant_set;
*swig_authenticationMethod_get = *lassoc::SamlAuthenticationStatement_authenticationMethod_get;
*swig_authenticationMethod_set = *lassoc::SamlAuthenticationStatement_authenticationMethod_set;
*swig_authorityBinding_get = *lassoc::SamlAuthenticationStatement_authorityBinding_get;
*swig_authorityBinding_set = *lassoc::SamlAuthenticationStatement_authorityBinding_set;
*swig_subjectLocality_get = *lassoc::SamlAuthenticationStatement_subjectLocality_get;
*swig_subjectLocality_set = *lassoc::SamlAuthenticationStatement_subjectLocality_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlAuthenticationStatement(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlAuthenticationStatement($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlAuthenticationStatement_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlAuthorityBinding ##############

package lasso::SamlAuthorityBinding;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_authorityKind_get = *lassoc::SamlAuthorityBinding_authorityKind_get;
*swig_authorityKind_set = *lassoc::SamlAuthorityBinding_authorityKind_set;
*swig_location_get = *lassoc::SamlAuthorityBinding_location_get;
*swig_location_set = *lassoc::SamlAuthorityBinding_location_set;
*swig_binding_get = *lassoc::SamlAuthorityBinding_binding_get;
*swig_binding_set = *lassoc::SamlAuthorityBinding_binding_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlAuthorityBinding(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlAuthorityBinding($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlAuthorityBinding_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlConditionAbstract ##############

package lasso::SamlConditionAbstract;
@ISA = qw( lasso );
%OWNER = ();
*dump = *lassoc::SamlConditionAbstract_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlConditions ##############

package lasso::SamlConditions;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_notBefore_get = *lassoc::SamlConditions_notBefore_get;
*swig_notBefore_set = *lassoc::SamlConditions_notBefore_set;
*swig_notOnOrAfter_get = *lassoc::SamlConditions_notOnOrAfter_get;
*swig_notOnOrAfter_set = *lassoc::SamlConditions_notOnOrAfter_set;
*swig_audienceRestrictionCondition_get = *lassoc::SamlConditions_audienceRestrictionCondition_get;
*swig_audienceRestrictionCondition_set = *lassoc::SamlConditions_audienceRestrictionCondition_set;
*swig_condition_get = *lassoc::SamlConditions_condition_get;
*swig_condition_set = *lassoc::SamlConditions_condition_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlConditions(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlConditions($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlConditions_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlNameIdentifier ##############

package lasso::SamlNameIdentifier;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_content_get = *lassoc::SamlNameIdentifier_content_get;
*swig_content_set = *lassoc::SamlNameIdentifier_content_set;
*swig_format_get = *lassoc::SamlNameIdentifier_format_get;
*swig_format_set = *lassoc::SamlNameIdentifier_format_set;
*swig_nameQualifier_get = *lassoc::SamlNameIdentifier_nameQualifier_get;
*swig_nameQualifier_set = *lassoc::SamlNameIdentifier_nameQualifier_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlNameIdentifier(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlNameIdentifier($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlNameIdentifier_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlStatementAbstract ##############

package lasso::SamlStatementAbstract;
@ISA = qw( lasso );
%OWNER = ();
*dump = *lassoc::SamlStatementAbstract_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlSubject ##############

package lasso::SamlSubject;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_nameIdentifier_get = *lassoc::SamlSubject_nameIdentifier_get;
*swig_nameIdentifier_set = *lassoc::SamlSubject_nameIdentifier_set;
*swig_subjectConfirmation_get = *lassoc::SamlSubject_subjectConfirmation_get;
*swig_subjectConfirmation_set = *lassoc::SamlSubject_subjectConfirmation_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlSubject(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlSubject($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlSubject_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlSubjectConfirmation ##############

package lasso::SamlSubjectConfirmation;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_subjectConfirmationData_get = *lassoc::SamlSubjectConfirmation_subjectConfirmationData_get;
*swig_subjectConfirmationData_set = *lassoc::SamlSubjectConfirmation_subjectConfirmationData_set;
*swig_confirmationMethod_get = *lassoc::SamlSubjectConfirmation_confirmationMethod_get;
*swig_confirmationMethod_set = *lassoc::SamlSubjectConfirmation_confirmationMethod_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlSubjectConfirmation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlSubjectConfirmation($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlSubjectConfirmation_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlSubjectLocality ##############

package lasso::SamlSubjectLocality;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_dnsAddress_get = *lassoc::SamlSubjectLocality_dnsAddress_get;
*swig_dnsAddress_set = *lassoc::SamlSubjectLocality_dnsAddress_set;
*swig_ipAddress_get = *lassoc::SamlSubjectLocality_ipAddress_get;
*swig_ipAddress_set = *lassoc::SamlSubjectLocality_ipAddress_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlSubjectLocality(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlSubjectLocality($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlSubjectLocality_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlSubjectStatement ##############

package lasso::SamlSubjectStatement;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_subject_get = *lassoc::SamlSubjectStatement_subject_get;
*swig_subject_set = *lassoc::SamlSubjectStatement_subject_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlSubjectStatement(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlSubjectStatement($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlSubjectStatement_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlSubjectStatementAbstract ##############

package lasso::SamlSubjectStatementAbstract;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_subject_get = *lassoc::SamlSubjectStatementAbstract_subject_get;
*swig_subject_set = *lassoc::SamlSubjectStatementAbstract_subject_set;
*dump = *lassoc::SamlSubjectStatementAbstract_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlpRequest ##############

package lasso::SamlpRequest;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_assertionArtifact_get = *lassoc::SamlpRequest_assertionArtifact_get;
*swig_assertionArtifact_set = *lassoc::SamlpRequest_assertionArtifact_set;
*swig_certificateFile_get = *lassoc::SamlpRequest_certificateFile_get;
*swig_certificateFile_set = *lassoc::SamlpRequest_certificateFile_set;
*swig_issueInstant_get = *lassoc::SamlpRequest_issueInstant_get;
*swig_issueInstant_set = *lassoc::SamlpRequest_issueInstant_set;
*swig_majorVersion_get = *lassoc::SamlpRequest_majorVersion_get;
*swig_majorVersion_set = *lassoc::SamlpRequest_majorVersion_set;
*swig_minorVersion_get = *lassoc::SamlpRequest_minorVersion_get;
*swig_minorVersion_set = *lassoc::SamlpRequest_minorVersion_set;
*swig_privateKeyFile_get = *lassoc::SamlpRequest_privateKeyFile_get;
*swig_privateKeyFile_set = *lassoc::SamlpRequest_privateKeyFile_set;
*swig_requestId_get = *lassoc::SamlpRequest_requestId_get;
*swig_requestId_set = *lassoc::SamlpRequest_requestId_set;
*swig_respondWith_get = *lassoc::SamlpRequest_respondWith_get;
*swig_respondWith_set = *lassoc::SamlpRequest_respondWith_set;
*swig_signMethod_get = *lassoc::SamlpRequest_signMethod_get;
*swig_signMethod_set = *lassoc::SamlpRequest_signMethod_set;
*swig_signType_get = *lassoc::SamlpRequest_signType_get;
*swig_signType_set = *lassoc::SamlpRequest_signType_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlpRequest(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlpRequest($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlpRequest_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlpRequestAbstract ##############

package lasso::SamlpRequestAbstract;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_certificateFile_get = *lassoc::SamlpRequestAbstract_certificateFile_get;
*swig_certificateFile_set = *lassoc::SamlpRequestAbstract_certificateFile_set;
*swig_issueInstant_get = *lassoc::SamlpRequestAbstract_issueInstant_get;
*swig_issueInstant_set = *lassoc::SamlpRequestAbstract_issueInstant_set;
*swig_majorVersion_get = *lassoc::SamlpRequestAbstract_majorVersion_get;
*swig_majorVersion_set = *lassoc::SamlpRequestAbstract_majorVersion_set;
*swig_minorVersion_get = *lassoc::SamlpRequestAbstract_minorVersion_get;
*swig_minorVersion_set = *lassoc::SamlpRequestAbstract_minorVersion_set;
*swig_privateKeyFile_get = *lassoc::SamlpRequestAbstract_privateKeyFile_get;
*swig_privateKeyFile_set = *lassoc::SamlpRequestAbstract_privateKeyFile_set;
*swig_requestId_get = *lassoc::SamlpRequestAbstract_requestId_get;
*swig_requestId_set = *lassoc::SamlpRequestAbstract_requestId_set;
*swig_signMethod_get = *lassoc::SamlpRequestAbstract_signMethod_get;
*swig_signMethod_set = *lassoc::SamlpRequestAbstract_signMethod_set;
*swig_signType_get = *lassoc::SamlpRequestAbstract_signType_get;
*swig_signType_set = *lassoc::SamlpRequestAbstract_signType_set;
*swig_respondWith_get = *lassoc::SamlpRequestAbstract_respondWith_get;
*swig_respondWith_set = *lassoc::SamlpRequestAbstract_respondWith_set;
*dump = *lassoc::SamlpRequestAbstract_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlpResponse ##############

package lasso::SamlpResponse;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_certificateFile_get = *lassoc::SamlpResponse_certificateFile_get;
*swig_certificateFile_set = *lassoc::SamlpResponse_certificateFile_set;
*swig_inResponseTo_get = *lassoc::SamlpResponse_inResponseTo_get;
*swig_inResponseTo_set = *lassoc::SamlpResponse_inResponseTo_set;
*swig_issueInstant_get = *lassoc::SamlpResponse_issueInstant_get;
*swig_issueInstant_set = *lassoc::SamlpResponse_issueInstant_set;
*swig_majorVersion_get = *lassoc::SamlpResponse_majorVersion_get;
*swig_majorVersion_set = *lassoc::SamlpResponse_majorVersion_set;
*swig_minorVersion_get = *lassoc::SamlpResponse_minorVersion_get;
*swig_minorVersion_set = *lassoc::SamlpResponse_minorVersion_set;
*swig_privateKeyFile_get = *lassoc::SamlpResponse_privateKeyFile_get;
*swig_privateKeyFile_set = *lassoc::SamlpResponse_privateKeyFile_set;
*swig_recipient_get = *lassoc::SamlpResponse_recipient_get;
*swig_recipient_set = *lassoc::SamlpResponse_recipient_set;
*swig_responseId_get = *lassoc::SamlpResponse_responseId_get;
*swig_responseId_set = *lassoc::SamlpResponse_responseId_set;
*swig_signMethod_get = *lassoc::SamlpResponse_signMethod_get;
*swig_signMethod_set = *lassoc::SamlpResponse_signMethod_set;
*swig_signType_get = *lassoc::SamlpResponse_signType_get;
*swig_signType_set = *lassoc::SamlpResponse_signType_set;
*swig_assertion_get = *lassoc::SamlpResponse_assertion_get;
*swig_assertion_set = *lassoc::SamlpResponse_assertion_set;
*swig_status_get = *lassoc::SamlpResponse_status_get;
*swig_status_set = *lassoc::SamlpResponse_status_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlpResponse(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlpResponse($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlpResponse_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlpResponseAbstract ##############

package lasso::SamlpResponseAbstract;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_certificateFile_get = *lassoc::SamlpResponseAbstract_certificateFile_get;
*swig_certificateFile_set = *lassoc::SamlpResponseAbstract_certificateFile_set;
*swig_inResponseTo_get = *lassoc::SamlpResponseAbstract_inResponseTo_get;
*swig_inResponseTo_set = *lassoc::SamlpResponseAbstract_inResponseTo_set;
*swig_issueInstant_get = *lassoc::SamlpResponseAbstract_issueInstant_get;
*swig_issueInstant_set = *lassoc::SamlpResponseAbstract_issueInstant_set;
*swig_majorVersion_get = *lassoc::SamlpResponseAbstract_majorVersion_get;
*swig_majorVersion_set = *lassoc::SamlpResponseAbstract_majorVersion_set;
*swig_minorVersion_get = *lassoc::SamlpResponseAbstract_minorVersion_get;
*swig_minorVersion_set = *lassoc::SamlpResponseAbstract_minorVersion_set;
*swig_privateKeyFile_get = *lassoc::SamlpResponseAbstract_privateKeyFile_get;
*swig_privateKeyFile_set = *lassoc::SamlpResponseAbstract_privateKeyFile_set;
*swig_recipient_get = *lassoc::SamlpResponseAbstract_recipient_get;
*swig_recipient_set = *lassoc::SamlpResponseAbstract_recipient_set;
*swig_responseId_get = *lassoc::SamlpResponseAbstract_responseId_get;
*swig_responseId_set = *lassoc::SamlpResponseAbstract_responseId_set;
*swig_signMethod_get = *lassoc::SamlpResponseAbstract_signMethod_get;
*swig_signMethod_set = *lassoc::SamlpResponseAbstract_signMethod_set;
*swig_signType_get = *lassoc::SamlpResponseAbstract_signType_get;
*swig_signType_set = *lassoc::SamlpResponseAbstract_signType_set;
*dump = *lassoc::SamlpResponseAbstract_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlpStatus ##############

package lasso::SamlpStatus;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_statusMessage_get = *lassoc::SamlpStatus_statusMessage_get;
*swig_statusMessage_set = *lassoc::SamlpStatus_statusMessage_set;
*swig_statusCode_get = *lassoc::SamlpStatus_statusCode_get;
*swig_statusCode_set = *lassoc::SamlpStatus_statusCode_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlpStatus(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlpStatus($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlpStatus_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::SamlpStatusCode ##############

package lasso::SamlpStatusCode;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_value_get = *lassoc::SamlpStatusCode_value_get;
*swig_value_set = *lassoc::SamlpStatusCode_value_set;
*swig_statusCode_get = *lassoc::SamlpStatusCode_statusCode_get;
*swig_statusCode_set = *lassoc::SamlpStatusCode_statusCode_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_SamlpStatusCode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_SamlpStatusCode($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::SamlpStatusCode_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::LibAssertion ##############

package lasso::LibAssertion;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_advice_get = *lassoc::LibAssertion_advice_get;
*swig_advice_set = *lassoc::LibAssertion_advice_set;
*swig_assertionId_get = *lassoc::LibAssertion_assertionId_get;
*swig_assertionId_set = *lassoc::LibAssertion_assertionId_set;
*swig_attributeStatement_get = *lassoc::LibAssertion_attributeStatement_get;
*swig_attributeStatement_set = *lassoc::LibAssertion_attributeStatement_set;
*swig_authenticationStatement_get = *lassoc::LibAssertion_authenticationStatement_get;
*swig_authenticationStatement_set = *lassoc::LibAssertion_authenticationStatement_set;
*swig_certificateFile_get = *lassoc::LibAssertion_certificateFile_get;
*swig_certificateFile_set = *lassoc::LibAssertion_certificateFile_set;
*swig_conditions_get = *lassoc::LibAssertion_conditions_get;
*swig_conditions_set = *lassoc::LibAssertion_conditions_set;
*swig_issueInstant_get = *lassoc::LibAssertion_issueInstant_get;
*swig_issueInstant_set = *lassoc::LibAssertion_issueInstant_set;
*swig_issuer_get = *lassoc::LibAssertion_issuer_get;
*swig_issuer_set = *lassoc::LibAssertion_issuer_set;
*swig_majorVersion_get = *lassoc::LibAssertion_majorVersion_get;
*swig_majorVersion_set = *lassoc::LibAssertion_majorVersion_set;
*swig_minorVersion_get = *lassoc::LibAssertion_minorVersion_get;
*swig_minorVersion_set = *lassoc::LibAssertion_minorVersion_set;
*swig_privateKeyFile_get = *lassoc::LibAssertion_privateKeyFile_get;
*swig_privateKeyFile_set = *lassoc::LibAssertion_privateKeyFile_set;
*swig_signMethod_get = *lassoc::LibAssertion_signMethod_get;
*swig_signMethod_set = *lassoc::LibAssertion_signMethod_set;
*swig_signType_get = *lassoc::LibAssertion_signType_get;
*swig_signType_set = *lassoc::LibAssertion_signType_set;
*swig_subjectStatement_get = *lassoc::LibAssertion_subjectStatement_get;
*swig_subjectStatement_set = *lassoc::LibAssertion_subjectStatement_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_LibAssertion(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_LibAssertion($self);
        delete $OWNER{$self};
    }
}

*newFull = *lassoc::LibAssertion_newFull;
*dump = *lassoc::LibAssertion_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::LibAuthnRequest ##############

package lasso::LibAuthnRequest;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_affiliationId_get = *lassoc::LibAuthnRequest_affiliationId_get;
*swig_affiliationId_set = *lassoc::LibAuthnRequest_affiliationId_set;
*swig_assertionConsumerServiceId_get = *lassoc::LibAuthnRequest_assertionConsumerServiceId_get;
*swig_assertionConsumerServiceId_set = *lassoc::LibAuthnRequest_assertionConsumerServiceId_set;
*swig_consent_get = *lassoc::LibAuthnRequest_consent_get;
*swig_consent_set = *lassoc::LibAuthnRequest_consent_set;
*swig_forceAuthn_get = *lassoc::LibAuthnRequest_forceAuthn_get;
*swig_forceAuthn_set = *lassoc::LibAuthnRequest_forceAuthn_set;
*swig_isPassive_get = *lassoc::LibAuthnRequest_isPassive_get;
*swig_isPassive_set = *lassoc::LibAuthnRequest_isPassive_set;
*swig_nameIdPolicy_get = *lassoc::LibAuthnRequest_nameIdPolicy_get;
*swig_nameIdPolicy_set = *lassoc::LibAuthnRequest_nameIdPolicy_set;
*swig_protocolProfile_get = *lassoc::LibAuthnRequest_protocolProfile_get;
*swig_protocolProfile_set = *lassoc::LibAuthnRequest_protocolProfile_set;
*swig_providerId_get = *lassoc::LibAuthnRequest_providerId_get;
*swig_providerId_set = *lassoc::LibAuthnRequest_providerId_set;
*swig_relayState_get = *lassoc::LibAuthnRequest_relayState_get;
*swig_relayState_set = *lassoc::LibAuthnRequest_relayState_set;
*swig_certificateFile_get = *lassoc::LibAuthnRequest_certificateFile_get;
*swig_certificateFile_set = *lassoc::LibAuthnRequest_certificateFile_set;
*swig_issueInstant_get = *lassoc::LibAuthnRequest_issueInstant_get;
*swig_issueInstant_set = *lassoc::LibAuthnRequest_issueInstant_set;
*swig_majorVersion_get = *lassoc::LibAuthnRequest_majorVersion_get;
*swig_majorVersion_set = *lassoc::LibAuthnRequest_majorVersion_set;
*swig_minorVersion_get = *lassoc::LibAuthnRequest_minorVersion_get;
*swig_minorVersion_set = *lassoc::LibAuthnRequest_minorVersion_set;
*swig_privateKeyFile_get = *lassoc::LibAuthnRequest_privateKeyFile_get;
*swig_privateKeyFile_set = *lassoc::LibAuthnRequest_privateKeyFile_set;
*swig_requestId_get = *lassoc::LibAuthnRequest_requestId_get;
*swig_requestId_set = *lassoc::LibAuthnRequest_requestId_set;
*swig_respondWith_get = *lassoc::LibAuthnRequest_respondWith_get;
*swig_respondWith_set = *lassoc::LibAuthnRequest_respondWith_set;
*swig_signMethod_get = *lassoc::LibAuthnRequest_signMethod_get;
*swig_signMethod_set = *lassoc::LibAuthnRequest_signMethod_set;
*swig_signType_get = *lassoc::LibAuthnRequest_signType_get;
*swig_signType_set = *lassoc::LibAuthnRequest_signType_set;
*swig_extension_get = *lassoc::LibAuthnRequest_extension_get;
*swig_extension_set = *lassoc::LibAuthnRequest_extension_set;
*swig_requestAuthnContext_get = *lassoc::LibAuthnRequest_requestAuthnContext_get;
*swig_requestAuthnContext_set = *lassoc::LibAuthnRequest_requestAuthnContext_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_LibAuthnRequest(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_LibAuthnRequest($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::LibAuthnRequest_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::LibAuthnResponse ##############

package lasso::LibAuthnResponse;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_consent_get = *lassoc::LibAuthnResponse_consent_get;
*swig_consent_set = *lassoc::LibAuthnResponse_consent_set;
*swig_providerId_get = *lassoc::LibAuthnResponse_providerId_get;
*swig_providerId_set = *lassoc::LibAuthnResponse_providerId_set;
*swig_relayState_get = *lassoc::LibAuthnResponse_relayState_get;
*swig_relayState_set = *lassoc::LibAuthnResponse_relayState_set;
*swig_extension_get = *lassoc::LibAuthnResponse_extension_get;
*swig_extension_set = *lassoc::LibAuthnResponse_extension_set;
*swig_status_get = *lassoc::LibAuthnResponse_status_get;
*swig_status_set = *lassoc::LibAuthnResponse_status_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_LibAuthnResponse(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_LibAuthnResponse($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::LibAuthnResponse_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::LibFederationTerminationNotification ##############

package lasso::LibFederationTerminationNotification;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_consent_get = *lassoc::LibFederationTerminationNotification_consent_get;
*swig_consent_set = *lassoc::LibFederationTerminationNotification_consent_set;
*swig_providerId_get = *lassoc::LibFederationTerminationNotification_providerId_get;
*swig_providerId_set = *lassoc::LibFederationTerminationNotification_providerId_set;
*swig_relayState_get = *lassoc::LibFederationTerminationNotification_relayState_get;
*swig_relayState_set = *lassoc::LibFederationTerminationNotification_relayState_set;
*swig_certificateFile_get = *lassoc::LibFederationTerminationNotification_certificateFile_get;
*swig_certificateFile_set = *lassoc::LibFederationTerminationNotification_certificateFile_set;
*swig_issueInstant_get = *lassoc::LibFederationTerminationNotification_issueInstant_get;
*swig_issueInstant_set = *lassoc::LibFederationTerminationNotification_issueInstant_set;
*swig_majorVersion_get = *lassoc::LibFederationTerminationNotification_majorVersion_get;
*swig_majorVersion_set = *lassoc::LibFederationTerminationNotification_majorVersion_set;
*swig_minorVersion_get = *lassoc::LibFederationTerminationNotification_minorVersion_get;
*swig_minorVersion_set = *lassoc::LibFederationTerminationNotification_minorVersion_set;
*swig_privateKeyFile_get = *lassoc::LibFederationTerminationNotification_privateKeyFile_get;
*swig_privateKeyFile_set = *lassoc::LibFederationTerminationNotification_privateKeyFile_set;
*swig_requestId_get = *lassoc::LibFederationTerminationNotification_requestId_get;
*swig_requestId_set = *lassoc::LibFederationTerminationNotification_requestId_set;
*swig_respondWith_get = *lassoc::LibFederationTerminationNotification_respondWith_get;
*swig_respondWith_set = *lassoc::LibFederationTerminationNotification_respondWith_set;
*swig_signMethod_get = *lassoc::LibFederationTerminationNotification_signMethod_get;
*swig_signMethod_set = *lassoc::LibFederationTerminationNotification_signMethod_set;
*swig_signType_get = *lassoc::LibFederationTerminationNotification_signType_get;
*swig_signType_set = *lassoc::LibFederationTerminationNotification_signType_set;
*swig_extension_get = *lassoc::LibFederationTerminationNotification_extension_get;
*swig_extension_set = *lassoc::LibFederationTerminationNotification_extension_set;
*swig_nameIdentifier_get = *lassoc::LibFederationTerminationNotification_nameIdentifier_get;
*swig_nameIdentifier_set = *lassoc::LibFederationTerminationNotification_nameIdentifier_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_LibFederationTerminationNotification(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_LibFederationTerminationNotification($self);
        delete $OWNER{$self};
    }
}

*newFull = *lassoc::LibFederationTerminationNotification_newFull;
*dump = *lassoc::LibFederationTerminationNotification_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::LibLogoutRequest ##############

package lasso::LibLogoutRequest;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_consent_get = *lassoc::LibLogoutRequest_consent_get;
*swig_consent_set = *lassoc::LibLogoutRequest_consent_set;
*swig_notOnOrAfter_get = *lassoc::LibLogoutRequest_notOnOrAfter_get;
*swig_notOnOrAfter_set = *lassoc::LibLogoutRequest_notOnOrAfter_set;
*swig_providerId_get = *lassoc::LibLogoutRequest_providerId_get;
*swig_providerId_set = *lassoc::LibLogoutRequest_providerId_set;
*swig_relayState_get = *lassoc::LibLogoutRequest_relayState_get;
*swig_relayState_set = *lassoc::LibLogoutRequest_relayState_set;
*swig_sessionIndex_get = *lassoc::LibLogoutRequest_sessionIndex_get;
*swig_sessionIndex_set = *lassoc::LibLogoutRequest_sessionIndex_set;
*swig_certificateFile_get = *lassoc::LibLogoutRequest_certificateFile_get;
*swig_certificateFile_set = *lassoc::LibLogoutRequest_certificateFile_set;
*swig_issueInstant_get = *lassoc::LibLogoutRequest_issueInstant_get;
*swig_issueInstant_set = *lassoc::LibLogoutRequest_issueInstant_set;
*swig_majorVersion_get = *lassoc::LibLogoutRequest_majorVersion_get;
*swig_majorVersion_set = *lassoc::LibLogoutRequest_majorVersion_set;
*swig_minorVersion_get = *lassoc::LibLogoutRequest_minorVersion_get;
*swig_minorVersion_set = *lassoc::LibLogoutRequest_minorVersion_set;
*swig_privateKeyFile_get = *lassoc::LibLogoutRequest_privateKeyFile_get;
*swig_privateKeyFile_set = *lassoc::LibLogoutRequest_privateKeyFile_set;
*swig_requestId_get = *lassoc::LibLogoutRequest_requestId_get;
*swig_requestId_set = *lassoc::LibLogoutRequest_requestId_set;
*swig_respondWith_get = *lassoc::LibLogoutRequest_respondWith_get;
*swig_respondWith_set = *lassoc::LibLogoutRequest_respondWith_set;
*swig_signMethod_get = *lassoc::LibLogoutRequest_signMethod_get;
*swig_signMethod_set = *lassoc::LibLogoutRequest_signMethod_set;
*swig_signType_get = *lassoc::LibLogoutRequest_signType_get;
*swig_signType_set = *lassoc::LibLogoutRequest_signType_set;
*swig_extension_get = *lassoc::LibLogoutRequest_extension_get;
*swig_extension_set = *lassoc::LibLogoutRequest_extension_set;
*swig_nameIdentifier_get = *lassoc::LibLogoutRequest_nameIdentifier_get;
*swig_nameIdentifier_set = *lassoc::LibLogoutRequest_nameIdentifier_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_LibLogoutRequest(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_LibLogoutRequest($self);
        delete $OWNER{$self};
    }
}

*newFull = *lassoc::LibLogoutRequest_newFull;
*dump = *lassoc::LibLogoutRequest_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::LibLogoutResponse ##############

package lasso::LibLogoutResponse;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_extension_get = *lassoc::LibLogoutResponse_extension_get;
*swig_extension_set = *lassoc::LibLogoutResponse_extension_set;
*swig_providerId_get = *lassoc::LibLogoutResponse_providerId_get;
*swig_providerId_set = *lassoc::LibLogoutResponse_providerId_set;
*swig_relayState_get = *lassoc::LibLogoutResponse_relayState_get;
*swig_relayState_set = *lassoc::LibLogoutResponse_relayState_set;
*swig_status_get = *lassoc::LibLogoutResponse_status_get;
*swig_status_set = *lassoc::LibLogoutResponse_status_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_LibLogoutResponse(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_LibLogoutResponse($self);
        delete $OWNER{$self};
    }
}

*newFull = *lassoc::LibLogoutResponse_newFull;
*dump = *lassoc::LibLogoutResponse_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::LibRegisterNameIdentifierRequest ##############

package lasso::LibRegisterNameIdentifierRequest;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_providerId_get = *lassoc::LibRegisterNameIdentifierRequest_providerId_get;
*swig_providerId_set = *lassoc::LibRegisterNameIdentifierRequest_providerId_set;
*swig_relayState_get = *lassoc::LibRegisterNameIdentifierRequest_relayState_get;
*swig_relayState_set = *lassoc::LibRegisterNameIdentifierRequest_relayState_set;
*swig_certificateFile_get = *lassoc::LibRegisterNameIdentifierRequest_certificateFile_get;
*swig_certificateFile_set = *lassoc::LibRegisterNameIdentifierRequest_certificateFile_set;
*swig_issueInstant_get = *lassoc::LibRegisterNameIdentifierRequest_issueInstant_get;
*swig_issueInstant_set = *lassoc::LibRegisterNameIdentifierRequest_issueInstant_set;
*swig_majorVersion_get = *lassoc::LibRegisterNameIdentifierRequest_majorVersion_get;
*swig_majorVersion_set = *lassoc::LibRegisterNameIdentifierRequest_majorVersion_set;
*swig_minorVersion_get = *lassoc::LibRegisterNameIdentifierRequest_minorVersion_get;
*swig_minorVersion_set = *lassoc::LibRegisterNameIdentifierRequest_minorVersion_set;
*swig_privateKeyFile_get = *lassoc::LibRegisterNameIdentifierRequest_privateKeyFile_get;
*swig_privateKeyFile_set = *lassoc::LibRegisterNameIdentifierRequest_privateKeyFile_set;
*swig_requestId_get = *lassoc::LibRegisterNameIdentifierRequest_requestId_get;
*swig_requestId_set = *lassoc::LibRegisterNameIdentifierRequest_requestId_set;
*swig_respondWith_get = *lassoc::LibRegisterNameIdentifierRequest_respondWith_get;
*swig_respondWith_set = *lassoc::LibRegisterNameIdentifierRequest_respondWith_set;
*swig_signMethod_get = *lassoc::LibRegisterNameIdentifierRequest_signMethod_get;
*swig_signMethod_set = *lassoc::LibRegisterNameIdentifierRequest_signMethod_set;
*swig_signType_get = *lassoc::LibRegisterNameIdentifierRequest_signType_get;
*swig_signType_set = *lassoc::LibRegisterNameIdentifierRequest_signType_set;
*swig_extension_get = *lassoc::LibRegisterNameIdentifierRequest_extension_get;
*swig_extension_set = *lassoc::LibRegisterNameIdentifierRequest_extension_set;
*swig_idpProvidedNameIdentifier_get = *lassoc::LibRegisterNameIdentifierRequest_idpProvidedNameIdentifier_get;
*swig_idpProvidedNameIdentifier_set = *lassoc::LibRegisterNameIdentifierRequest_idpProvidedNameIdentifier_set;
*swig_oldProvidedNameIdentifier_get = *lassoc::LibRegisterNameIdentifierRequest_oldProvidedNameIdentifier_get;
*swig_oldProvidedNameIdentifier_set = *lassoc::LibRegisterNameIdentifierRequest_oldProvidedNameIdentifier_set;
*swig_spProvidedNameIdentifier_get = *lassoc::LibRegisterNameIdentifierRequest_spProvidedNameIdentifier_get;
*swig_spProvidedNameIdentifier_set = *lassoc::LibRegisterNameIdentifierRequest_spProvidedNameIdentifier_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_LibRegisterNameIdentifierRequest(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_LibRegisterNameIdentifierRequest($self);
        delete $OWNER{$self};
    }
}

*newFull = *lassoc::LibRegisterNameIdentifierRequest_newFull;
*dump = *lassoc::LibRegisterNameIdentifierRequest_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::LibRegisterNameIdentifierResponse ##############

package lasso::LibRegisterNameIdentifierResponse;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_extension_get = *lassoc::LibRegisterNameIdentifierResponse_extension_get;
*swig_extension_set = *lassoc::LibRegisterNameIdentifierResponse_extension_set;
*swig_providerId_get = *lassoc::LibRegisterNameIdentifierResponse_providerId_get;
*swig_providerId_set = *lassoc::LibRegisterNameIdentifierResponse_providerId_set;
*swig_relayState_get = *lassoc::LibRegisterNameIdentifierResponse_relayState_get;
*swig_relayState_set = *lassoc::LibRegisterNameIdentifierResponse_relayState_set;
*swig_status_get = *lassoc::LibRegisterNameIdentifierResponse_status_get;
*swig_status_set = *lassoc::LibRegisterNameIdentifierResponse_status_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_LibRegisterNameIdentifierResponse(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_LibRegisterNameIdentifierResponse($self);
        delete $OWNER{$self};
    }
}

*newFull = *lassoc::LibRegisterNameIdentifierResponse_newFull;
*dump = *lassoc::LibRegisterNameIdentifierResponse_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::LibRequestAuthnContext ##############

package lasso::LibRequestAuthnContext;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_authnContextComparison_get = *lassoc::LibRequestAuthnContext_authnContextComparison_get;
*swig_authnContextComparison_set = *lassoc::LibRequestAuthnContext_authnContextComparison_set;
*swig_authnContextClassRef_get = *lassoc::LibRequestAuthnContext_authnContextClassRef_get;
*swig_authnContextClassRef_set = *lassoc::LibRequestAuthnContext_authnContextClassRef_set;
*swig_authnContextStatementRef_get = *lassoc::LibRequestAuthnContext_authnContextStatementRef_get;
*swig_authnContextStatementRef_set = *lassoc::LibRequestAuthnContext_authnContextStatementRef_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_LibRequestAuthnContext(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_LibRequestAuthnContext($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::LibRequestAuthnContext_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::LibStatusResponse ##############

package lasso::LibStatusResponse;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_providerId_get = *lassoc::LibStatusResponse_providerId_get;
*swig_providerId_set = *lassoc::LibStatusResponse_providerId_set;
*swig_relayState_get = *lassoc::LibStatusResponse_relayState_get;
*swig_relayState_set = *lassoc::LibStatusResponse_relayState_set;
*swig_extension_get = *lassoc::LibStatusResponse_extension_get;
*swig_extension_set = *lassoc::LibStatusResponse_extension_set;
*swig_status_get = *lassoc::LibStatusResponse_status_get;
*swig_status_set = *lassoc::LibStatusResponse_status_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_LibStatusResponse(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_LibStatusResponse($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::LibStatusResponse_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::Provider ##############

package lasso::Provider;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_caCertChain_get = *lassoc::Provider_caCertChain_get;
*swig_caCertChain_set = *lassoc::Provider_caCertChain_set;
*swig_metadataFilename_get = *lassoc::Provider_metadataFilename_get;
*swig_metadataFilename_set = *lassoc::Provider_metadataFilename_set;
*swig_providerId_get = *lassoc::Provider_providerId_get;
*swig_providerId_set = *lassoc::Provider_providerId_set;
*swig_publicKey_get = *lassoc::Provider_publicKey_get;
*swig_publicKey_set = *lassoc::Provider_publicKey_set;
*swig_role_get = *lassoc::Provider_role_get;
*swig_role_set = *lassoc::Provider_role_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_Provider(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_Provider($self);
        delete $OWNER{$self};
    }
}

*newFromDump = *lassoc::Provider_newFromDump;
*dump = *lassoc::Provider_dump;
*acceptHttpMethod = *lassoc::Provider_acceptHttpMethod;
*getAssertionConsumerServiceUrl = *lassoc::Provider_getAssertionConsumerServiceUrl;
*getBase64SuccinctId = *lassoc::Provider_getBase64SuccinctId;
*getOrganization = *lassoc::Provider_getOrganization;
*getFirstHttpMethod = *lassoc::Provider_getFirstHttpMethod;
*getMetadataOne = *lassoc::Provider_getMetadataOne;
*hasProtocolProfile = *lassoc::Provider_hasProtocolProfile;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::Server ##############

package lasso::Server;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_certificate_get = *lassoc::Server_certificate_get;
*swig_certificate_set = *lassoc::Server_certificate_set;
*swig_privateKey_get = *lassoc::Server_privateKey_get;
*swig_privateKey_set = *lassoc::Server_privateKey_set;
*swig_privateKeyPassword_get = *lassoc::Server_privateKeyPassword_get;
*swig_privateKeyPassword_set = *lassoc::Server_privateKeyPassword_set;
*swig_signatureMethod_get = *lassoc::Server_signatureMethod_get;
*swig_signatureMethod_set = *lassoc::Server_signatureMethod_set;
*swig_caCertChain_get = *lassoc::Server_caCertChain_get;
*swig_caCertChain_set = *lassoc::Server_caCertChain_set;
*swig_metadataFilename_get = *lassoc::Server_metadataFilename_get;
*swig_metadataFilename_set = *lassoc::Server_metadataFilename_set;
*swig_providerId_get = *lassoc::Server_providerId_get;
*swig_providerId_set = *lassoc::Server_providerId_set;
*swig_publicKey_get = *lassoc::Server_publicKey_get;
*swig_publicKey_set = *lassoc::Server_publicKey_set;
*swig_role_get = *lassoc::Server_role_get;
*swig_role_set = *lassoc::Server_role_set;
*swig_providerIds_get = *lassoc::Server_providerIds_get;
*swig_providerIds_set = *lassoc::Server_providerIds_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_Server(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_Server($self);
        delete $OWNER{$self};
    }
}

*newFromDump = *lassoc::Server_newFromDump;
*acceptHttpMethod = *lassoc::Server_acceptHttpMethod;
*getAssertionConsumerServiceUrl = *lassoc::Server_getAssertionConsumerServiceUrl;
*getBase64SuccinctId = *lassoc::Server_getBase64SuccinctId;
*getOrganization = *lassoc::Server_getOrganization;
*getFirstHttpMethod = *lassoc::Server_getFirstHttpMethod;
*getMetadataOne = *lassoc::Server_getMetadataOne;
*hasProtocolProfile = *lassoc::Server_hasProtocolProfile;
*addProvider = *lassoc::Server_addProvider;
*dump = *lassoc::Server_dump;
*getProvider = *lassoc::Server_getProvider;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::Federation ##############

package lasso::Federation;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_remoteProviderId_get = *lassoc::Federation_remoteProviderId_get;
*swig_remoteProviderId_set = *lassoc::Federation_remoteProviderId_set;
*swig_localNameIdentifier_get = *lassoc::Federation_localNameIdentifier_get;
*swig_localNameIdentifier_set = *lassoc::Federation_localNameIdentifier_set;
*swig_remoteNameIdentifier_get = *lassoc::Federation_remoteNameIdentifier_get;
*swig_remoteNameIdentifier_set = *lassoc::Federation_remoteNameIdentifier_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_Federation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_Federation($self);
        delete $OWNER{$self};
    }
}

*dump = *lassoc::Federation_dump;
*buildLocalNameIdentifier = *lassoc::Federation_buildLocalNameIdentifier;
*verifyNameIdentifier = *lassoc::Federation_verifyNameIdentifier;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::Identity ##############

package lasso::Identity;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_isDirty_get = *lassoc::Identity_isDirty_get;
*swig_isDirty_set = *lassoc::Identity_isDirty_set;
*swig_providerIds_get = *lassoc::Identity_providerIds_get;
*swig_providerIds_set = *lassoc::Identity_providerIds_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_Identity(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_Identity($self);
        delete $OWNER{$self};
    }
}

*newFromDump = *lassoc::Identity_newFromDump;
*dump = *lassoc::Identity_dump;
*getFederation = *lassoc::Identity_getFederation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::Session ##############

package lasso::Session;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_isDirty_get = *lassoc::Session_isDirty_get;
*swig_isDirty_set = *lassoc::Session_isDirty_set;
*swig_providerIds_get = *lassoc::Session_providerIds_get;
*swig_providerIds_set = *lassoc::Session_providerIds_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_Session(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_Session($self);
        delete $OWNER{$self};
    }
}

*newFromDump = *lassoc::Session_newFromDump;
*dump = *lassoc::Session_dump;
*getAssertions = *lassoc::Session_getAssertions;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::Defederation ##############

package lasso::Defederation;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_identity_get = *lassoc::Defederation_identity_get;
*swig_identity_set = *lassoc::Defederation_identity_set;
*swig_isIdentityDirty_get = *lassoc::Defederation_isIdentityDirty_get;
*swig_isIdentityDirty_set = *lassoc::Defederation_isIdentityDirty_set;
*swig_isSessionDirty_get = *lassoc::Defederation_isSessionDirty_get;
*swig_isSessionDirty_set = *lassoc::Defederation_isSessionDirty_set;
*swig_msgBody_get = *lassoc::Defederation_msgBody_get;
*swig_msgBody_set = *lassoc::Defederation_msgBody_set;
*swig_msgRelayState_get = *lassoc::Defederation_msgRelayState_get;
*swig_msgRelayState_set = *lassoc::Defederation_msgRelayState_set;
*swig_msgUrl_get = *lassoc::Defederation_msgUrl_get;
*swig_msgUrl_set = *lassoc::Defederation_msgUrl_set;
*swig_nameIdentifier_get = *lassoc::Defederation_nameIdentifier_get;
*swig_nameIdentifier_set = *lassoc::Defederation_nameIdentifier_set;
*swig_remoteProviderId_get = *lassoc::Defederation_remoteProviderId_get;
*swig_remoteProviderId_set = *lassoc::Defederation_remoteProviderId_set;
*swig_request_get = *lassoc::Defederation_request_get;
*swig_request_set = *lassoc::Defederation_request_set;
*swig_response_get = *lassoc::Defederation_response_get;
*swig_response_set = *lassoc::Defederation_response_set;
*swig_server_get = *lassoc::Defederation_server_get;
*swig_server_set = *lassoc::Defederation_server_set;
*swig_session_get = *lassoc::Defederation_session_get;
*swig_session_set = *lassoc::Defederation_session_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_Defederation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_Defederation($self);
        delete $OWNER{$self};
    }
}

*setIdentityFromDump = *lassoc::Defederation_setIdentityFromDump;
*setSessionFromDump = *lassoc::Defederation_setSessionFromDump;
*buildNotificationMsg = *lassoc::Defederation_buildNotificationMsg;
*initNotification = *lassoc::Defederation_initNotification;
*processNotificationMsg = *lassoc::Defederation_processNotificationMsg;
*validateNotification = *lassoc::Defederation_validateNotification;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::Login ##############

package lasso::Login;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_assertionArtifact_get = *lassoc::Login_assertionArtifact_get;
*swig_assertionArtifact_set = *lassoc::Login_assertionArtifact_set;
*swig_protocolProfile_get = *lassoc::Login_protocolProfile_get;
*swig_protocolProfile_set = *lassoc::Login_protocolProfile_set;
*swig_identity_get = *lassoc::Login_identity_get;
*swig_identity_set = *lassoc::Login_identity_set;
*swig_isIdentityDirty_get = *lassoc::Login_isIdentityDirty_get;
*swig_isIdentityDirty_set = *lassoc::Login_isIdentityDirty_set;
*swig_isSessionDirty_get = *lassoc::Login_isSessionDirty_get;
*swig_isSessionDirty_set = *lassoc::Login_isSessionDirty_set;
*swig_msgBody_get = *lassoc::Login_msgBody_get;
*swig_msgBody_set = *lassoc::Login_msgBody_set;
*swig_msgRelayState_get = *lassoc::Login_msgRelayState_get;
*swig_msgRelayState_set = *lassoc::Login_msgRelayState_set;
*swig_msgUrl_get = *lassoc::Login_msgUrl_get;
*swig_msgUrl_set = *lassoc::Login_msgUrl_set;
*swig_nameIdentifier_get = *lassoc::Login_nameIdentifier_get;
*swig_nameIdentifier_set = *lassoc::Login_nameIdentifier_set;
*swig_remoteProviderId_get = *lassoc::Login_remoteProviderId_get;
*swig_remoteProviderId_set = *lassoc::Login_remoteProviderId_set;
*swig_request_get = *lassoc::Login_request_get;
*swig_request_set = *lassoc::Login_request_set;
*swig_response_get = *lassoc::Login_response_get;
*swig_response_set = *lassoc::Login_response_set;
*swig_server_get = *lassoc::Login_server_get;
*swig_server_set = *lassoc::Login_server_set;
*swig_session_get = *lassoc::Login_session_get;
*swig_session_set = *lassoc::Login_session_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_Login(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_Login($self);
        delete $OWNER{$self};
    }
}

*newFromDump = *lassoc::Login_newFromDump;
*setIdentityFromDump = *lassoc::Login_setIdentityFromDump;
*setSessionFromDump = *lassoc::Login_setSessionFromDump;
*acceptSso = *lassoc::Login_acceptSso;
*buildArtifactMsg = *lassoc::Login_buildArtifactMsg;
*buildAssertion = *lassoc::Login_buildAssertion;
*buildAuthnRequestMsg = *lassoc::Login_buildAuthnRequestMsg;
*buildAuthnResponseMsg = *lassoc::Login_buildAuthnResponseMsg;
*buildRequestMsg = *lassoc::Login_buildRequestMsg;
*buildResponseMsg = *lassoc::Login_buildResponseMsg;
*dump = *lassoc::Login_dump;
*initAuthnRequest = *lassoc::Login_initAuthnRequest;
*initRequest = *lassoc::Login_initRequest;
*initIdpInitiatedAuthnRequest = *lassoc::Login_initIdpInitiatedAuthnRequest;
*mustAskForConsent = *lassoc::Login_mustAskForConsent;
*mustAuthenticate = *lassoc::Login_mustAuthenticate;
*processAuthnRequestMsg = *lassoc::Login_processAuthnRequestMsg;
*processAuthnResponseMsg = *lassoc::Login_processAuthnResponseMsg;
*processRequestMsg = *lassoc::Login_processRequestMsg;
*processResponseMsg = *lassoc::Login_processResponseMsg;
*setResourceId = *lassoc::Login_setResourceId;
*validateRequestMsg = *lassoc::Login_validateRequestMsg;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::Logout ##############

package lasso::Logout;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_identity_get = *lassoc::Logout_identity_get;
*swig_identity_set = *lassoc::Logout_identity_set;
*swig_isIdentityDirty_get = *lassoc::Logout_isIdentityDirty_get;
*swig_isIdentityDirty_set = *lassoc::Logout_isIdentityDirty_set;
*swig_isSessionDirty_get = *lassoc::Logout_isSessionDirty_get;
*swig_isSessionDirty_set = *lassoc::Logout_isSessionDirty_set;
*swig_msgBody_get = *lassoc::Logout_msgBody_get;
*swig_msgBody_set = *lassoc::Logout_msgBody_set;
*swig_msgRelayState_get = *lassoc::Logout_msgRelayState_get;
*swig_msgRelayState_set = *lassoc::Logout_msgRelayState_set;
*swig_msgUrl_get = *lassoc::Logout_msgUrl_get;
*swig_msgUrl_set = *lassoc::Logout_msgUrl_set;
*swig_nameIdentifier_get = *lassoc::Logout_nameIdentifier_get;
*swig_nameIdentifier_set = *lassoc::Logout_nameIdentifier_set;
*swig_remoteProviderId_get = *lassoc::Logout_remoteProviderId_get;
*swig_remoteProviderId_set = *lassoc::Logout_remoteProviderId_set;
*swig_request_get = *lassoc::Logout_request_get;
*swig_request_set = *lassoc::Logout_request_set;
*swig_response_get = *lassoc::Logout_response_get;
*swig_response_set = *lassoc::Logout_response_set;
*swig_server_get = *lassoc::Logout_server_get;
*swig_server_set = *lassoc::Logout_server_set;
*swig_session_get = *lassoc::Logout_session_get;
*swig_session_set = *lassoc::Logout_session_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_Logout(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_Logout($self);
        delete $OWNER{$self};
    }
}

*newFromDump = *lassoc::Logout_newFromDump;
*setIdentityFromDump = *lassoc::Logout_setIdentityFromDump;
*setSessionFromDump = *lassoc::Logout_setSessionFromDump;
*buildRequestMsg = *lassoc::Logout_buildRequestMsg;
*buildResponseMsg = *lassoc::Logout_buildResponseMsg;
*dump = *lassoc::Logout_dump;
*getNextProviderId = *lassoc::Logout_getNextProviderId;
*initRequest = *lassoc::Logout_initRequest;
*processRequestMsg = *lassoc::Logout_processRequestMsg;
*processResponseMsg = *lassoc::Logout_processResponseMsg;
*resetProviderIdIndex = *lassoc::Logout_resetProviderIdIndex;
*validateRequest = *lassoc::Logout_validateRequest;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::Lecp ##############

package lasso::Lecp;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_identity_get = *lassoc::Lecp_identity_get;
*swig_identity_set = *lassoc::Lecp_identity_set;
*swig_isIdentityDirty_get = *lassoc::Lecp_isIdentityDirty_get;
*swig_isIdentityDirty_set = *lassoc::Lecp_isIdentityDirty_set;
*swig_isSessionDirty_get = *lassoc::Lecp_isSessionDirty_get;
*swig_isSessionDirty_set = *lassoc::Lecp_isSessionDirty_set;
*swig_msgBody_get = *lassoc::Lecp_msgBody_get;
*swig_msgBody_set = *lassoc::Lecp_msgBody_set;
*swig_msgRelayState_get = *lassoc::Lecp_msgRelayState_get;
*swig_msgRelayState_set = *lassoc::Lecp_msgRelayState_set;
*swig_msgUrl_get = *lassoc::Lecp_msgUrl_get;
*swig_msgUrl_set = *lassoc::Lecp_msgUrl_set;
*swig_nameIdentifier_get = *lassoc::Lecp_nameIdentifier_get;
*swig_nameIdentifier_set = *lassoc::Lecp_nameIdentifier_set;
*swig_remoteProviderId_get = *lassoc::Lecp_remoteProviderId_get;
*swig_remoteProviderId_set = *lassoc::Lecp_remoteProviderId_set;
*swig_request_get = *lassoc::Lecp_request_get;
*swig_request_set = *lassoc::Lecp_request_set;
*swig_response_get = *lassoc::Lecp_response_get;
*swig_response_set = *lassoc::Lecp_response_set;
*swig_server_get = *lassoc::Lecp_server_get;
*swig_server_set = *lassoc::Lecp_server_set;
*swig_session_get = *lassoc::Lecp_session_get;
*swig_session_set = *lassoc::Lecp_session_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_Lecp(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_Lecp($self);
        delete $OWNER{$self};
    }
}

*setIdentityFromDump = *lassoc::Lecp_setIdentityFromDump;
*setSessionFromDump = *lassoc::Lecp_setSessionFromDump;
*buildAssertion = *lassoc::Lecp_buildAssertion;
*setResourceId = *lassoc::Lecp_setResourceId;
*validateRequestMsg = *lassoc::Lecp_validateRequestMsg;
*buildAuthnRequestEnvelopeMsg = *lassoc::Lecp_buildAuthnRequestEnvelopeMsg;
*buildAuthnRequestMsg = *lassoc::Lecp_buildAuthnRequestMsg;
*buildAuthnResponseEnvelopeMsg = *lassoc::Lecp_buildAuthnResponseEnvelopeMsg;
*buildAuthnResponseMsg = *lassoc::Lecp_buildAuthnResponseMsg;
*initAuthnRequest = *lassoc::Lecp_initAuthnRequest;
*processAuthnRequestEnvelopeMsg = *lassoc::Lecp_processAuthnRequestEnvelopeMsg;
*processAuthnRequestMsg = *lassoc::Lecp_processAuthnRequestMsg;
*processAuthnResponseEnvelopeMsg = *lassoc::Lecp_processAuthnResponseEnvelopeMsg;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::NameIdentifierMapping ##############

package lasso::NameIdentifierMapping;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_targetNameIdentifier_get = *lassoc::NameIdentifierMapping_targetNameIdentifier_get;
*swig_targetNameIdentifier_set = *lassoc::NameIdentifierMapping_targetNameIdentifier_set;
*swig_identity_get = *lassoc::NameIdentifierMapping_identity_get;
*swig_identity_set = *lassoc::NameIdentifierMapping_identity_set;
*swig_isIdentityDirty_get = *lassoc::NameIdentifierMapping_isIdentityDirty_get;
*swig_isIdentityDirty_set = *lassoc::NameIdentifierMapping_isIdentityDirty_set;
*swig_isSessionDirty_get = *lassoc::NameIdentifierMapping_isSessionDirty_get;
*swig_isSessionDirty_set = *lassoc::NameIdentifierMapping_isSessionDirty_set;
*swig_msgBody_get = *lassoc::NameIdentifierMapping_msgBody_get;
*swig_msgBody_set = *lassoc::NameIdentifierMapping_msgBody_set;
*swig_msgUrl_get = *lassoc::NameIdentifierMapping_msgUrl_get;
*swig_msgUrl_set = *lassoc::NameIdentifierMapping_msgUrl_set;
*swig_nameIdentifier_get = *lassoc::NameIdentifierMapping_nameIdentifier_get;
*swig_nameIdentifier_set = *lassoc::NameIdentifierMapping_nameIdentifier_set;
*swig_remoteProviderId_get = *lassoc::NameIdentifierMapping_remoteProviderId_get;
*swig_remoteProviderId_set = *lassoc::NameIdentifierMapping_remoteProviderId_set;
*swig_request_get = *lassoc::NameIdentifierMapping_request_get;
*swig_request_set = *lassoc::NameIdentifierMapping_request_set;
*swig_response_get = *lassoc::NameIdentifierMapping_response_get;
*swig_response_set = *lassoc::NameIdentifierMapping_response_set;
*swig_server_get = *lassoc::NameIdentifierMapping_server_get;
*swig_server_set = *lassoc::NameIdentifierMapping_server_set;
*swig_session_get = *lassoc::NameIdentifierMapping_session_get;
*swig_session_set = *lassoc::NameIdentifierMapping_session_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_NameIdentifierMapping(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_NameIdentifierMapping($self);
        delete $OWNER{$self};
    }
}

*setIdentityFromDump = *lassoc::NameIdentifierMapping_setIdentityFromDump;
*setSessionFromDump = *lassoc::NameIdentifierMapping_setSessionFromDump;
*buildRequestMsg = *lassoc::NameIdentifierMapping_buildRequestMsg;
*buildResponseMsg = *lassoc::NameIdentifierMapping_buildResponseMsg;
*initRequest = *lassoc::NameIdentifierMapping_initRequest;
*processRequestMsg = *lassoc::NameIdentifierMapping_processRequestMsg;
*processResponseMsg = *lassoc::NameIdentifierMapping_processResponseMsg;
*validateRequest = *lassoc::NameIdentifierMapping_validateRequest;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : lasso::NameRegistration ##############

package lasso::NameRegistration;
@ISA = qw( lasso );
%OWNER = ();
%ITERATORS = ();
*swig_identity_get = *lassoc::NameRegistration_identity_get;
*swig_identity_set = *lassoc::NameRegistration_identity_set;
*swig_isIdentityDirty_get = *lassoc::NameRegistration_isIdentityDirty_get;
*swig_isIdentityDirty_set = *lassoc::NameRegistration_isIdentityDirty_set;
*swig_isSessionDirty_get = *lassoc::NameRegistration_isSessionDirty_get;
*swig_isSessionDirty_set = *lassoc::NameRegistration_isSessionDirty_set;
*swig_msgBody_get = *lassoc::NameRegistration_msgBody_get;
*swig_msgBody_set = *lassoc::NameRegistration_msgBody_set;
*swig_msgRelayState_get = *lassoc::NameRegistration_msgRelayState_get;
*swig_msgRelayState_set = *lassoc::NameRegistration_msgRelayState_set;
*swig_msgUrl_get = *lassoc::NameRegistration_msgUrl_get;
*swig_msgUrl_set = *lassoc::NameRegistration_msgUrl_set;
*swig_nameIdentifier_get = *lassoc::NameRegistration_nameIdentifier_get;
*swig_nameIdentifier_set = *lassoc::NameRegistration_nameIdentifier_set;
*swig_remoteProviderId_get = *lassoc::NameRegistration_remoteProviderId_get;
*swig_remoteProviderId_set = *lassoc::NameRegistration_remoteProviderId_set;
*swig_request_get = *lassoc::NameRegistration_request_get;
*swig_request_set = *lassoc::NameRegistration_request_set;
*swig_response_get = *lassoc::NameRegistration_response_get;
*swig_response_set = *lassoc::NameRegistration_response_set;
*swig_server_get = *lassoc::NameRegistration_server_get;
*swig_server_set = *lassoc::NameRegistration_server_set;
*swig_session_get = *lassoc::NameRegistration_session_get;
*swig_session_set = *lassoc::NameRegistration_session_set;
*swig_oldNameIdentifier_get = *lassoc::NameRegistration_oldNameIdentifier_get;
*swig_oldNameIdentifier_set = *lassoc::NameRegistration_oldNameIdentifier_set;
sub new {
    my $pkg = shift;
    my $self = lassoc::new_NameRegistration(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        lassoc::delete_NameRegistration($self);
        delete $OWNER{$self};
    }
}

*newFromDump = *lassoc::NameRegistration_newFromDump;
*setIdentityFromDump = *lassoc::NameRegistration_setIdentityFromDump;
*setSessionFromDump = *lassoc::NameRegistration_setSessionFromDump;
*buildRequestMsg = *lassoc::NameRegistration_buildRequestMsg;
*buildResponseMsg = *lassoc::NameRegistration_buildResponseMsg;
*dump = *lassoc::NameRegistration_dump;
*initRequest = *lassoc::NameRegistration_initRequest;
*processRequestMsg = *lassoc::NameRegistration_processRequestMsg;
*processResponseMsg = *lassoc::NameRegistration_processResponseMsg;
*validateRequest = *lassoc::NameRegistration_validateRequest;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package lasso;

*WSF_SUPPORT = *lassoc::WSF_SUPPORT;
*HTTP_METHOD_NONE = *lassoc::HTTP_METHOD_NONE;
*HTTP_METHOD_ANY = *lassoc::HTTP_METHOD_ANY;
*HTTP_METHOD_IDP_INITIATED = *lassoc::HTTP_METHOD_IDP_INITIATED;
*HTTP_METHOD_GET = *lassoc::HTTP_METHOD_GET;
*HTTP_METHOD_POST = *lassoc::HTTP_METHOD_POST;
*HTTP_METHOD_REDIRECT = *lassoc::HTTP_METHOD_REDIRECT;
*HTTP_METHOD_SOAP = *lassoc::HTTP_METHOD_SOAP;
*LIB_CONSENT_OBTAINED = *lassoc::LIB_CONSENT_OBTAINED;
*LIB_CONSENT_OBTAINED_PRIOR = *lassoc::LIB_CONSENT_OBTAINED_PRIOR;
*LIB_CONSENT_OBTAINED_CURRENT_IMPLICIT = *lassoc::LIB_CONSENT_OBTAINED_CURRENT_IMPLICIT;
*LIB_CONSENT_OBTAINED_CURRENT_EXPLICIT = *lassoc::LIB_CONSENT_OBTAINED_CURRENT_EXPLICIT;
*LIB_CONSENT_UNAVAILABLE = *lassoc::LIB_CONSENT_UNAVAILABLE;
*LIB_CONSENT_INAPPLICABLE = *lassoc::LIB_CONSENT_INAPPLICABLE;
*LIB_NAMEID_POLICY_TYPE_NONE = *lassoc::LIB_NAMEID_POLICY_TYPE_NONE;
*LIB_NAMEID_POLICY_TYPE_ONE_TIME = *lassoc::LIB_NAMEID_POLICY_TYPE_ONE_TIME;
*LIB_NAMEID_POLICY_TYPE_FEDERATED = *lassoc::LIB_NAMEID_POLICY_TYPE_FEDERATED;
*LIB_NAMEID_POLICY_TYPE_ANY = *lassoc::LIB_NAMEID_POLICY_TYPE_ANY;
*LIB_PROTOCOL_PROFILE_BRWS_ART = *lassoc::LIB_PROTOCOL_PROFILE_BRWS_ART;
*LIB_PROTOCOL_PROFILE_BRWS_POST = *lassoc::LIB_PROTOCOL_PROFILE_BRWS_POST;
*LIB_PROTOCOL_PROFILE_BRWS_LECP = *lassoc::LIB_PROTOCOL_PROFILE_BRWS_LECP;
*LIB_PROTOCOL_PROFILE_FED_TERM_IDP_HTTP = *lassoc::LIB_PROTOCOL_PROFILE_FED_TERM_IDP_HTTP;
*LIB_PROTOCOL_PROFILE_FED_TERM_IDP_SOAP = *lassoc::LIB_PROTOCOL_PROFILE_FED_TERM_IDP_SOAP;
*LIB_PROTOCOL_PROFILE_FED_TERM_SP_HTTP = *lassoc::LIB_PROTOCOL_PROFILE_FED_TERM_SP_HTTP;
*LIB_PROTOCOL_PROFILE_FED_TERM_SP_SOAP = *lassoc::LIB_PROTOCOL_PROFILE_FED_TERM_SP_SOAP;
*LIB_PROTOCOL_PROFILE_RNI_IDP_HTTP = *lassoc::LIB_PROTOCOL_PROFILE_RNI_IDP_HTTP;
*LIB_PROTOCOL_PROFILE_RNI_IDP_SOAP = *lassoc::LIB_PROTOCOL_PROFILE_RNI_IDP_SOAP;
*LIB_PROTOCOL_PROFILE_RNI_SP_HTTP = *lassoc::LIB_PROTOCOL_PROFILE_RNI_SP_HTTP;
*LIB_PROTOCOL_PROFILE_RNI_SP_SOAP = *lassoc::LIB_PROTOCOL_PROFILE_RNI_SP_SOAP;
*LIB_PROTOCOL_PROFILE_SLO_IDP_HTTP = *lassoc::LIB_PROTOCOL_PROFILE_SLO_IDP_HTTP;
*LIB_PROTOCOL_PROFILE_SLO_IDP_SOAP = *lassoc::LIB_PROTOCOL_PROFILE_SLO_IDP_SOAP;
*LIB_PROTOCOL_PROFILE_SLO_SP_HTTP = *lassoc::LIB_PROTOCOL_PROFILE_SLO_SP_HTTP;
*LIB_PROTOCOL_PROFILE_SLO_SP_SOAP = *lassoc::LIB_PROTOCOL_PROFILE_SLO_SP_SOAP;
*LOGIN_PROTOCOL_PROFILE_BRWS_ART = *lassoc::LOGIN_PROTOCOL_PROFILE_BRWS_ART;
*LOGIN_PROTOCOL_PROFILE_BRWS_POST = *lassoc::LOGIN_PROTOCOL_PROFILE_BRWS_POST;
*LOGIN_PROTOCOL_PROFILE_BRWS_LECP = *lassoc::LOGIN_PROTOCOL_PROFILE_BRWS_LECP;
*PROVIDER_ROLE_NONE = *lassoc::PROVIDER_ROLE_NONE;
*PROVIDER_ROLE_SP = *lassoc::PROVIDER_ROLE_SP;
*PROVIDER_ROLE_IDP = *lassoc::PROVIDER_ROLE_IDP;
*REQUEST_TYPE_INVALID = *lassoc::REQUEST_TYPE_INVALID;
*REQUEST_TYPE_LOGIN = *lassoc::REQUEST_TYPE_LOGIN;
*REQUEST_TYPE_LOGOUT = *lassoc::REQUEST_TYPE_LOGOUT;
*REQUEST_TYPE_DEFEDERATION = *lassoc::REQUEST_TYPE_DEFEDERATION;
*REQUEST_TYPE_NAME_REGISTRATION = *lassoc::REQUEST_TYPE_NAME_REGISTRATION;
*REQUEST_TYPE_NAME_IDENTIFIER_MAPPING = *lassoc::REQUEST_TYPE_NAME_IDENTIFIER_MAPPING;
*REQUEST_TYPE_LECP = *lassoc::REQUEST_TYPE_LECP;
*REQUEST_TYPE_DISCO_QUERY = *lassoc::REQUEST_TYPE_DISCO_QUERY;
*REQUEST_TYPE_DISCO_MODIFY = *lassoc::REQUEST_TYPE_DISCO_MODIFY;
*REQUEST_TYPE_DST_QUERY = *lassoc::REQUEST_TYPE_DST_QUERY;
*REQUEST_TYPE_DST_MODIFY = *lassoc::REQUEST_TYPE_DST_MODIFY;
*REQUEST_TYPE_SASL_REQUEST = *lassoc::REQUEST_TYPE_SASL_REQUEST;
*LIB_AUTHN_CONTEXT_CLASS_REF_INTERNET_PROTOCOL = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_INTERNET_PROTOCOL;
*LIB_AUTHN_CONTEXT_CLASS_REF_INTERNET_PROTOCOL_PASSWORD = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_INTERNET_PROTOCOL_PASSWORD;
*LIB_AUTHN_CONTEXT_CLASS_REF_MOBILE_ONE_FACTOR_UNREGISTERED = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_MOBILE_ONE_FACTOR_UNREGISTERED;
*LIB_AUTHN_CONTEXT_CLASS_REF_MOBILE_TWO_FACTOR_UNREGISTERED = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_MOBILE_TWO_FACTOR_UNREGISTERED;
*LIB_AUTHN_CONTEXT_CLASS_REF_MOBILE_ONE_FACTOR_CONTRACT = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_MOBILE_ONE_FACTOR_CONTRACT;
*LIB_AUTHN_CONTEXT_CLASS_REF_MOBILE_TWO_FACTOR_CONTRACT = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_MOBILE_TWO_FACTOR_CONTRACT;
*LIB_AUTHN_CONTEXT_CLASS_REF_PASSWORD = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_PASSWORD;
*LIB_AUTHN_CONTEXT_CLASS_REF_PASSWORD_PROTECTED_TRANSPORT = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_PASSWORD_PROTECTED_TRANSPORT;
*LIB_AUTHN_CONTEXT_CLASS_REF_PREVIOUS_SESSION = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_PREVIOUS_SESSION;
*LIB_AUTHN_CONTEXT_CLASS_REF_SMARTCARD = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_SMARTCARD;
*LIB_AUTHN_CONTEXT_CLASS_REF_SMARTCARD_PKI = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_SMARTCARD_PKI;
*LIB_AUTHN_CONTEXT_CLASS_REF_SOFTWARE_PKI = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_SOFTWARE_PKI;
*LIB_AUTHN_CONTEXT_CLASS_REF_TIME_SYNC_TOKEN = *lassoc::LIB_AUTHN_CONTEXT_CLASS_REF_TIME_SYNC_TOKEN;
*LIB_AUTHN_CONTEXT_COMPARISON_EXACT = *lassoc::LIB_AUTHN_CONTEXT_COMPARISON_EXACT;
*LIB_AUTHN_CONTEXT_COMPARISON_MINIMUM = *lassoc::LIB_AUTHN_CONTEXT_COMPARISON_MINIMUM;
*LIB_AUTHN_CONTEXT_COMPARISON_MAXIMUM = *lassoc::LIB_AUTHN_CONTEXT_COMPARISON_MAXIMUM;
*LIB_AUTHN_CONTEXT_COMPARISON_BETTER = *lassoc::LIB_AUTHN_CONTEXT_COMPARISON_BETTER;
*SAML_AUTHENTICATION_METHOD_PASSWORD = *lassoc::SAML_AUTHENTICATION_METHOD_PASSWORD;
*SAML_AUTHENTICATION_METHOD_KERBEROS = *lassoc::SAML_AUTHENTICATION_METHOD_KERBEROS;
*SAML_AUTHENTICATION_METHOD_SECURE_REMOTE_PASSWORD = *lassoc::SAML_AUTHENTICATION_METHOD_SECURE_REMOTE_PASSWORD;
*SAML_AUTHENTICATION_METHOD_HARDWARE_TOKEN = *lassoc::SAML_AUTHENTICATION_METHOD_HARDWARE_TOKEN;
*SAML_AUTHENTICATION_METHOD_SMARTCARD_PKI = *lassoc::SAML_AUTHENTICATION_METHOD_SMARTCARD_PKI;
*SAML_AUTHENTICATION_METHOD_SOFTWARE_PKI = *lassoc::SAML_AUTHENTICATION_METHOD_SOFTWARE_PKI;
*SAML_AUTHENTICATION_METHOD_PGP = *lassoc::SAML_AUTHENTICATION_METHOD_PGP;
*SAML_AUTHENTICATION_METHODS_PKI = *lassoc::SAML_AUTHENTICATION_METHODS_PKI;
*SAML_AUTHENTICATION_METHOD_XKMS = *lassoc::SAML_AUTHENTICATION_METHOD_XKMS;
*SAML_AUTHENTICATION_METHOD_XMLD_SIG = *lassoc::SAML_AUTHENTICATION_METHOD_XMLD_SIG;
*SAML_AUTHENTICATION_METHOD_UNSPECIFIED = *lassoc::SAML_AUTHENTICATION_METHOD_UNSPECIFIED;
*SAML_AUTHENTICATION_METHOD_LIBERTY = *lassoc::SAML_AUTHENTICATION_METHOD_LIBERTY;
*SIGNATURE_METHOD_RSA_SHA1 = *lassoc::SIGNATURE_METHOD_RSA_SHA1;
*SIGNATURE_METHOD_DSA_SHA1 = *lassoc::SIGNATURE_METHOD_DSA_SHA1;
*ERROR_UNDEFINED = *lassoc::ERROR_UNDEFINED;
*ERROR_UNIMPLEMENTED = *lassoc::ERROR_UNIMPLEMENTED;
*XML_ERROR_NODE_NOT_FOUND = *lassoc::XML_ERROR_NODE_NOT_FOUND;
*XML_ERROR_NODE_CONTENT_NOT_FOUND = *lassoc::XML_ERROR_NODE_CONTENT_NOT_FOUND;
*XML_ERROR_ATTR_NOT_FOUND = *lassoc::XML_ERROR_ATTR_NOT_FOUND;
*XML_ERROR_ATTR_VALUE_NOT_FOUND = *lassoc::XML_ERROR_ATTR_VALUE_NOT_FOUND;
*DS_ERROR_SIGNATURE_NOT_FOUND = *lassoc::DS_ERROR_SIGNATURE_NOT_FOUND;
*DS_ERROR_INVALID_SIGNATURE = *lassoc::DS_ERROR_INVALID_SIGNATURE;
*DS_ERROR_SIGNATURE_TMPL_CREATION_FAILED = *lassoc::DS_ERROR_SIGNATURE_TMPL_CREATION_FAILED;
*DS_ERROR_CONTEXT_CREATION_FAILED = *lassoc::DS_ERROR_CONTEXT_CREATION_FAILED;
*DS_ERROR_PUBLIC_KEY_LOAD_FAILED = *lassoc::DS_ERROR_PUBLIC_KEY_LOAD_FAILED;
*DS_ERROR_PRIVATE_KEY_LOAD_FAILED = *lassoc::DS_ERROR_PRIVATE_KEY_LOAD_FAILED;
*DS_ERROR_CERTIFICATE_LOAD_FAILED = *lassoc::DS_ERROR_CERTIFICATE_LOAD_FAILED;
*DS_ERROR_SIGNATURE_FAILED = *lassoc::DS_ERROR_SIGNATURE_FAILED;
*DS_ERROR_KEYS_MNGR_CREATION_FAILED = *lassoc::DS_ERROR_KEYS_MNGR_CREATION_FAILED;
*DS_ERROR_KEYS_MNGR_INIT_FAILED = *lassoc::DS_ERROR_KEYS_MNGR_INIT_FAILED;
*DS_ERROR_SIGNATURE_VERIFICATION_FAILED = *lassoc::DS_ERROR_SIGNATURE_VERIFICATION_FAILED;
*DS_ERROR_CA_CERT_CHAIN_LOAD_FAILED = *lassoc::DS_ERROR_CA_CERT_CHAIN_LOAD_FAILED;
*DS_ERROR_INVALID_SIGALG = *lassoc::DS_ERROR_INVALID_SIGALG;
*DS_ERROR_DIGEST_COMPUTE_FAILED = *lassoc::DS_ERROR_DIGEST_COMPUTE_FAILED;
*LASSO_DS_ERROR_SIGNATURE_TEMPLATE_NOT_FOUND = *lassoc::LASSO_DS_ERROR_SIGNATURE_TEMPLATE_NOT_FOUND;
*SERVER_ERROR_PROVIDER_NOT_FOUND = *lassoc::SERVER_ERROR_PROVIDER_NOT_FOUND;
*SERVER_ERROR_ADD_PROVIDER_FAILED = *lassoc::SERVER_ERROR_ADD_PROVIDER_FAILED;
*LOGOUT_ERROR_UNSUPPORTED_PROFILE = *lassoc::LOGOUT_ERROR_UNSUPPORTED_PROFILE;
*PROFILE_ERROR_INVALID_QUERY = *lassoc::PROFILE_ERROR_INVALID_QUERY;
*PROFILE_ERROR_INVALID_POST_MSG = *lassoc::PROFILE_ERROR_INVALID_POST_MSG;
*PROFILE_ERROR_INVALID_SOAP_MSG = *lassoc::PROFILE_ERROR_INVALID_SOAP_MSG;
*PROFILE_ERROR_MISSING_REQUEST = *lassoc::PROFILE_ERROR_MISSING_REQUEST;
*PROFILE_ERROR_INVALID_HTTP_METHOD = *lassoc::PROFILE_ERROR_INVALID_HTTP_METHOD;
*PROFILE_ERROR_INVALID_PROTOCOLPROFILE = *lassoc::PROFILE_ERROR_INVALID_PROTOCOLPROFILE;
*PROFILE_ERROR_INVALID_MSG = *lassoc::PROFILE_ERROR_INVALID_MSG;
*PROFILE_ERROR_MISSING_REMOTE_PROVIDERID = *lassoc::PROFILE_ERROR_MISSING_REMOTE_PROVIDERID;
*PROFILE_ERROR_UNSUPPORTED_PROFILE = *lassoc::PROFILE_ERROR_UNSUPPORTED_PROFILE;
*PROFILE_ERROR_UNKNOWN_PROFILE_URL = *lassoc::PROFILE_ERROR_UNKNOWN_PROFILE_URL;
*PROFILE_ERROR_IDENTITY_NOT_FOUND = *lassoc::PROFILE_ERROR_IDENTITY_NOT_FOUND;
*PROFILE_ERROR_FEDERATION_NOT_FOUND = *lassoc::PROFILE_ERROR_FEDERATION_NOT_FOUND;
*PROFILE_ERROR_NAME_IDENTIFIER_NOT_FOUND = *lassoc::PROFILE_ERROR_NAME_IDENTIFIER_NOT_FOUND;
*PROFILE_ERROR_BUILDING_QUERY_FAILED = *lassoc::PROFILE_ERROR_BUILDING_QUERY_FAILED;
*PROFILE_ERROR_BUILDING_REQUEST_FAILED = *lassoc::PROFILE_ERROR_BUILDING_REQUEST_FAILED;
*PROFILE_ERROR_BUILDING_MESSAGE_FAILED = *lassoc::PROFILE_ERROR_BUILDING_MESSAGE_FAILED;
*PROFILE_ERROR_BUILDING_RESPONSE_FAILED = *lassoc::PROFILE_ERROR_BUILDING_RESPONSE_FAILED;
*PROFILE_ERROR_SESSION_NOT_FOUND = *lassoc::PROFILE_ERROR_SESSION_NOT_FOUND;
*PROFILE_ERROR_BAD_IDENTITY_DUMP = *lassoc::PROFILE_ERROR_BAD_IDENTITY_DUMP;
*PROFILE_ERROR_BAD_SESSION_DUMP = *lassoc::PROFILE_ERROR_BAD_SESSION_DUMP;
*LASSO_PARAM_ERROR_BAD_TYPE_OR_NULL_OBJ = *lassoc::LASSO_PARAM_ERROR_BAD_TYPE_OR_NULL_OBJ;
*PARAM_ERROR_INVALID_VALUE = *lassoc::PARAM_ERROR_INVALID_VALUE;
*LASSO_PARAM_ERROR_CHECK_FAILED = *lassoc::LASSO_PARAM_ERROR_CHECK_FAILED;
*LOGIN_ERROR_FEDERATION_NOT_FOUND = *lassoc::LOGIN_ERROR_FEDERATION_NOT_FOUND;
*LOGIN_ERROR_CONSENT_NOT_OBTAINED = *lassoc::LOGIN_ERROR_CONSENT_NOT_OBTAINED;
*LOGIN_ERROR_INVALID_NAMEIDPOLICY = *lassoc::LOGIN_ERROR_INVALID_NAMEIDPOLICY;
*LOGIN_ERROR_REQUEST_DENIED = *lassoc::LOGIN_ERROR_REQUEST_DENIED;
*LOGIN_ERROR_INVALID_SIGNATURE = *lassoc::LOGIN_ERROR_INVALID_SIGNATURE;
*LOGIN_ERROR_UNSIGNED_AUTHN_REQUEST = *lassoc::LOGIN_ERROR_UNSIGNED_AUTHN_REQUEST;
*LOGIN_ERROR_STATUS_NOT_SUCCESS = *lassoc::LOGIN_ERROR_STATUS_NOT_SUCCESS;
*LOGIN_ERROR_UNKNOWN_PRINCIPAL = *lassoc::LOGIN_ERROR_UNKNOWN_PRINCIPAL;
*DEFEDERATION_ERROR_MISSING_NAME_IDENTIFIER = *lassoc::DEFEDERATION_ERROR_MISSING_NAME_IDENTIFIER;
*CHECK_VERSION_EXACT = *lassoc::CHECK_VERSION_EXACT;
*CHECK_VERSIONABI_COMPATIBLE = *lassoc::CHECK_VERSIONABI_COMPATIBLE;
*CHECK_VERSION_NUMERIC = *lassoc::CHECK_VERSION_NUMERIC;
1;
